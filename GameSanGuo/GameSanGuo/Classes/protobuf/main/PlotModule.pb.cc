// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PlotModule.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "PlotModule.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace main {

void protobuf_ShutdownFile_PlotModule_2eproto() {
  delete StoryListRequest::default_instance_;
  delete StoryListResponse::default_instance_;
  delete StoryModel::default_instance_;
  delete PlotListRequest::default_instance_;
  delete PlotListResponse::default_instance_;
  delete BossPlotListRequest::default_instance_;
  delete BossPlotListResponse::default_instance_;
  delete BossPlotBuyCountRequest::default_instance_;
  delete BossPlotBuyCountResponse::default_instance_;
  delete BossPlotModel::default_instance_;
  delete PlotModel::default_instance_;
  delete PlotEndRequest::default_instance_;
  delete PlotEndResponse::default_instance_;
  delete PlotDropItems::default_instance_;
  delete PlotQuitEndRequest::default_instance_;
  delete PlotQuitEndResponse::default_instance_;
  delete PlotDropItemMessage::default_instance_;
  delete NewHandProssRequest::default_instance_;
  delete NewHandProssResponse::default_instance_;
  delete BossStoryListRequest::default_instance_;
  delete BossStoryListResponse::default_instance_;
  delete BossStoryModel::default_instance_;
  delete StoryRewardRequest::default_instance_;
  delete StoryRewardResponse::default_instance_;
  delete PlotPrologueStartRequest::default_instance_;
  delete PlotPrologueStartResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_PlotModule_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_PlotModule_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::main::protobuf_AddDesc_ItemModule_2eproto();
  ::main::protobuf_AddDesc_FightBaseModule_2eproto();
  StoryListRequest::default_instance_ = new StoryListRequest();
  StoryListResponse::default_instance_ = new StoryListResponse();
  StoryModel::default_instance_ = new StoryModel();
  PlotListRequest::default_instance_ = new PlotListRequest();
  PlotListResponse::default_instance_ = new PlotListResponse();
  BossPlotListRequest::default_instance_ = new BossPlotListRequest();
  BossPlotListResponse::default_instance_ = new BossPlotListResponse();
  BossPlotBuyCountRequest::default_instance_ = new BossPlotBuyCountRequest();
  BossPlotBuyCountResponse::default_instance_ = new BossPlotBuyCountResponse();
  BossPlotModel::default_instance_ = new BossPlotModel();
  PlotModel::default_instance_ = new PlotModel();
  PlotEndRequest::default_instance_ = new PlotEndRequest();
  PlotEndResponse::default_instance_ = new PlotEndResponse();
  PlotDropItems::default_instance_ = new PlotDropItems();
  PlotQuitEndRequest::default_instance_ = new PlotQuitEndRequest();
  PlotQuitEndResponse::default_instance_ = new PlotQuitEndResponse();
  PlotDropItemMessage::default_instance_ = new PlotDropItemMessage();
  NewHandProssRequest::default_instance_ = new NewHandProssRequest();
  NewHandProssResponse::default_instance_ = new NewHandProssResponse();
  BossStoryListRequest::default_instance_ = new BossStoryListRequest();
  BossStoryListResponse::default_instance_ = new BossStoryListResponse();
  BossStoryModel::default_instance_ = new BossStoryModel();
  StoryRewardRequest::default_instance_ = new StoryRewardRequest();
  StoryRewardResponse::default_instance_ = new StoryRewardResponse();
  PlotPrologueStartRequest::default_instance_ = new PlotPrologueStartRequest();
  PlotPrologueStartResponse::default_instance_ = new PlotPrologueStartResponse();
  StoryListRequest::default_instance_->InitAsDefaultInstance();
  StoryListResponse::default_instance_->InitAsDefaultInstance();
  StoryModel::default_instance_->InitAsDefaultInstance();
  PlotListRequest::default_instance_->InitAsDefaultInstance();
  PlotListResponse::default_instance_->InitAsDefaultInstance();
  BossPlotListRequest::default_instance_->InitAsDefaultInstance();
  BossPlotListResponse::default_instance_->InitAsDefaultInstance();
  BossPlotBuyCountRequest::default_instance_->InitAsDefaultInstance();
  BossPlotBuyCountResponse::default_instance_->InitAsDefaultInstance();
  BossPlotModel::default_instance_->InitAsDefaultInstance();
  PlotModel::default_instance_->InitAsDefaultInstance();
  PlotEndRequest::default_instance_->InitAsDefaultInstance();
  PlotEndResponse::default_instance_->InitAsDefaultInstance();
  PlotDropItems::default_instance_->InitAsDefaultInstance();
  PlotQuitEndRequest::default_instance_->InitAsDefaultInstance();
  PlotQuitEndResponse::default_instance_->InitAsDefaultInstance();
  PlotDropItemMessage::default_instance_->InitAsDefaultInstance();
  NewHandProssRequest::default_instance_->InitAsDefaultInstance();
  NewHandProssResponse::default_instance_->InitAsDefaultInstance();
  BossStoryListRequest::default_instance_->InitAsDefaultInstance();
  BossStoryListResponse::default_instance_->InitAsDefaultInstance();
  BossStoryModel::default_instance_->InitAsDefaultInstance();
  StoryRewardRequest::default_instance_->InitAsDefaultInstance();
  StoryRewardResponse::default_instance_->InitAsDefaultInstance();
  PlotPrologueStartRequest::default_instance_->InitAsDefaultInstance();
  PlotPrologueStartResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_PlotModule_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_PlotModule_2eproto_once_);
void protobuf_AddDesc_PlotModule_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_PlotModule_2eproto_once_,
                 &protobuf_AddDesc_PlotModule_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_PlotModule_2eproto {
  StaticDescriptorInitializer_PlotModule_2eproto() {
    protobuf_AddDesc_PlotModule_2eproto();
  }
} static_descriptor_initializer_PlotModule_2eproto_;
#endif
bool PlotQuitEndType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

StoryListRequest::StoryListRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.StoryListRequest)
}

void StoryListRequest::InitAsDefaultInstance() {
}

StoryListRequest::StoryListRequest(const StoryListRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.StoryListRequest)
}

void StoryListRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoryListRequest::~StoryListRequest() {
  // @@protoc_insertion_point(destructor:main.StoryListRequest)
  SharedDtor();
}

void StoryListRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoryListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoryListRequest& StoryListRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

StoryListRequest* StoryListRequest::default_instance_ = NULL;

StoryListRequest* StoryListRequest::New() const {
  return new StoryListRequest;
}

void StoryListRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StoryListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.StoryListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.StoryListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.StoryListRequest)
  return false;
#undef DO_
}

void StoryListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.StoryListRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.StoryListRequest)
}

int StoryListRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoryListRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoryListRequest*>(&from));
}

void StoryListRequest::MergeFrom(const StoryListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StoryListRequest::CopyFrom(const StoryListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoryListRequest::IsInitialized() const {

  return true;
}

void StoryListRequest::Swap(StoryListRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoryListRequest::GetTypeName() const {
  return "main.StoryListRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int StoryListResponse::kStoryModelFieldNumber;
#endif  // !_MSC_VER

StoryListResponse::StoryListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.StoryListResponse)
}

void StoryListResponse::InitAsDefaultInstance() {
}

StoryListResponse::StoryListResponse(const StoryListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.StoryListResponse)
}

void StoryListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoryListResponse::~StoryListResponse() {
  // @@protoc_insertion_point(destructor:main.StoryListResponse)
  SharedDtor();
}

void StoryListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoryListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoryListResponse& StoryListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

StoryListResponse* StoryListResponse::default_instance_ = NULL;

StoryListResponse* StoryListResponse::New() const {
  return new StoryListResponse;
}

void StoryListResponse::Clear() {
  storymodel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StoryListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.StoryListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.StoryModel storyModel = 1;
      case 1: {
        if (tag == 10) {
         parse_storyModel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_storymodel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_storyModel;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.StoryListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.StoryListResponse)
  return false;
#undef DO_
}

void StoryListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.StoryListResponse)
  // repeated .main.StoryModel storyModel = 1;
  for (int i = 0; i < this->storymodel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->storymodel(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.StoryListResponse)
}

int StoryListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .main.StoryModel storyModel = 1;
  total_size += 1 * this->storymodel_size();
  for (int i = 0; i < this->storymodel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->storymodel(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoryListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoryListResponse*>(&from));
}

void StoryListResponse::MergeFrom(const StoryListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  storymodel_.MergeFrom(from.storymodel_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StoryListResponse::CopyFrom(const StoryListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoryListResponse::IsInitialized() const {

  return true;
}

void StoryListResponse::Swap(StoryListResponse* other) {
  if (other != this) {
    storymodel_.Swap(&other->storymodel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoryListResponse::GetTypeName() const {
  return "main.StoryListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int StoryModel::kStoryIdFieldNumber;
const int StoryModel::kIswinFieldNumber;
const int StoryModel::kStarFieldNumber;
const int StoryModel::kCoinsRateFieldNumber;
const int StoryModel::kExpRateFieldNumber;
const int StoryModel::kTimeFieldNumber;
const int StoryModel::kRewardFieldNumber;
#endif  // !_MSC_VER

StoryModel::StoryModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.StoryModel)
}

void StoryModel::InitAsDefaultInstance() {
}

StoryModel::StoryModel(const StoryModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.StoryModel)
}

void StoryModel::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  iswin_ = 0;
  star_ = 0;
  coinsrate_ = 0;
  exprate_ = 0;
  time_ = 0;
  reward_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoryModel::~StoryModel() {
  // @@protoc_insertion_point(destructor:main.StoryModel)
  SharedDtor();
}

void StoryModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoryModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoryModel& StoryModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

StoryModel* StoryModel::default_instance_ = NULL;

StoryModel* StoryModel::New() const {
  return new StoryModel;
}

void StoryModel::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StoryModel*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(storyid_, reward_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StoryModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.StoryModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_iswin;
        break;
      }

      // optional int32 iswin = 2;
      case 2: {
        if (tag == 16) {
         parse_iswin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &iswin_)));
          set_has_iswin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_star;
        break;
      }

      // optional int32 star = 3;
      case 3: {
        if (tag == 24) {
         parse_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &star_)));
          set_has_star();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_coinsRate;
        break;
      }

      // optional float coinsRate = 4;
      case 4: {
        if (tag == 37) {
         parse_coinsRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &coinsrate_)));
          set_has_coinsrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_expRate;
        break;
      }

      // optional float expRate = 5;
      case 5: {
        if (tag == 45) {
         parse_expRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &exprate_)));
          set_has_exprate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_time;
        break;
      }

      // optional int32 time = 6;
      case 6: {
        if (tag == 48) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_reward;
        break;
      }

      // optional int32 reward = 7;
      case 7: {
        if (tag == 56) {
         parse_reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.StoryModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.StoryModel)
  return false;
#undef DO_
}

void StoryModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.StoryModel)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  // optional int32 iswin = 2;
  if (has_iswin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->iswin(), output);
  }

  // optional int32 star = 3;
  if (has_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->star(), output);
  }

  // optional float coinsRate = 4;
  if (has_coinsrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->coinsrate(), output);
  }

  // optional float expRate = 5;
  if (has_exprate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->exprate(), output);
  }

  // optional int32 time = 6;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->time(), output);
  }

  // optional int32 reward = 7;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->reward(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.StoryModel)
}

int StoryModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

    // optional int32 iswin = 2;
    if (has_iswin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->iswin());
    }

    // optional int32 star = 3;
    if (has_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->star());
    }

    // optional float coinsRate = 4;
    if (has_coinsrate()) {
      total_size += 1 + 4;
    }

    // optional float expRate = 5;
    if (has_exprate()) {
      total_size += 1 + 4;
    }

    // optional int32 time = 6;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time());
    }

    // optional int32 reward = 7;
    if (has_reward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reward());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoryModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoryModel*>(&from));
}

void StoryModel::MergeFrom(const StoryModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
    if (from.has_iswin()) {
      set_iswin(from.iswin());
    }
    if (from.has_star()) {
      set_star(from.star());
    }
    if (from.has_coinsrate()) {
      set_coinsrate(from.coinsrate());
    }
    if (from.has_exprate()) {
      set_exprate(from.exprate());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StoryModel::CopyFrom(const StoryModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoryModel::IsInitialized() const {

  return true;
}

void StoryModel::Swap(StoryModel* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(iswin_, other->iswin_);
    std::swap(star_, other->star_);
    std::swap(coinsrate_, other->coinsrate_);
    std::swap(exprate_, other->exprate_);
    std::swap(time_, other->time_);
    std::swap(reward_, other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoryModel::GetTypeName() const {
  return "main.StoryModel";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotListRequest::kStoryIdFieldNumber;
const int PlotListRequest::kPoltAskIdFieldNumber;
#endif  // !_MSC_VER

PlotListRequest::PlotListRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotListRequest)
}

void PlotListRequest::InitAsDefaultInstance() {
}

PlotListRequest::PlotListRequest(const PlotListRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotListRequest)
}

void PlotListRequest::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  poltaskid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotListRequest::~PlotListRequest() {
  // @@protoc_insertion_point(destructor:main.PlotListRequest)
  SharedDtor();
}

void PlotListRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotListRequest& PlotListRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotListRequest* PlotListRequest::default_instance_ = NULL;

PlotListRequest* PlotListRequest::New() const {
  return new PlotListRequest;
}

void PlotListRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotListRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(storyid_, poltaskid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_poltAskId;
        break;
      }

      // optional int32 poltAskId = 2;
      case 2: {
        if (tag == 16) {
         parse_poltAskId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &poltaskid_)));
          set_has_poltaskid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotListRequest)
  return false;
#undef DO_
}

void PlotListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotListRequest)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  // optional int32 poltAskId = 2;
  if (has_poltaskid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->poltaskid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotListRequest)
}

int PlotListRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

    // optional int32 poltAskId = 2;
    if (has_poltaskid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->poltaskid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotListRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotListRequest*>(&from));
}

void PlotListRequest::MergeFrom(const PlotListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
    if (from.has_poltaskid()) {
      set_poltaskid(from.poltaskid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotListRequest::CopyFrom(const PlotListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotListRequest::IsInitialized() const {

  return true;
}

void PlotListRequest::Swap(PlotListRequest* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(poltaskid_, other->poltaskid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotListRequest::GetTypeName() const {
  return "main.PlotListRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotListResponse::kStateFieldNumber;
const int PlotListResponse::kPlotAskIdFieldNumber;
const int PlotListResponse::kStoryIdFieldNumber;
const int PlotListResponse::kStarFieldNumber;
const int PlotListResponse::kMaxStarFieldNumber;
const int PlotListResponse::kCanRewardFieldNumber;
const int PlotListResponse::kRewardIdFieldNumber;
const int PlotListResponse::kPlotModelFieldNumber;
#endif  // !_MSC_VER

PlotListResponse::PlotListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotListResponse)
}

void PlotListResponse::InitAsDefaultInstance() {
}

PlotListResponse::PlotListResponse(const PlotListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotListResponse)
}

void PlotListResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  plotaskid_ = 0;
  storyid_ = 0;
  star_ = 0;
  maxstar_ = 0;
  canreward_ = 0;
  rewardid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotListResponse::~PlotListResponse() {
  // @@protoc_insertion_point(destructor:main.PlotListResponse)
  SharedDtor();
}

void PlotListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotListResponse& PlotListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotListResponse* PlotListResponse::default_instance_ = NULL;

PlotListResponse* PlotListResponse::New() const {
  return new PlotListResponse;
}

void PlotListResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotListResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(state_, canreward_);
    rewardid_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  plotmodel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_plotAskId;
        break;
      }

      // optional int32 plotAskId = 2;
      case 2: {
        if (tag == 16) {
         parse_plotAskId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plotaskid_)));
          set_has_plotaskid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_storyId;
        break;
      }

      // optional int32 storyId = 3;
      case 3: {
        if (tag == 24) {
         parse_storyId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_star;
        break;
      }

      // optional int32 star = 4;
      case 4: {
        if (tag == 32) {
         parse_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &star_)));
          set_has_star();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_maxStar;
        break;
      }

      // optional int32 maxStar = 5;
      case 5: {
        if (tag == 40) {
         parse_maxStar:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxstar_)));
          set_has_maxstar();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_canReward;
        break;
      }

      // optional int32 canReward = 6;
      case 6: {
        if (tag == 48) {
         parse_canReward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &canreward_)));
          set_has_canreward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_rewardId;
        break;
      }

      // optional int32 rewardId = 7;
      case 7: {
        if (tag == 56) {
         parse_rewardId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rewardid_)));
          set_has_rewardid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_plotModel;
        break;
      }

      // repeated .main.PlotModel plotModel = 8;
      case 8: {
        if (tag == 66) {
         parse_plotModel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_plotmodel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_plotModel;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotListResponse)
  return false;
#undef DO_
}

void PlotListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotListResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional int32 plotAskId = 2;
  if (has_plotaskid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->plotaskid(), output);
  }

  // optional int32 storyId = 3;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->storyid(), output);
  }

  // optional int32 star = 4;
  if (has_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->star(), output);
  }

  // optional int32 maxStar = 5;
  if (has_maxstar()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->maxstar(), output);
  }

  // optional int32 canReward = 6;
  if (has_canreward()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->canreward(), output);
  }

  // optional int32 rewardId = 7;
  if (has_rewardid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->rewardid(), output);
  }

  // repeated .main.PlotModel plotModel = 8;
  for (int i = 0; i < this->plotmodel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->plotmodel(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotListResponse)
}

int PlotListResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 plotAskId = 2;
    if (has_plotaskid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->plotaskid());
    }

    // optional int32 storyId = 3;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

    // optional int32 star = 4;
    if (has_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->star());
    }

    // optional int32 maxStar = 5;
    if (has_maxstar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxstar());
    }

    // optional int32 canReward = 6;
    if (has_canreward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->canreward());
    }

    // optional int32 rewardId = 7;
    if (has_rewardid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rewardid());
    }

  }
  // repeated .main.PlotModel plotModel = 8;
  total_size += 1 * this->plotmodel_size();
  for (int i = 0; i < this->plotmodel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->plotmodel(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotListResponse*>(&from));
}

void PlotListResponse::MergeFrom(const PlotListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  plotmodel_.MergeFrom(from.plotmodel_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_plotaskid()) {
      set_plotaskid(from.plotaskid());
    }
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
    if (from.has_star()) {
      set_star(from.star());
    }
    if (from.has_maxstar()) {
      set_maxstar(from.maxstar());
    }
    if (from.has_canreward()) {
      set_canreward(from.canreward());
    }
    if (from.has_rewardid()) {
      set_rewardid(from.rewardid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotListResponse::CopyFrom(const PlotListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotListResponse::IsInitialized() const {

  return true;
}

void PlotListResponse::Swap(PlotListResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(plotaskid_, other->plotaskid_);
    std::swap(storyid_, other->storyid_);
    std::swap(star_, other->star_);
    std::swap(maxstar_, other->maxstar_);
    std::swap(canreward_, other->canreward_);
    std::swap(rewardid_, other->rewardid_);
    plotmodel_.Swap(&other->plotmodel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotListResponse::GetTypeName() const {
  return "main.PlotListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BossPlotListRequest::kStoryIdFieldNumber;
#endif  // !_MSC_VER

BossPlotListRequest::BossPlotListRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossPlotListRequest)
}

void BossPlotListRequest::InitAsDefaultInstance() {
}

BossPlotListRequest::BossPlotListRequest(const BossPlotListRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossPlotListRequest)
}

void BossPlotListRequest::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossPlotListRequest::~BossPlotListRequest() {
  // @@protoc_insertion_point(destructor:main.BossPlotListRequest)
  SharedDtor();
}

void BossPlotListRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossPlotListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossPlotListRequest& BossPlotListRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossPlotListRequest* BossPlotListRequest::default_instance_ = NULL;

BossPlotListRequest* BossPlotListRequest::New() const {
  return new BossPlotListRequest;
}

void BossPlotListRequest::Clear() {
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossPlotListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossPlotListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossPlotListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossPlotListRequest)
  return false;
#undef DO_
}

void BossPlotListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossPlotListRequest)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossPlotListRequest)
}

int BossPlotListRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossPlotListRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossPlotListRequest*>(&from));
}

void BossPlotListRequest::MergeFrom(const BossPlotListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossPlotListRequest::CopyFrom(const BossPlotListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossPlotListRequest::IsInitialized() const {

  return true;
}

void BossPlotListRequest::Swap(BossPlotListRequest* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossPlotListRequest::GetTypeName() const {
  return "main.BossPlotListRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int BossPlotListResponse::kBossPlotModelFieldNumber;
#endif  // !_MSC_VER

BossPlotListResponse::BossPlotListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossPlotListResponse)
}

void BossPlotListResponse::InitAsDefaultInstance() {
}

BossPlotListResponse::BossPlotListResponse(const BossPlotListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossPlotListResponse)
}

void BossPlotListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossPlotListResponse::~BossPlotListResponse() {
  // @@protoc_insertion_point(destructor:main.BossPlotListResponse)
  SharedDtor();
}

void BossPlotListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossPlotListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossPlotListResponse& BossPlotListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossPlotListResponse* BossPlotListResponse::default_instance_ = NULL;

BossPlotListResponse* BossPlotListResponse::New() const {
  return new BossPlotListResponse;
}

void BossPlotListResponse::Clear() {
  bossplotmodel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossPlotListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossPlotListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.BossPlotModel bossPlotModel = 1;
      case 1: {
        if (tag == 10) {
         parse_bossPlotModel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bossplotmodel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_bossPlotModel;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossPlotListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossPlotListResponse)
  return false;
#undef DO_
}

void BossPlotListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossPlotListResponse)
  // repeated .main.BossPlotModel bossPlotModel = 1;
  for (int i = 0; i < this->bossplotmodel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->bossplotmodel(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossPlotListResponse)
}

int BossPlotListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .main.BossPlotModel bossPlotModel = 1;
  total_size += 1 * this->bossplotmodel_size();
  for (int i = 0; i < this->bossplotmodel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bossplotmodel(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossPlotListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossPlotListResponse*>(&from));
}

void BossPlotListResponse::MergeFrom(const BossPlotListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  bossplotmodel_.MergeFrom(from.bossplotmodel_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossPlotListResponse::CopyFrom(const BossPlotListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossPlotListResponse::IsInitialized() const {

  return true;
}

void BossPlotListResponse::Swap(BossPlotListResponse* other) {
  if (other != this) {
    bossplotmodel_.Swap(&other->bossplotmodel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossPlotListResponse::GetTypeName() const {
  return "main.BossPlotListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BossPlotBuyCountRequest::kBossPlotIdFieldNumber;
#endif  // !_MSC_VER

BossPlotBuyCountRequest::BossPlotBuyCountRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossPlotBuyCountRequest)
}

void BossPlotBuyCountRequest::InitAsDefaultInstance() {
}

BossPlotBuyCountRequest::BossPlotBuyCountRequest(const BossPlotBuyCountRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossPlotBuyCountRequest)
}

void BossPlotBuyCountRequest::SharedCtor() {
  _cached_size_ = 0;
  bossplotid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossPlotBuyCountRequest::~BossPlotBuyCountRequest() {
  // @@protoc_insertion_point(destructor:main.BossPlotBuyCountRequest)
  SharedDtor();
}

void BossPlotBuyCountRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossPlotBuyCountRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossPlotBuyCountRequest& BossPlotBuyCountRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossPlotBuyCountRequest* BossPlotBuyCountRequest::default_instance_ = NULL;

BossPlotBuyCountRequest* BossPlotBuyCountRequest::New() const {
  return new BossPlotBuyCountRequest;
}

void BossPlotBuyCountRequest::Clear() {
  bossplotid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossPlotBuyCountRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossPlotBuyCountRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 bossPlotId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bossplotid_)));
          set_has_bossplotid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossPlotBuyCountRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossPlotBuyCountRequest)
  return false;
#undef DO_
}

void BossPlotBuyCountRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossPlotBuyCountRequest)
  // optional int32 bossPlotId = 1;
  if (has_bossplotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bossplotid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossPlotBuyCountRequest)
}

int BossPlotBuyCountRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 bossPlotId = 1;
    if (has_bossplotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bossplotid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossPlotBuyCountRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossPlotBuyCountRequest*>(&from));
}

void BossPlotBuyCountRequest::MergeFrom(const BossPlotBuyCountRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bossplotid()) {
      set_bossplotid(from.bossplotid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossPlotBuyCountRequest::CopyFrom(const BossPlotBuyCountRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossPlotBuyCountRequest::IsInitialized() const {

  return true;
}

void BossPlotBuyCountRequest::Swap(BossPlotBuyCountRequest* other) {
  if (other != this) {
    std::swap(bossplotid_, other->bossplotid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossPlotBuyCountRequest::GetTypeName() const {
  return "main.BossPlotBuyCountRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int BossPlotBuyCountResponse::kStateFieldNumber;
#endif  // !_MSC_VER

BossPlotBuyCountResponse::BossPlotBuyCountResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossPlotBuyCountResponse)
}

void BossPlotBuyCountResponse::InitAsDefaultInstance() {
}

BossPlotBuyCountResponse::BossPlotBuyCountResponse(const BossPlotBuyCountResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossPlotBuyCountResponse)
}

void BossPlotBuyCountResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossPlotBuyCountResponse::~BossPlotBuyCountResponse() {
  // @@protoc_insertion_point(destructor:main.BossPlotBuyCountResponse)
  SharedDtor();
}

void BossPlotBuyCountResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossPlotBuyCountResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossPlotBuyCountResponse& BossPlotBuyCountResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossPlotBuyCountResponse* BossPlotBuyCountResponse::default_instance_ = NULL;

BossPlotBuyCountResponse* BossPlotBuyCountResponse::New() const {
  return new BossPlotBuyCountResponse;
}

void BossPlotBuyCountResponse::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossPlotBuyCountResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossPlotBuyCountResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossPlotBuyCountResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossPlotBuyCountResponse)
  return false;
#undef DO_
}

void BossPlotBuyCountResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossPlotBuyCountResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossPlotBuyCountResponse)
}

int BossPlotBuyCountResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossPlotBuyCountResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossPlotBuyCountResponse*>(&from));
}

void BossPlotBuyCountResponse::MergeFrom(const BossPlotBuyCountResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossPlotBuyCountResponse::CopyFrom(const BossPlotBuyCountResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossPlotBuyCountResponse::IsInitialized() const {

  return true;
}

void BossPlotBuyCountResponse::Swap(BossPlotBuyCountResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossPlotBuyCountResponse::GetTypeName() const {
  return "main.BossPlotBuyCountResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BossPlotModel::kPlotIdFieldNumber;
const int BossPlotModel::kRankFieldNumber;
const int BossPlotModel::kItemIdsFieldNumber;
const int BossPlotModel::kPowerFieldNumber;
const int BossPlotModel::kZhandouFieldNumber;
const int BossPlotModel::kExpFieldNumber;
const int BossPlotModel::kGoldFieldNumber;
const int BossPlotModel::kInfoFieldNumber;
const int BossPlotModel::kCanJoinCountFieldNumber;
const int BossPlotModel::kCanBuyCountFieldNumber;
const int BossPlotModel::kCanJoinFieldNumber;
const int BossPlotModel::kPriceFieldNumber;
const int BossPlotModel::kBuyCountFieldNumber;
#endif  // !_MSC_VER

BossPlotModel::BossPlotModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossPlotModel)
}

void BossPlotModel::InitAsDefaultInstance() {
}

BossPlotModel::BossPlotModel(const BossPlotModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossPlotModel)
}

void BossPlotModel::SharedCtor() {
  _cached_size_ = 0;
  plotid_ = 0;
  rank_ = 0;
  power_ = 0;
  zhandou_ = 0;
  exp_ = 0;
  gold_ = 0;
  info_ = 0;
  canjoincount_ = 0;
  canbuycount_ = 0;
  canjoin_ = 0;
  price_ = 0;
  buycount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossPlotModel::~BossPlotModel() {
  // @@protoc_insertion_point(destructor:main.BossPlotModel)
  SharedDtor();
}

void BossPlotModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossPlotModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossPlotModel& BossPlotModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossPlotModel* BossPlotModel::default_instance_ = NULL;

BossPlotModel* BossPlotModel::New() const {
  return new BossPlotModel;
}

void BossPlotModel::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BossPlotModel*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 251) {
    ZR_(plotid_, rank_);
    ZR_(power_, info_);
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(canjoincount_, buycount_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  itemids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossPlotModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossPlotModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 plotId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plotid_)));
          set_has_plotid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rank;
        break;
      }

      // optional int32 rank = 2;
      case 2: {
        if (tag == 16) {
         parse_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemIds;
        break;
      }

      // repeated int32 itemIds = 3;
      case 3: {
        if (tag == 24) {
         parse_itemIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_itemids())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_itemids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemIds;
        if (input->ExpectTag(32)) goto parse_power;
        break;
      }

      // optional int32 power = 4;
      case 4: {
        if (tag == 32) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_zhandou;
        break;
      }

      // optional int32 zhandou = 5;
      case 5: {
        if (tag == 40) {
         parse_zhandou:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zhandou_)));
          set_has_zhandou();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_exp;
        break;
      }

      // optional int32 exp = 6;
      case 6: {
        if (tag == 48) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_gold;
        break;
      }

      // optional int32 gold = 7;
      case 7: {
        if (tag == 56) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_info;
        break;
      }

      // optional int32 info = 8;
      case 8: {
        if (tag == 64) {
         parse_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &info_)));
          set_has_info();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_canJoinCount;
        break;
      }

      // optional int32 canJoinCount = 9;
      case 9: {
        if (tag == 72) {
         parse_canJoinCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &canjoincount_)));
          set_has_canjoincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_canBuyCount;
        break;
      }

      // optional int32 canBuyCount = 10;
      case 10: {
        if (tag == 80) {
         parse_canBuyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &canbuycount_)));
          set_has_canbuycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_canJoin;
        break;
      }

      // optional int32 canJoin = 11;
      case 11: {
        if (tag == 88) {
         parse_canJoin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &canjoin_)));
          set_has_canjoin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_price;
        break;
      }

      // optional int32 price = 12 [default = 0];
      case 12: {
        if (tag == 96) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_buyCount;
        break;
      }

      // optional int32 buyCount = 13;
      case 13: {
        if (tag == 104) {
         parse_buyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buycount_)));
          set_has_buycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossPlotModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossPlotModel)
  return false;
#undef DO_
}

void BossPlotModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossPlotModel)
  // optional int32 plotId = 1;
  if (has_plotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->plotid(), output);
  }

  // optional int32 rank = 2;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rank(), output);
  }

  // repeated int32 itemIds = 3;
  for (int i = 0; i < this->itemids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->itemids(i), output);
  }

  // optional int32 power = 4;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->power(), output);
  }

  // optional int32 zhandou = 5;
  if (has_zhandou()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->zhandou(), output);
  }

  // optional int32 exp = 6;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->exp(), output);
  }

  // optional int32 gold = 7;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->gold(), output);
  }

  // optional int32 info = 8;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->info(), output);
  }

  // optional int32 canJoinCount = 9;
  if (has_canjoincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->canjoincount(), output);
  }

  // optional int32 canBuyCount = 10;
  if (has_canbuycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->canbuycount(), output);
  }

  // optional int32 canJoin = 11;
  if (has_canjoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->canjoin(), output);
  }

  // optional int32 price = 12 [default = 0];
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->price(), output);
  }

  // optional int32 buyCount = 13;
  if (has_buycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->buycount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossPlotModel)
}

int BossPlotModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 plotId = 1;
    if (has_plotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->plotid());
    }

    // optional int32 rank = 2;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rank());
    }

    // optional int32 power = 4;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

    // optional int32 zhandou = 5;
    if (has_zhandou()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zhandou());
    }

    // optional int32 exp = 6;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 gold = 7;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

    // optional int32 info = 8;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 canJoinCount = 9;
    if (has_canjoincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->canjoincount());
    }

    // optional int32 canBuyCount = 10;
    if (has_canbuycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->canbuycount());
    }

    // optional int32 canJoin = 11;
    if (has_canjoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->canjoin());
    }

    // optional int32 price = 12 [default = 0];
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

    // optional int32 buyCount = 13;
    if (has_buycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buycount());
    }

  }
  // repeated int32 itemIds = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->itemids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->itemids(i));
    }
    total_size += 1 * this->itemids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossPlotModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossPlotModel*>(&from));
}

void BossPlotModel::MergeFrom(const BossPlotModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  itemids_.MergeFrom(from.itemids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_plotid()) {
      set_plotid(from.plotid());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
    if (from.has_zhandou()) {
      set_zhandou(from.zhandou());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_canjoincount()) {
      set_canjoincount(from.canjoincount());
    }
    if (from.has_canbuycount()) {
      set_canbuycount(from.canbuycount());
    }
    if (from.has_canjoin()) {
      set_canjoin(from.canjoin());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_buycount()) {
      set_buycount(from.buycount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossPlotModel::CopyFrom(const BossPlotModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossPlotModel::IsInitialized() const {

  return true;
}

void BossPlotModel::Swap(BossPlotModel* other) {
  if (other != this) {
    std::swap(plotid_, other->plotid_);
    std::swap(rank_, other->rank_);
    itemids_.Swap(&other->itemids_);
    std::swap(power_, other->power_);
    std::swap(zhandou_, other->zhandou_);
    std::swap(exp_, other->exp_);
    std::swap(gold_, other->gold_);
    std::swap(info_, other->info_);
    std::swap(canjoincount_, other->canjoincount_);
    std::swap(canbuycount_, other->canbuycount_);
    std::swap(canjoin_, other->canjoin_);
    std::swap(price_, other->price_);
    std::swap(buycount_, other->buycount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossPlotModel::GetTypeName() const {
  return "main.BossPlotModel";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotModel::kPlotIdFieldNumber;
const int PlotModel::kRankFieldNumber;
const int PlotModel::kItemIdsFieldNumber;
const int PlotModel::kPowerFieldNumber;
const int PlotModel::kZhandouFieldNumber;
const int PlotModel::kExpFieldNumber;
const int PlotModel::kGoldFieldNumber;
const int PlotModel::kInfoFieldNumber;
const int PlotModel::kOpenStateFieldNumber;
const int PlotModel::kJoinCountFieldNumber;
#endif  // !_MSC_VER

PlotModel::PlotModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotModel)
}

void PlotModel::InitAsDefaultInstance() {
}

PlotModel::PlotModel(const PlotModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotModel)
}

void PlotModel::SharedCtor() {
  _cached_size_ = 0;
  plotid_ = 0;
  rank_ = 0;
  power_ = 0;
  zhandou_ = 0;
  exp_ = 0;
  gold_ = 0;
  info_ = 0;
  openstate_ = 1;
  joincount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotModel::~PlotModel() {
  // @@protoc_insertion_point(destructor:main.PlotModel)
  SharedDtor();
}

void PlotModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotModel& PlotModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotModel* PlotModel::default_instance_ = NULL;

PlotModel* PlotModel::New() const {
  return new PlotModel;
}

void PlotModel::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotModel*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 251) {
    ZR_(plotid_, rank_);
    ZR_(power_, info_);
  }
  if (_has_bits_[8 / 32] & 768) {
    openstate_ = 1;
    joincount_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  itemids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 plotId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plotid_)));
          set_has_plotid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rank;
        break;
      }

      // optional int32 rank = 2;
      case 2: {
        if (tag == 16) {
         parse_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemIds;
        break;
      }

      // repeated int32 itemIds = 3;
      case 3: {
        if (tag == 24) {
         parse_itemIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_itemids())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_itemids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemIds;
        if (input->ExpectTag(32)) goto parse_power;
        break;
      }

      // optional int32 power = 4;
      case 4: {
        if (tag == 32) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_zhandou;
        break;
      }

      // optional int32 zhandou = 5;
      case 5: {
        if (tag == 40) {
         parse_zhandou:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zhandou_)));
          set_has_zhandou();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_exp;
        break;
      }

      // optional int32 exp = 6;
      case 6: {
        if (tag == 48) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_gold;
        break;
      }

      // optional int32 gold = 7;
      case 7: {
        if (tag == 56) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_info;
        break;
      }

      // optional int32 info = 8;
      case 8: {
        if (tag == 64) {
         parse_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &info_)));
          set_has_info();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_openState;
        break;
      }

      // optional int32 openState = 9 [default = 1];
      case 9: {
        if (tag == 72) {
         parse_openState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &openstate_)));
          set_has_openstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_joinCount;
        break;
      }

      // optional int32 joinCount = 10 [default = 0];
      case 10: {
        if (tag == 80) {
         parse_joinCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &joincount_)));
          set_has_joincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotModel)
  return false;
#undef DO_
}

void PlotModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotModel)
  // optional int32 plotId = 1;
  if (has_plotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->plotid(), output);
  }

  // optional int32 rank = 2;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rank(), output);
  }

  // repeated int32 itemIds = 3;
  for (int i = 0; i < this->itemids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->itemids(i), output);
  }

  // optional int32 power = 4;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->power(), output);
  }

  // optional int32 zhandou = 5;
  if (has_zhandou()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->zhandou(), output);
  }

  // optional int32 exp = 6;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->exp(), output);
  }

  // optional int32 gold = 7;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->gold(), output);
  }

  // optional int32 info = 8;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->info(), output);
  }

  // optional int32 openState = 9 [default = 1];
  if (has_openstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->openstate(), output);
  }

  // optional int32 joinCount = 10 [default = 0];
  if (has_joincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->joincount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotModel)
}

int PlotModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 plotId = 1;
    if (has_plotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->plotid());
    }

    // optional int32 rank = 2;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rank());
    }

    // optional int32 power = 4;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

    // optional int32 zhandou = 5;
    if (has_zhandou()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zhandou());
    }

    // optional int32 exp = 6;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 gold = 7;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

    // optional int32 info = 8;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 openState = 9 [default = 1];
    if (has_openstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->openstate());
    }

    // optional int32 joinCount = 10 [default = 0];
    if (has_joincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->joincount());
    }

  }
  // repeated int32 itemIds = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->itemids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->itemids(i));
    }
    total_size += 1 * this->itemids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotModel*>(&from));
}

void PlotModel::MergeFrom(const PlotModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  itemids_.MergeFrom(from.itemids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_plotid()) {
      set_plotid(from.plotid());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
    if (from.has_zhandou()) {
      set_zhandou(from.zhandou());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_openstate()) {
      set_openstate(from.openstate());
    }
    if (from.has_joincount()) {
      set_joincount(from.joincount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotModel::CopyFrom(const PlotModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotModel::IsInitialized() const {

  return true;
}

void PlotModel::Swap(PlotModel* other) {
  if (other != this) {
    std::swap(plotid_, other->plotid_);
    std::swap(rank_, other->rank_);
    itemids_.Swap(&other->itemids_);
    std::swap(power_, other->power_);
    std::swap(zhandou_, other->zhandou_);
    std::swap(exp_, other->exp_);
    std::swap(gold_, other->gold_);
    std::swap(info_, other->info_);
    std::swap(openstate_, other->openstate_);
    std::swap(joincount_, other->joincount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotModel::GetTypeName() const {
  return "main.PlotModel";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlotEndRequest::PlotEndRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotEndRequest)
}

void PlotEndRequest::InitAsDefaultInstance() {
}

PlotEndRequest::PlotEndRequest(const PlotEndRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotEndRequest)
}

void PlotEndRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotEndRequest::~PlotEndRequest() {
  // @@protoc_insertion_point(destructor:main.PlotEndRequest)
  SharedDtor();
}

void PlotEndRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotEndRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotEndRequest& PlotEndRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotEndRequest* PlotEndRequest::default_instance_ = NULL;

PlotEndRequest* PlotEndRequest::New() const {
  return new PlotEndRequest;
}

void PlotEndRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotEndRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotEndRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotEndRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotEndRequest)
  return false;
#undef DO_
}

void PlotEndRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotEndRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotEndRequest)
}

int PlotEndRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotEndRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotEndRequest*>(&from));
}

void PlotEndRequest::MergeFrom(const PlotEndRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotEndRequest::CopyFrom(const PlotEndRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotEndRequest::IsInitialized() const {

  return true;
}

void PlotEndRequest::Swap(PlotEndRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotEndRequest::GetTypeName() const {
  return "main.PlotEndRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotEndResponse::kStateFieldNumber;
const int PlotEndResponse::kRatingFieldNumber;
const int PlotEndResponse::kExpFieldNumber;
const int PlotEndResponse::kGoldFieldNumber;
const int PlotEndResponse::kPlotDropItemsFieldNumber;
#endif  // !_MSC_VER

PlotEndResponse::PlotEndResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotEndResponse)
}

void PlotEndResponse::InitAsDefaultInstance() {
}

PlotEndResponse::PlotEndResponse(const PlotEndResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotEndResponse)
}

void PlotEndResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  rating_ = 0;
  exp_ = 0;
  gold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotEndResponse::~PlotEndResponse() {
  // @@protoc_insertion_point(destructor:main.PlotEndResponse)
  SharedDtor();
}

void PlotEndResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotEndResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotEndResponse& PlotEndResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotEndResponse* PlotEndResponse::default_instance_ = NULL;

PlotEndResponse* PlotEndResponse::New() const {
  return new PlotEndResponse;
}

void PlotEndResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotEndResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(state_, gold_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  plotdropitems_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotEndResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotEndResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rating;
        break;
      }

      // optional int32 rating = 2;
      case 2: {
        if (tag == 16) {
         parse_rating:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rating_)));
          set_has_rating();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_exp;
        break;
      }

      // optional int32 exp = 3;
      case 3: {
        if (tag == 24) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_gold;
        break;
      }

      // optional int32 gold = 4;
      case 4: {
        if (tag == 32) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plotDropItems;
        break;
      }

      // repeated .main.PlotDropItems plotDropItems = 5;
      case 5: {
        if (tag == 42) {
         parse_plotDropItems:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_plotdropitems()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plotDropItems;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotEndResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotEndResponse)
  return false;
#undef DO_
}

void PlotEndResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotEndResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional int32 rating = 2;
  if (has_rating()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rating(), output);
  }

  // optional int32 exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->exp(), output);
  }

  // optional int32 gold = 4;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gold(), output);
  }

  // repeated .main.PlotDropItems plotDropItems = 5;
  for (int i = 0; i < this->plotdropitems_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->plotdropitems(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotEndResponse)
}

int PlotEndResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 rating = 2;
    if (has_rating()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rating());
    }

    // optional int32 exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 gold = 4;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

  }
  // repeated .main.PlotDropItems plotDropItems = 5;
  total_size += 1 * this->plotdropitems_size();
  for (int i = 0; i < this->plotdropitems_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->plotdropitems(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotEndResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotEndResponse*>(&from));
}

void PlotEndResponse::MergeFrom(const PlotEndResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  plotdropitems_.MergeFrom(from.plotdropitems_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_rating()) {
      set_rating(from.rating());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotEndResponse::CopyFrom(const PlotEndResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotEndResponse::IsInitialized() const {

  return true;
}

void PlotEndResponse::Swap(PlotEndResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(rating_, other->rating_);
    std::swap(exp_, other->exp_);
    std::swap(gold_, other->gold_);
    plotdropitems_.Swap(&other->plotdropitems_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotEndResponse::GetTypeName() const {
  return "main.PlotEndResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotDropItems::kOfficerCardsFieldNumber;
const int PlotDropItems::kEquipmentCardsFieldNumber;
const int PlotDropItems::kPropsCardsFieldNumber;
const int PlotDropItems::kConsumableCardsFieldNumber;
const int PlotDropItems::kFragmentCardsFieldNumber;
const int PlotDropItems::kMaterialItemProtosFieldNumber;
#endif  // !_MSC_VER

PlotDropItems::PlotDropItems()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotDropItems)
}

void PlotDropItems::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  officercards_ = const_cast< ::main::OfficerCardItemProto*>(
      ::main::OfficerCardItemProto::internal_default_instance());
#else
  officercards_ = const_cast< ::main::OfficerCardItemProto*>(&::main::OfficerCardItemProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  equipmentcards_ = const_cast< ::main::EquipmentCardItemProto*>(
      ::main::EquipmentCardItemProto::internal_default_instance());
#else
  equipmentcards_ = const_cast< ::main::EquipmentCardItemProto*>(&::main::EquipmentCardItemProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  propscards_ = const_cast< ::main::PropsCardItemProto*>(
      ::main::PropsCardItemProto::internal_default_instance());
#else
  propscards_ = const_cast< ::main::PropsCardItemProto*>(&::main::PropsCardItemProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  consumablecards_ = const_cast< ::main::ConsumableCardItemProto*>(
      ::main::ConsumableCardItemProto::internal_default_instance());
#else
  consumablecards_ = const_cast< ::main::ConsumableCardItemProto*>(&::main::ConsumableCardItemProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  fragmentcards_ = const_cast< ::main::OfficerFragmentCardItemProto*>(
      ::main::OfficerFragmentCardItemProto::internal_default_instance());
#else
  fragmentcards_ = const_cast< ::main::OfficerFragmentCardItemProto*>(&::main::OfficerFragmentCardItemProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  materialitemprotos_ = const_cast< ::main::MaterialItemProto*>(
      ::main::MaterialItemProto::internal_default_instance());
#else
  materialitemprotos_ = const_cast< ::main::MaterialItemProto*>(&::main::MaterialItemProto::default_instance());
#endif
}

PlotDropItems::PlotDropItems(const PlotDropItems& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotDropItems)
}

void PlotDropItems::SharedCtor() {
  _cached_size_ = 0;
  officercards_ = NULL;
  equipmentcards_ = NULL;
  propscards_ = NULL;
  consumablecards_ = NULL;
  fragmentcards_ = NULL;
  materialitemprotos_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotDropItems::~PlotDropItems() {
  // @@protoc_insertion_point(destructor:main.PlotDropItems)
  SharedDtor();
}

void PlotDropItems::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete officercards_;
    delete equipmentcards_;
    delete propscards_;
    delete consumablecards_;
    delete fragmentcards_;
    delete materialitemprotos_;
  }
}

void PlotDropItems::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotDropItems& PlotDropItems::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotDropItems* PlotDropItems::default_instance_ = NULL;

PlotDropItems* PlotDropItems::New() const {
  return new PlotDropItems;
}

void PlotDropItems::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_officercards()) {
      if (officercards_ != NULL) officercards_->::main::OfficerCardItemProto::Clear();
    }
    if (has_equipmentcards()) {
      if (equipmentcards_ != NULL) equipmentcards_->::main::EquipmentCardItemProto::Clear();
    }
    if (has_propscards()) {
      if (propscards_ != NULL) propscards_->::main::PropsCardItemProto::Clear();
    }
    if (has_consumablecards()) {
      if (consumablecards_ != NULL) consumablecards_->::main::ConsumableCardItemProto::Clear();
    }
    if (has_fragmentcards()) {
      if (fragmentcards_ != NULL) fragmentcards_->::main::OfficerFragmentCardItemProto::Clear();
    }
    if (has_materialitemprotos()) {
      if (materialitemprotos_ != NULL) materialitemprotos_->::main::MaterialItemProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotDropItems::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotDropItems)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .main.OfficerCardItemProto officerCards = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_officercards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_equipmentCards;
        break;
      }

      // optional .main.EquipmentCardItemProto equipmentCards = 2;
      case 2: {
        if (tag == 18) {
         parse_equipmentCards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_equipmentcards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_propsCards;
        break;
      }

      // optional .main.PropsCardItemProto propsCards = 3;
      case 3: {
        if (tag == 26) {
         parse_propsCards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_propscards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_consumableCards;
        break;
      }

      // optional .main.ConsumableCardItemProto consumableCards = 4;
      case 4: {
        if (tag == 34) {
         parse_consumableCards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_consumablecards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_fragmentCards;
        break;
      }

      // optional .main.OfficerFragmentCardItemProto fragmentCards = 5;
      case 5: {
        if (tag == 42) {
         parse_fragmentCards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fragmentcards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_materialItemProtos;
        break;
      }

      // optional .main.MaterialItemProto materialItemProtos = 6;
      case 6: {
        if (tag == 50) {
         parse_materialItemProtos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_materialitemprotos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotDropItems)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotDropItems)
  return false;
#undef DO_
}

void PlotDropItems::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotDropItems)
  // optional .main.OfficerCardItemProto officerCards = 1;
  if (has_officercards()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->officercards(), output);
  }

  // optional .main.EquipmentCardItemProto equipmentCards = 2;
  if (has_equipmentcards()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->equipmentcards(), output);
  }

  // optional .main.PropsCardItemProto propsCards = 3;
  if (has_propscards()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->propscards(), output);
  }

  // optional .main.ConsumableCardItemProto consumableCards = 4;
  if (has_consumablecards()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->consumablecards(), output);
  }

  // optional .main.OfficerFragmentCardItemProto fragmentCards = 5;
  if (has_fragmentcards()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->fragmentcards(), output);
  }

  // optional .main.MaterialItemProto materialItemProtos = 6;
  if (has_materialitemprotos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->materialitemprotos(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotDropItems)
}

int PlotDropItems::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .main.OfficerCardItemProto officerCards = 1;
    if (has_officercards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->officercards());
    }

    // optional .main.EquipmentCardItemProto equipmentCards = 2;
    if (has_equipmentcards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->equipmentcards());
    }

    // optional .main.PropsCardItemProto propsCards = 3;
    if (has_propscards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->propscards());
    }

    // optional .main.ConsumableCardItemProto consumableCards = 4;
    if (has_consumablecards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->consumablecards());
    }

    // optional .main.OfficerFragmentCardItemProto fragmentCards = 5;
    if (has_fragmentcards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fragmentcards());
    }

    // optional .main.MaterialItemProto materialItemProtos = 6;
    if (has_materialitemprotos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->materialitemprotos());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotDropItems::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotDropItems*>(&from));
}

void PlotDropItems::MergeFrom(const PlotDropItems& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_officercards()) {
      mutable_officercards()->::main::OfficerCardItemProto::MergeFrom(from.officercards());
    }
    if (from.has_equipmentcards()) {
      mutable_equipmentcards()->::main::EquipmentCardItemProto::MergeFrom(from.equipmentcards());
    }
    if (from.has_propscards()) {
      mutable_propscards()->::main::PropsCardItemProto::MergeFrom(from.propscards());
    }
    if (from.has_consumablecards()) {
      mutable_consumablecards()->::main::ConsumableCardItemProto::MergeFrom(from.consumablecards());
    }
    if (from.has_fragmentcards()) {
      mutable_fragmentcards()->::main::OfficerFragmentCardItemProto::MergeFrom(from.fragmentcards());
    }
    if (from.has_materialitemprotos()) {
      mutable_materialitemprotos()->::main::MaterialItemProto::MergeFrom(from.materialitemprotos());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotDropItems::CopyFrom(const PlotDropItems& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotDropItems::IsInitialized() const {

  return true;
}

void PlotDropItems::Swap(PlotDropItems* other) {
  if (other != this) {
    std::swap(officercards_, other->officercards_);
    std::swap(equipmentcards_, other->equipmentcards_);
    std::swap(propscards_, other->propscards_);
    std::swap(consumablecards_, other->consumablecards_);
    std::swap(fragmentcards_, other->fragmentcards_);
    std::swap(materialitemprotos_, other->materialitemprotos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotDropItems::GetTypeName() const {
  return "main.PlotDropItems";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotQuitEndRequest::kStoryIdFieldNumber;
const int PlotQuitEndRequest::kPlotIdFieldNumber;
const int PlotQuitEndRequest::kTypeFieldNumber;
#endif  // !_MSC_VER

PlotQuitEndRequest::PlotQuitEndRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotQuitEndRequest)
}

void PlotQuitEndRequest::InitAsDefaultInstance() {
}

PlotQuitEndRequest::PlotQuitEndRequest(const PlotQuitEndRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotQuitEndRequest)
}

void PlotQuitEndRequest::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  plotid_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotQuitEndRequest::~PlotQuitEndRequest() {
  // @@protoc_insertion_point(destructor:main.PlotQuitEndRequest)
  SharedDtor();
}

void PlotQuitEndRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotQuitEndRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotQuitEndRequest& PlotQuitEndRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotQuitEndRequest* PlotQuitEndRequest::default_instance_ = NULL;

PlotQuitEndRequest* PlotQuitEndRequest::New() const {
  return new PlotQuitEndRequest;
}

void PlotQuitEndRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotQuitEndRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(storyid_, plotid_);
    type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotQuitEndRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotQuitEndRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_plotId;
        break;
      }

      // optional int32 plotId = 2;
      case 2: {
        if (tag == 16) {
         parse_plotId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plotid_)));
          set_has_plotid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .main.PlotQuitEndType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::main::PlotQuitEndType_IsValid(value)) {
            set_type(static_cast< ::main::PlotQuitEndType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotQuitEndRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotQuitEndRequest)
  return false;
#undef DO_
}

void PlotQuitEndRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotQuitEndRequest)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  // optional int32 plotId = 2;
  if (has_plotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->plotid(), output);
  }

  // optional .main.PlotQuitEndType type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotQuitEndRequest)
}

int PlotQuitEndRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

    // optional int32 plotId = 2;
    if (has_plotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->plotid());
    }

    // optional .main.PlotQuitEndType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotQuitEndRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotQuitEndRequest*>(&from));
}

void PlotQuitEndRequest::MergeFrom(const PlotQuitEndRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
    if (from.has_plotid()) {
      set_plotid(from.plotid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotQuitEndRequest::CopyFrom(const PlotQuitEndRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotQuitEndRequest::IsInitialized() const {

  return true;
}

void PlotQuitEndRequest::Swap(PlotQuitEndRequest* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(plotid_, other->plotid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotQuitEndRequest::GetTypeName() const {
  return "main.PlotQuitEndRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotQuitEndResponse::kStateFieldNumber;
const int PlotQuitEndResponse::kRatingFieldNumber;
const int PlotQuitEndResponse::kExpFieldNumber;
const int PlotQuitEndResponse::kGoldFieldNumber;
const int PlotQuitEndResponse::kPlotDropItemsFieldNumber;
const int PlotQuitEndResponse::kMeritoriousFieldNumber;
const int PlotQuitEndResponse::kLianDanFieldNumber;
const int PlotQuitEndResponse::kAddExpFieldNumber;
const int PlotQuitEndResponse::kTypeFieldNumber;
const int PlotQuitEndResponse::kOldLevelFieldNumber;
const int PlotQuitEndResponse::kCooIdFieldNumber;
const int PlotQuitEndResponse::kPlotHarryCountFieldNumber;
const int PlotQuitEndResponse::kXiyuFieldNumber;
#endif  // !_MSC_VER

PlotQuitEndResponse::PlotQuitEndResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotQuitEndResponse)
}

void PlotQuitEndResponse::InitAsDefaultInstance() {
}

PlotQuitEndResponse::PlotQuitEndResponse(const PlotQuitEndResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotQuitEndResponse)
}

void PlotQuitEndResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  rating_ = 0;
  exp_ = 0;
  gold_ = 0;
  meritorious_ = 0;
  liandan_ = 0;
  addexp_ = 0;
  type_ = 0;
  oldlevel_ = 0;
  cooid_ = 0;
  plotharrycount_ = 0;
  xiyu_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotQuitEndResponse::~PlotQuitEndResponse() {
  // @@protoc_insertion_point(destructor:main.PlotQuitEndResponse)
  SharedDtor();
}

void PlotQuitEndResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotQuitEndResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotQuitEndResponse& PlotQuitEndResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotQuitEndResponse* PlotQuitEndResponse::default_instance_ = NULL;

PlotQuitEndResponse* PlotQuitEndResponse::New() const {
  return new PlotQuitEndResponse;
}

void PlotQuitEndResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlotQuitEndResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 239) {
    ZR_(state_, gold_);
    ZR_(meritorious_, addexp_);
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(type_, xiyu_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  plotdropitems_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotQuitEndResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotQuitEndResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rating;
        break;
      }

      // optional int32 rating = 2;
      case 2: {
        if (tag == 16) {
         parse_rating:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rating_)));
          set_has_rating();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_exp;
        break;
      }

      // optional int32 exp = 3;
      case 3: {
        if (tag == 24) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_gold;
        break;
      }

      // optional int32 gold = 4;
      case 4: {
        if (tag == 32) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plotDropItems;
        break;
      }

      // repeated .main.PlotDropItemMessage plotDropItems = 5;
      case 5: {
        if (tag == 42) {
         parse_plotDropItems:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_plotdropitems()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plotDropItems;
        if (input->ExpectTag(48)) goto parse_meritorious;
        break;
      }

      // optional int32 meritorious = 6;
      case 6: {
        if (tag == 48) {
         parse_meritorious:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meritorious_)));
          set_has_meritorious();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_lianDan;
        break;
      }

      // optional int32 lianDan = 7;
      case 7: {
        if (tag == 56) {
         parse_lianDan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &liandan_)));
          set_has_liandan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_addExp;
        break;
      }

      // optional int32 addExp = 8;
      case 8: {
        if (tag == 64) {
         parse_addExp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &addexp_)));
          set_has_addexp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_type;
        break;
      }

      // optional int32 type = 9;
      case 9: {
        if (tag == 72) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_oldLevel;
        break;
      }

      // optional int32 oldLevel = 10 [default = 0];
      case 10: {
        if (tag == 80) {
         parse_oldLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &oldlevel_)));
          set_has_oldlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_cooId;
        break;
      }

      // optional int32 cooId = 11 [default = 0];
      case 11: {
        if (tag == 88) {
         parse_cooId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cooid_)));
          set_has_cooid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_plotHarryCount;
        break;
      }

      // optional int32 plotHarryCount = 12;
      case 12: {
        if (tag == 96) {
         parse_plotHarryCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plotharrycount_)));
          set_has_plotharrycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_xiyu;
        break;
      }

      // optional int32 xiyu = 13;
      case 13: {
        if (tag == 104) {
         parse_xiyu:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &xiyu_)));
          set_has_xiyu();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotQuitEndResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotQuitEndResponse)
  return false;
#undef DO_
}

void PlotQuitEndResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotQuitEndResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional int32 rating = 2;
  if (has_rating()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rating(), output);
  }

  // optional int32 exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->exp(), output);
  }

  // optional int32 gold = 4;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gold(), output);
  }

  // repeated .main.PlotDropItemMessage plotDropItems = 5;
  for (int i = 0; i < this->plotdropitems_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->plotdropitems(i), output);
  }

  // optional int32 meritorious = 6;
  if (has_meritorious()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->meritorious(), output);
  }

  // optional int32 lianDan = 7;
  if (has_liandan()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->liandan(), output);
  }

  // optional int32 addExp = 8;
  if (has_addexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->addexp(), output);
  }

  // optional int32 type = 9;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->type(), output);
  }

  // optional int32 oldLevel = 10 [default = 0];
  if (has_oldlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->oldlevel(), output);
  }

  // optional int32 cooId = 11 [default = 0];
  if (has_cooid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->cooid(), output);
  }

  // optional int32 plotHarryCount = 12;
  if (has_plotharrycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->plotharrycount(), output);
  }

  // optional int32 xiyu = 13;
  if (has_xiyu()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->xiyu(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotQuitEndResponse)
}

int PlotQuitEndResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 rating = 2;
    if (has_rating()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rating());
    }

    // optional int32 exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 gold = 4;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

    // optional int32 meritorious = 6;
    if (has_meritorious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meritorious());
    }

    // optional int32 lianDan = 7;
    if (has_liandan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->liandan());
    }

    // optional int32 addExp = 8;
    if (has_addexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->addexp());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 type = 9;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 oldLevel = 10 [default = 0];
    if (has_oldlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->oldlevel());
    }

    // optional int32 cooId = 11 [default = 0];
    if (has_cooid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cooid());
    }

    // optional int32 plotHarryCount = 12;
    if (has_plotharrycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->plotharrycount());
    }

    // optional int32 xiyu = 13;
    if (has_xiyu()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->xiyu());
    }

  }
  // repeated .main.PlotDropItemMessage plotDropItems = 5;
  total_size += 1 * this->plotdropitems_size();
  for (int i = 0; i < this->plotdropitems_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->plotdropitems(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotQuitEndResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotQuitEndResponse*>(&from));
}

void PlotQuitEndResponse::MergeFrom(const PlotQuitEndResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  plotdropitems_.MergeFrom(from.plotdropitems_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_rating()) {
      set_rating(from.rating());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_meritorious()) {
      set_meritorious(from.meritorious());
    }
    if (from.has_liandan()) {
      set_liandan(from.liandan());
    }
    if (from.has_addexp()) {
      set_addexp(from.addexp());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_oldlevel()) {
      set_oldlevel(from.oldlevel());
    }
    if (from.has_cooid()) {
      set_cooid(from.cooid());
    }
    if (from.has_plotharrycount()) {
      set_plotharrycount(from.plotharrycount());
    }
    if (from.has_xiyu()) {
      set_xiyu(from.xiyu());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotQuitEndResponse::CopyFrom(const PlotQuitEndResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotQuitEndResponse::IsInitialized() const {

  return true;
}

void PlotQuitEndResponse::Swap(PlotQuitEndResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(rating_, other->rating_);
    std::swap(exp_, other->exp_);
    std::swap(gold_, other->gold_);
    plotdropitems_.Swap(&other->plotdropitems_);
    std::swap(meritorious_, other->meritorious_);
    std::swap(liandan_, other->liandan_);
    std::swap(addexp_, other->addexp_);
    std::swap(type_, other->type_);
    std::swap(oldlevel_, other->oldlevel_);
    std::swap(cooid_, other->cooid_);
    std::swap(plotharrycount_, other->plotharrycount_);
    std::swap(xiyu_, other->xiyu_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotQuitEndResponse::GetTypeName() const {
  return "main.PlotQuitEndResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotDropItemMessage::kItemFieldNumber;
#endif  // !_MSC_VER

PlotDropItemMessage::PlotDropItemMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotDropItemMessage)
}

void PlotDropItemMessage::InitAsDefaultInstance() {
}

PlotDropItemMessage::PlotDropItemMessage(const PlotDropItemMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotDropItemMessage)
}

void PlotDropItemMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotDropItemMessage::~PlotDropItemMessage() {
  // @@protoc_insertion_point(destructor:main.PlotDropItemMessage)
  SharedDtor();
}

void PlotDropItemMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotDropItemMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotDropItemMessage& PlotDropItemMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotDropItemMessage* PlotDropItemMessage::default_instance_ = NULL;

PlotDropItemMessage* PlotDropItemMessage::New() const {
  return new PlotDropItemMessage;
}

void PlotDropItemMessage::Clear() {
  item_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotDropItemMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotDropItemMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.PlotDropItems item = 1;
      case 1: {
        if (tag == 10) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_item;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotDropItemMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotDropItemMessage)
  return false;
#undef DO_
}

void PlotDropItemMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotDropItemMessage)
  // repeated .main.PlotDropItems item = 1;
  for (int i = 0; i < this->item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotDropItemMessage)
}

int PlotDropItemMessage::ByteSize() const {
  int total_size = 0;

  // repeated .main.PlotDropItems item = 1;
  total_size += 1 * this->item_size();
  for (int i = 0; i < this->item_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotDropItemMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotDropItemMessage*>(&from));
}

void PlotDropItemMessage::MergeFrom(const PlotDropItemMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_.MergeFrom(from.item_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotDropItemMessage::CopyFrom(const PlotDropItemMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotDropItemMessage::IsInitialized() const {

  return true;
}

void PlotDropItemMessage::Swap(PlotDropItemMessage* other) {
  if (other != this) {
    item_.Swap(&other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotDropItemMessage::GetTypeName() const {
  return "main.PlotDropItemMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NewHandProssRequest::NewHandProssRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.NewHandProssRequest)
}

void NewHandProssRequest::InitAsDefaultInstance() {
}

NewHandProssRequest::NewHandProssRequest(const NewHandProssRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.NewHandProssRequest)
}

void NewHandProssRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewHandProssRequest::~NewHandProssRequest() {
  // @@protoc_insertion_point(destructor:main.NewHandProssRequest)
  SharedDtor();
}

void NewHandProssRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewHandProssRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewHandProssRequest& NewHandProssRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

NewHandProssRequest* NewHandProssRequest::default_instance_ = NULL;

NewHandProssRequest* NewHandProssRequest::New() const {
  return new NewHandProssRequest;
}

void NewHandProssRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NewHandProssRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.NewHandProssRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.NewHandProssRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.NewHandProssRequest)
  return false;
#undef DO_
}

void NewHandProssRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.NewHandProssRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.NewHandProssRequest)
}

int NewHandProssRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewHandProssRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewHandProssRequest*>(&from));
}

void NewHandProssRequest::MergeFrom(const NewHandProssRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NewHandProssRequest::CopyFrom(const NewHandProssRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewHandProssRequest::IsInitialized() const {

  return true;
}

void NewHandProssRequest::Swap(NewHandProssRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewHandProssRequest::GetTypeName() const {
  return "main.NewHandProssRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NewHandProssResponse::NewHandProssResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.NewHandProssResponse)
}

void NewHandProssResponse::InitAsDefaultInstance() {
}

NewHandProssResponse::NewHandProssResponse(const NewHandProssResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.NewHandProssResponse)
}

void NewHandProssResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewHandProssResponse::~NewHandProssResponse() {
  // @@protoc_insertion_point(destructor:main.NewHandProssResponse)
  SharedDtor();
}

void NewHandProssResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewHandProssResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewHandProssResponse& NewHandProssResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

NewHandProssResponse* NewHandProssResponse::default_instance_ = NULL;

NewHandProssResponse* NewHandProssResponse::New() const {
  return new NewHandProssResponse;
}

void NewHandProssResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NewHandProssResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.NewHandProssResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.NewHandProssResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.NewHandProssResponse)
  return false;
#undef DO_
}

void NewHandProssResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.NewHandProssResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.NewHandProssResponse)
}

int NewHandProssResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewHandProssResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewHandProssResponse*>(&from));
}

void NewHandProssResponse::MergeFrom(const NewHandProssResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NewHandProssResponse::CopyFrom(const NewHandProssResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewHandProssResponse::IsInitialized() const {

  return true;
}

void NewHandProssResponse::Swap(NewHandProssResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewHandProssResponse::GetTypeName() const {
  return "main.NewHandProssResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

BossStoryListRequest::BossStoryListRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossStoryListRequest)
}

void BossStoryListRequest::InitAsDefaultInstance() {
}

BossStoryListRequest::BossStoryListRequest(const BossStoryListRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossStoryListRequest)
}

void BossStoryListRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossStoryListRequest::~BossStoryListRequest() {
  // @@protoc_insertion_point(destructor:main.BossStoryListRequest)
  SharedDtor();
}

void BossStoryListRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossStoryListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossStoryListRequest& BossStoryListRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossStoryListRequest* BossStoryListRequest::default_instance_ = NULL;

BossStoryListRequest* BossStoryListRequest::New() const {
  return new BossStoryListRequest;
}

void BossStoryListRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossStoryListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossStoryListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossStoryListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossStoryListRequest)
  return false;
#undef DO_
}

void BossStoryListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossStoryListRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossStoryListRequest)
}

int BossStoryListRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossStoryListRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossStoryListRequest*>(&from));
}

void BossStoryListRequest::MergeFrom(const BossStoryListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossStoryListRequest::CopyFrom(const BossStoryListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossStoryListRequest::IsInitialized() const {

  return true;
}

void BossStoryListRequest::Swap(BossStoryListRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossStoryListRequest::GetTypeName() const {
  return "main.BossStoryListRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int BossStoryListResponse::kBossStoryModelFieldNumber;
#endif  // !_MSC_VER

BossStoryListResponse::BossStoryListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossStoryListResponse)
}

void BossStoryListResponse::InitAsDefaultInstance() {
}

BossStoryListResponse::BossStoryListResponse(const BossStoryListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossStoryListResponse)
}

void BossStoryListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossStoryListResponse::~BossStoryListResponse() {
  // @@protoc_insertion_point(destructor:main.BossStoryListResponse)
  SharedDtor();
}

void BossStoryListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossStoryListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossStoryListResponse& BossStoryListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossStoryListResponse* BossStoryListResponse::default_instance_ = NULL;

BossStoryListResponse* BossStoryListResponse::New() const {
  return new BossStoryListResponse;
}

void BossStoryListResponse::Clear() {
  bossstorymodel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossStoryListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossStoryListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.BossStoryModel BossStoryModel = 1;
      case 1: {
        if (tag == 10) {
         parse_BossStoryModel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bossstorymodel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_BossStoryModel;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossStoryListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossStoryListResponse)
  return false;
#undef DO_
}

void BossStoryListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossStoryListResponse)
  // repeated .main.BossStoryModel BossStoryModel = 1;
  for (int i = 0; i < this->bossstorymodel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->bossstorymodel(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossStoryListResponse)
}

int BossStoryListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .main.BossStoryModel BossStoryModel = 1;
  total_size += 1 * this->bossstorymodel_size();
  for (int i = 0; i < this->bossstorymodel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bossstorymodel(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossStoryListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossStoryListResponse*>(&from));
}

void BossStoryListResponse::MergeFrom(const BossStoryListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  bossstorymodel_.MergeFrom(from.bossstorymodel_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossStoryListResponse::CopyFrom(const BossStoryListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossStoryListResponse::IsInitialized() const {

  return true;
}

void BossStoryListResponse::Swap(BossStoryListResponse* other) {
  if (other != this) {
    bossstorymodel_.Swap(&other->bossstorymodel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossStoryListResponse::GetTypeName() const {
  return "main.BossStoryListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BossStoryModel::kStoryIdFieldNumber;
#endif  // !_MSC_VER

BossStoryModel::BossStoryModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BossStoryModel)
}

void BossStoryModel::InitAsDefaultInstance() {
}

BossStoryModel::BossStoryModel(const BossStoryModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BossStoryModel)
}

void BossStoryModel::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BossStoryModel::~BossStoryModel() {
  // @@protoc_insertion_point(destructor:main.BossStoryModel)
  SharedDtor();
}

void BossStoryModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BossStoryModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BossStoryModel& BossStoryModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

BossStoryModel* BossStoryModel::default_instance_ = NULL;

BossStoryModel* BossStoryModel::New() const {
  return new BossStoryModel;
}

void BossStoryModel::Clear() {
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BossStoryModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BossStoryModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BossStoryModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BossStoryModel)
  return false;
#undef DO_
}

void BossStoryModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BossStoryModel)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BossStoryModel)
}

int BossStoryModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BossStoryModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BossStoryModel*>(&from));
}

void BossStoryModel::MergeFrom(const BossStoryModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BossStoryModel::CopyFrom(const BossStoryModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BossStoryModel::IsInitialized() const {

  return true;
}

void BossStoryModel::Swap(BossStoryModel* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BossStoryModel::GetTypeName() const {
  return "main.BossStoryModel";
}


// ===================================================================

#ifndef _MSC_VER
const int StoryRewardRequest::kStoryIdFieldNumber;
#endif  // !_MSC_VER

StoryRewardRequest::StoryRewardRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.StoryRewardRequest)
}

void StoryRewardRequest::InitAsDefaultInstance() {
}

StoryRewardRequest::StoryRewardRequest(const StoryRewardRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.StoryRewardRequest)
}

void StoryRewardRequest::SharedCtor() {
  _cached_size_ = 0;
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoryRewardRequest::~StoryRewardRequest() {
  // @@protoc_insertion_point(destructor:main.StoryRewardRequest)
  SharedDtor();
}

void StoryRewardRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoryRewardRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoryRewardRequest& StoryRewardRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

StoryRewardRequest* StoryRewardRequest::default_instance_ = NULL;

StoryRewardRequest* StoryRewardRequest::New() const {
  return new StoryRewardRequest;
}

void StoryRewardRequest::Clear() {
  storyid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StoryRewardRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.StoryRewardRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 storyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &storyid_)));
          set_has_storyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.StoryRewardRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.StoryRewardRequest)
  return false;
#undef DO_
}

void StoryRewardRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.StoryRewardRequest)
  // optional int32 storyId = 1;
  if (has_storyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->storyid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.StoryRewardRequest)
}

int StoryRewardRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 storyId = 1;
    if (has_storyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->storyid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoryRewardRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoryRewardRequest*>(&from));
}

void StoryRewardRequest::MergeFrom(const StoryRewardRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_storyid()) {
      set_storyid(from.storyid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StoryRewardRequest::CopyFrom(const StoryRewardRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoryRewardRequest::IsInitialized() const {

  return true;
}

void StoryRewardRequest::Swap(StoryRewardRequest* other) {
  if (other != this) {
    std::swap(storyid_, other->storyid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoryRewardRequest::GetTypeName() const {
  return "main.StoryRewardRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int StoryRewardResponse::kStateFieldNumber;
#endif  // !_MSC_VER

StoryRewardResponse::StoryRewardResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.StoryRewardResponse)
}

void StoryRewardResponse::InitAsDefaultInstance() {
}

StoryRewardResponse::StoryRewardResponse(const StoryRewardResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.StoryRewardResponse)
}

void StoryRewardResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoryRewardResponse::~StoryRewardResponse() {
  // @@protoc_insertion_point(destructor:main.StoryRewardResponse)
  SharedDtor();
}

void StoryRewardResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoryRewardResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoryRewardResponse& StoryRewardResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

StoryRewardResponse* StoryRewardResponse::default_instance_ = NULL;

StoryRewardResponse* StoryRewardResponse::New() const {
  return new StoryRewardResponse;
}

void StoryRewardResponse::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StoryRewardResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.StoryRewardResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.StoryRewardResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.StoryRewardResponse)
  return false;
#undef DO_
}

void StoryRewardResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.StoryRewardResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.StoryRewardResponse)
}

int StoryRewardResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoryRewardResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoryRewardResponse*>(&from));
}

void StoryRewardResponse::MergeFrom(const StoryRewardResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StoryRewardResponse::CopyFrom(const StoryRewardResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoryRewardResponse::IsInitialized() const {

  return true;
}

void StoryRewardResponse::Swap(StoryRewardResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoryRewardResponse::GetTypeName() const {
  return "main.StoryRewardResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlotPrologueStartRequest::PlotPrologueStartRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotPrologueStartRequest)
}

void PlotPrologueStartRequest::InitAsDefaultInstance() {
}

PlotPrologueStartRequest::PlotPrologueStartRequest(const PlotPrologueStartRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotPrologueStartRequest)
}

void PlotPrologueStartRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotPrologueStartRequest::~PlotPrologueStartRequest() {
  // @@protoc_insertion_point(destructor:main.PlotPrologueStartRequest)
  SharedDtor();
}

void PlotPrologueStartRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlotPrologueStartRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotPrologueStartRequest& PlotPrologueStartRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotPrologueStartRequest* PlotPrologueStartRequest::default_instance_ = NULL;

PlotPrologueStartRequest* PlotPrologueStartRequest::New() const {
  return new PlotPrologueStartRequest;
}

void PlotPrologueStartRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotPrologueStartRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotPrologueStartRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotPrologueStartRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotPrologueStartRequest)
  return false;
#undef DO_
}

void PlotPrologueStartRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotPrologueStartRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotPrologueStartRequest)
}

int PlotPrologueStartRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotPrologueStartRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotPrologueStartRequest*>(&from));
}

void PlotPrologueStartRequest::MergeFrom(const PlotPrologueStartRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotPrologueStartRequest::CopyFrom(const PlotPrologueStartRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotPrologueStartRequest::IsInitialized() const {

  return true;
}

void PlotPrologueStartRequest::Swap(PlotPrologueStartRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotPrologueStartRequest::GetTypeName() const {
  return "main.PlotPrologueStartRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int PlotPrologueStartResponse::kRespFieldNumber;
#endif  // !_MSC_VER

PlotPrologueStartResponse::PlotPrologueStartResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.PlotPrologueStartResponse)
}

void PlotPrologueStartResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  resp_ = const_cast< ::main::PveStarResponse*>(
      ::main::PveStarResponse::internal_default_instance());
#else
  resp_ = const_cast< ::main::PveStarResponse*>(&::main::PveStarResponse::default_instance());
#endif
}

PlotPrologueStartResponse::PlotPrologueStartResponse(const PlotPrologueStartResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.PlotPrologueStartResponse)
}

void PlotPrologueStartResponse::SharedCtor() {
  _cached_size_ = 0;
  resp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlotPrologueStartResponse::~PlotPrologueStartResponse() {
  // @@protoc_insertion_point(destructor:main.PlotPrologueStartResponse)
  SharedDtor();
}

void PlotPrologueStartResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete resp_;
  }
}

void PlotPrologueStartResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlotPrologueStartResponse& PlotPrologueStartResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PlotModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PlotModule_2eproto();
#endif
  return *default_instance_;
}

PlotPrologueStartResponse* PlotPrologueStartResponse::default_instance_ = NULL;

PlotPrologueStartResponse* PlotPrologueStartResponse::New() const {
  return new PlotPrologueStartResponse;
}

void PlotPrologueStartResponse::Clear() {
  if (has_resp()) {
    if (resp_ != NULL) resp_->::main::PveStarResponse::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlotPrologueStartResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.PlotPrologueStartResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .main.PveStarResponse resp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.PlotPrologueStartResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.PlotPrologueStartResponse)
  return false;
#undef DO_
}

void PlotPrologueStartResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.PlotPrologueStartResponse)
  // optional .main.PveStarResponse resp = 1;
  if (has_resp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->resp(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.PlotPrologueStartResponse)
}

int PlotPrologueStartResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .main.PveStarResponse resp = 1;
    if (has_resp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->resp());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlotPrologueStartResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlotPrologueStartResponse*>(&from));
}

void PlotPrologueStartResponse::MergeFrom(const PlotPrologueStartResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resp()) {
      mutable_resp()->::main::PveStarResponse::MergeFrom(from.resp());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlotPrologueStartResponse::CopyFrom(const PlotPrologueStartResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlotPrologueStartResponse::IsInitialized() const {

  return true;
}

void PlotPrologueStartResponse::Swap(PlotPrologueStartResponse* other) {
  if (other != this) {
    std::swap(resp_, other->resp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlotPrologueStartResponse::GetTypeName() const {
  return "main.PlotPrologueStartResponse";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

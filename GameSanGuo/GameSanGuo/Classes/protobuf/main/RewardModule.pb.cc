// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RewardModule.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "RewardModule.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace main {

void protobuf_ShutdownFile_RewardModule_2eproto() {
  delete RewardLevelUpEntryRequest::default_instance_;
  delete RewardLevelUpEntryResponse::default_instance_;
  delete RewardLevelUpPurchRequest::default_instance_;
  delete RewardLevelUpPurchResponse::default_instance_;
  delete RewardSalaryEntryRequest::default_instance_;
  delete RewardSalaryEntryResponse::default_instance_;
  delete RewardGetSalaryRequest::default_instance_;
  delete RewardGetSalaryResponse::default_instance_;
  delete RewardRecoverPowerEntryRequest::default_instance_;
  delete RewardRecoverPowerEntryResponse::default_instance_;
  delete RewardRecoverPowerPurchRequest::default_instance_;
  delete RewardRecoverPowerPurchResponse::default_instance_;
  delete RewardGodPrayEntryRequest::default_instance_;
  delete RewardGodPrayEntryResponse::default_instance_;
  delete GodRewardInfo::default_instance_;
  delete RewardGodPrayAddRequest::default_instance_;
  delete RewardGodPrayAddResponse::default_instance_;
  delete RewardRegLotteryEntryRequest::default_instance_;
  delete RewardRegLotteryEntryResponse::default_instance_;
  delete RewardRegLotteryGetRequest::default_instance_;
  delete RewardRegLotteryGetResponse::default_instance_;
  delete RewardNoticeMessage::default_instance_;
  delete RewardTypeState::default_instance_;
  delete RewardLianDanTimeRequest::default_instance_;
  delete RewardLianDanTimeResponse::default_instance_;
  delete RewardLianDanRequest::default_instance_;
  delete RewardLianDanResponse::default_instance_;
  delete RewardRegLotteryPush::default_instance_;
  delete RewardBindAccountRequest::default_instance_;
  delete RewardBindAccountResponse::default_instance_;
  delete RewardItemListProto::default_instance_;
  delete RewardBindAccountInfoRequest::default_instance_;
  delete RewardBindAccountInfoResponse::default_instance_;
  delete BindMailRequest::default_instance_;
  delete BindMailResponse::default_instance_;
  delete RewardBindMailRequest::default_instance_;
  delete RewardBindMailResponse::default_instance_;
  delete ExchangeCodeEntryRequest::default_instance_;
  delete ExchangeCodeEntryResponse::default_instance_;
  delete ExchangeCodeInfoRequest::default_instance_;
  delete ExchangeCodeInfoResponse::default_instance_;
  delete RewardInfoProto::default_instance_;
  delete FirstPayRewardResponse::default_instance_;
  delete FirstPayRewardItemProto::default_instance_;
  delete SigninDetailRequest::default_instance_;
  delete SigninDetailResponse::default_instance_;
  delete SigninCell::default_instance_;
  delete SigninRewardRequest::default_instance_;
  delete SigninRewardResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_RewardModule_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_RewardModule_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::main::protobuf_AddDesc_ItemModule_2eproto();
  RewardLevelUpEntryRequest::default_instance_ = new RewardLevelUpEntryRequest();
  RewardLevelUpEntryResponse::default_instance_ = new RewardLevelUpEntryResponse();
  RewardLevelUpPurchRequest::default_instance_ = new RewardLevelUpPurchRequest();
  RewardLevelUpPurchResponse::default_instance_ = new RewardLevelUpPurchResponse();
  RewardSalaryEntryRequest::default_instance_ = new RewardSalaryEntryRequest();
  RewardSalaryEntryResponse::default_instance_ = new RewardSalaryEntryResponse();
  RewardGetSalaryRequest::default_instance_ = new RewardGetSalaryRequest();
  RewardGetSalaryResponse::default_instance_ = new RewardGetSalaryResponse();
  RewardRecoverPowerEntryRequest::default_instance_ = new RewardRecoverPowerEntryRequest();
  RewardRecoverPowerEntryResponse::default_instance_ = new RewardRecoverPowerEntryResponse();
  RewardRecoverPowerPurchRequest::default_instance_ = new RewardRecoverPowerPurchRequest();
  RewardRecoverPowerPurchResponse::default_instance_ = new RewardRecoverPowerPurchResponse();
  RewardGodPrayEntryRequest::default_instance_ = new RewardGodPrayEntryRequest();
  RewardGodPrayEntryResponse::default_instance_ = new RewardGodPrayEntryResponse();
  GodRewardInfo::default_instance_ = new GodRewardInfo();
  RewardGodPrayAddRequest::default_instance_ = new RewardGodPrayAddRequest();
  RewardGodPrayAddResponse::default_instance_ = new RewardGodPrayAddResponse();
  RewardRegLotteryEntryRequest::default_instance_ = new RewardRegLotteryEntryRequest();
  RewardRegLotteryEntryResponse::default_instance_ = new RewardRegLotteryEntryResponse();
  RewardRegLotteryGetRequest::default_instance_ = new RewardRegLotteryGetRequest();
  RewardRegLotteryGetResponse::default_instance_ = new RewardRegLotteryGetResponse();
  RewardNoticeMessage::default_instance_ = new RewardNoticeMessage();
  RewardTypeState::default_instance_ = new RewardTypeState();
  RewardLianDanTimeRequest::default_instance_ = new RewardLianDanTimeRequest();
  RewardLianDanTimeResponse::default_instance_ = new RewardLianDanTimeResponse();
  RewardLianDanRequest::default_instance_ = new RewardLianDanRequest();
  RewardLianDanResponse::default_instance_ = new RewardLianDanResponse();
  RewardRegLotteryPush::default_instance_ = new RewardRegLotteryPush();
  RewardBindAccountRequest::default_instance_ = new RewardBindAccountRequest();
  RewardBindAccountResponse::default_instance_ = new RewardBindAccountResponse();
  RewardItemListProto::default_instance_ = new RewardItemListProto();
  RewardBindAccountInfoRequest::default_instance_ = new RewardBindAccountInfoRequest();
  RewardBindAccountInfoResponse::default_instance_ = new RewardBindAccountInfoResponse();
  BindMailRequest::default_instance_ = new BindMailRequest();
  BindMailResponse::default_instance_ = new BindMailResponse();
  RewardBindMailRequest::default_instance_ = new RewardBindMailRequest();
  RewardBindMailResponse::default_instance_ = new RewardBindMailResponse();
  ExchangeCodeEntryRequest::default_instance_ = new ExchangeCodeEntryRequest();
  ExchangeCodeEntryResponse::default_instance_ = new ExchangeCodeEntryResponse();
  ExchangeCodeInfoRequest::default_instance_ = new ExchangeCodeInfoRequest();
  ExchangeCodeInfoResponse::default_instance_ = new ExchangeCodeInfoResponse();
  RewardInfoProto::default_instance_ = new RewardInfoProto();
  FirstPayRewardResponse::default_instance_ = new FirstPayRewardResponse();
  FirstPayRewardItemProto::default_instance_ = new FirstPayRewardItemProto();
  SigninDetailRequest::default_instance_ = new SigninDetailRequest();
  SigninDetailResponse::default_instance_ = new SigninDetailResponse();
  SigninCell::default_instance_ = new SigninCell();
  SigninRewardRequest::default_instance_ = new SigninRewardRequest();
  SigninRewardResponse::default_instance_ = new SigninRewardResponse();
  RewardLevelUpEntryRequest::default_instance_->InitAsDefaultInstance();
  RewardLevelUpEntryResponse::default_instance_->InitAsDefaultInstance();
  RewardLevelUpPurchRequest::default_instance_->InitAsDefaultInstance();
  RewardLevelUpPurchResponse::default_instance_->InitAsDefaultInstance();
  RewardSalaryEntryRequest::default_instance_->InitAsDefaultInstance();
  RewardSalaryEntryResponse::default_instance_->InitAsDefaultInstance();
  RewardGetSalaryRequest::default_instance_->InitAsDefaultInstance();
  RewardGetSalaryResponse::default_instance_->InitAsDefaultInstance();
  RewardRecoverPowerEntryRequest::default_instance_->InitAsDefaultInstance();
  RewardRecoverPowerEntryResponse::default_instance_->InitAsDefaultInstance();
  RewardRecoverPowerPurchRequest::default_instance_->InitAsDefaultInstance();
  RewardRecoverPowerPurchResponse::default_instance_->InitAsDefaultInstance();
  RewardGodPrayEntryRequest::default_instance_->InitAsDefaultInstance();
  RewardGodPrayEntryResponse::default_instance_->InitAsDefaultInstance();
  GodRewardInfo::default_instance_->InitAsDefaultInstance();
  RewardGodPrayAddRequest::default_instance_->InitAsDefaultInstance();
  RewardGodPrayAddResponse::default_instance_->InitAsDefaultInstance();
  RewardRegLotteryEntryRequest::default_instance_->InitAsDefaultInstance();
  RewardRegLotteryEntryResponse::default_instance_->InitAsDefaultInstance();
  RewardRegLotteryGetRequest::default_instance_->InitAsDefaultInstance();
  RewardRegLotteryGetResponse::default_instance_->InitAsDefaultInstance();
  RewardNoticeMessage::default_instance_->InitAsDefaultInstance();
  RewardTypeState::default_instance_->InitAsDefaultInstance();
  RewardLianDanTimeRequest::default_instance_->InitAsDefaultInstance();
  RewardLianDanTimeResponse::default_instance_->InitAsDefaultInstance();
  RewardLianDanRequest::default_instance_->InitAsDefaultInstance();
  RewardLianDanResponse::default_instance_->InitAsDefaultInstance();
  RewardRegLotteryPush::default_instance_->InitAsDefaultInstance();
  RewardBindAccountRequest::default_instance_->InitAsDefaultInstance();
  RewardBindAccountResponse::default_instance_->InitAsDefaultInstance();
  RewardItemListProto::default_instance_->InitAsDefaultInstance();
  RewardBindAccountInfoRequest::default_instance_->InitAsDefaultInstance();
  RewardBindAccountInfoResponse::default_instance_->InitAsDefaultInstance();
  BindMailRequest::default_instance_->InitAsDefaultInstance();
  BindMailResponse::default_instance_->InitAsDefaultInstance();
  RewardBindMailRequest::default_instance_->InitAsDefaultInstance();
  RewardBindMailResponse::default_instance_->InitAsDefaultInstance();
  ExchangeCodeEntryRequest::default_instance_->InitAsDefaultInstance();
  ExchangeCodeEntryResponse::default_instance_->InitAsDefaultInstance();
  ExchangeCodeInfoRequest::default_instance_->InitAsDefaultInstance();
  ExchangeCodeInfoResponse::default_instance_->InitAsDefaultInstance();
  RewardInfoProto::default_instance_->InitAsDefaultInstance();
  FirstPayRewardResponse::default_instance_->InitAsDefaultInstance();
  FirstPayRewardItemProto::default_instance_->InitAsDefaultInstance();
  SigninDetailRequest::default_instance_->InitAsDefaultInstance();
  SigninDetailResponse::default_instance_->InitAsDefaultInstance();
  SigninCell::default_instance_->InitAsDefaultInstance();
  SigninRewardRequest::default_instance_->InitAsDefaultInstance();
  SigninRewardResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_RewardModule_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_RewardModule_2eproto_once_);
void protobuf_AddDesc_RewardModule_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_RewardModule_2eproto_once_,
                 &protobuf_AddDesc_RewardModule_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_RewardModule_2eproto {
  StaticDescriptorInitializer_RewardModule_2eproto() {
    protobuf_AddDesc_RewardModule_2eproto();
  }
} static_descriptor_initializer_RewardModule_2eproto_;
#endif
bool SignState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardLevelUpEntryRequest::RewardLevelUpEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLevelUpEntryRequest)
}

void RewardLevelUpEntryRequest::InitAsDefaultInstance() {
}

RewardLevelUpEntryRequest::RewardLevelUpEntryRequest(const RewardLevelUpEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLevelUpEntryRequest)
}

void RewardLevelUpEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLevelUpEntryRequest::~RewardLevelUpEntryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardLevelUpEntryRequest)
  SharedDtor();
}

void RewardLevelUpEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLevelUpEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLevelUpEntryRequest& RewardLevelUpEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLevelUpEntryRequest* RewardLevelUpEntryRequest::default_instance_ = NULL;

RewardLevelUpEntryRequest* RewardLevelUpEntryRequest::New() const {
  return new RewardLevelUpEntryRequest;
}

void RewardLevelUpEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLevelUpEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLevelUpEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLevelUpEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLevelUpEntryRequest)
  return false;
#undef DO_
}

void RewardLevelUpEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLevelUpEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLevelUpEntryRequest)
}

int RewardLevelUpEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLevelUpEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLevelUpEntryRequest*>(&from));
}

void RewardLevelUpEntryRequest::MergeFrom(const RewardLevelUpEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLevelUpEntryRequest::CopyFrom(const RewardLevelUpEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLevelUpEntryRequest::IsInitialized() const {

  return true;
}

void RewardLevelUpEntryRequest::Swap(RewardLevelUpEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLevelUpEntryRequest::GetTypeName() const {
  return "main.RewardLevelUpEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLevelUpEntryResponse::kRecordsFieldNumber;
#endif  // !_MSC_VER

RewardLevelUpEntryResponse::RewardLevelUpEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLevelUpEntryResponse)
}

void RewardLevelUpEntryResponse::InitAsDefaultInstance() {
}

RewardLevelUpEntryResponse::RewardLevelUpEntryResponse(const RewardLevelUpEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLevelUpEntryResponse)
}

void RewardLevelUpEntryResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLevelUpEntryResponse::~RewardLevelUpEntryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardLevelUpEntryResponse)
  SharedDtor();
}

void RewardLevelUpEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLevelUpEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLevelUpEntryResponse& RewardLevelUpEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLevelUpEntryResponse* RewardLevelUpEntryResponse::default_instance_ = NULL;

RewardLevelUpEntryResponse* RewardLevelUpEntryResponse::New() const {
  return new RewardLevelUpEntryResponse;
}

void RewardLevelUpEntryResponse::Clear() {
  records_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLevelUpEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLevelUpEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 records = 1;
      case 1: {
        if (tag == 8) {
         parse_records:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_records())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_records())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_records;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLevelUpEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLevelUpEntryResponse)
  return false;
#undef DO_
}

void RewardLevelUpEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLevelUpEntryResponse)
  // repeated int32 records = 1;
  for (int i = 0; i < this->records_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->records(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLevelUpEntryResponse)
}

int RewardLevelUpEntryResponse::ByteSize() const {
  int total_size = 0;

  // repeated int32 records = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->records_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->records(i));
    }
    total_size += 1 * this->records_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLevelUpEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLevelUpEntryResponse*>(&from));
}

void RewardLevelUpEntryResponse::MergeFrom(const RewardLevelUpEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  records_.MergeFrom(from.records_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLevelUpEntryResponse::CopyFrom(const RewardLevelUpEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLevelUpEntryResponse::IsInitialized() const {

  return true;
}

void RewardLevelUpEntryResponse::Swap(RewardLevelUpEntryResponse* other) {
  if (other != this) {
    records_.Swap(&other->records_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLevelUpEntryResponse::GetTypeName() const {
  return "main.RewardLevelUpEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLevelUpPurchRequest::kLevelFieldNumber;
#endif  // !_MSC_VER

RewardLevelUpPurchRequest::RewardLevelUpPurchRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLevelUpPurchRequest)
}

void RewardLevelUpPurchRequest::InitAsDefaultInstance() {
}

RewardLevelUpPurchRequest::RewardLevelUpPurchRequest(const RewardLevelUpPurchRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLevelUpPurchRequest)
}

void RewardLevelUpPurchRequest::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLevelUpPurchRequest::~RewardLevelUpPurchRequest() {
  // @@protoc_insertion_point(destructor:main.RewardLevelUpPurchRequest)
  SharedDtor();
}

void RewardLevelUpPurchRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLevelUpPurchRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLevelUpPurchRequest& RewardLevelUpPurchRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLevelUpPurchRequest* RewardLevelUpPurchRequest::default_instance_ = NULL;

RewardLevelUpPurchRequest* RewardLevelUpPurchRequest::New() const {
  return new RewardLevelUpPurchRequest;
}

void RewardLevelUpPurchRequest::Clear() {
  level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLevelUpPurchRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLevelUpPurchRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 level = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLevelUpPurchRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLevelUpPurchRequest)
  return false;
#undef DO_
}

void RewardLevelUpPurchRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLevelUpPurchRequest)
  // required int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLevelUpPurchRequest)
}

int RewardLevelUpPurchRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLevelUpPurchRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLevelUpPurchRequest*>(&from));
}

void RewardLevelUpPurchRequest::MergeFrom(const RewardLevelUpPurchRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLevelUpPurchRequest::CopyFrom(const RewardLevelUpPurchRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLevelUpPurchRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RewardLevelUpPurchRequest::Swap(RewardLevelUpPurchRequest* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLevelUpPurchRequest::GetTypeName() const {
  return "main.RewardLevelUpPurchRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLevelUpPurchResponse::kResultFieldNumber;
#endif  // !_MSC_VER

RewardLevelUpPurchResponse::RewardLevelUpPurchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLevelUpPurchResponse)
}

void RewardLevelUpPurchResponse::InitAsDefaultInstance() {
}

RewardLevelUpPurchResponse::RewardLevelUpPurchResponse(const RewardLevelUpPurchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLevelUpPurchResponse)
}

void RewardLevelUpPurchResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLevelUpPurchResponse::~RewardLevelUpPurchResponse() {
  // @@protoc_insertion_point(destructor:main.RewardLevelUpPurchResponse)
  SharedDtor();
}

void RewardLevelUpPurchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLevelUpPurchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLevelUpPurchResponse& RewardLevelUpPurchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLevelUpPurchResponse* RewardLevelUpPurchResponse::default_instance_ = NULL;

RewardLevelUpPurchResponse* RewardLevelUpPurchResponse::New() const {
  return new RewardLevelUpPurchResponse;
}

void RewardLevelUpPurchResponse::Clear() {
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLevelUpPurchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLevelUpPurchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLevelUpPurchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLevelUpPurchResponse)
  return false;
#undef DO_
}

void RewardLevelUpPurchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLevelUpPurchResponse)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLevelUpPurchResponse)
}

int RewardLevelUpPurchResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLevelUpPurchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLevelUpPurchResponse*>(&from));
}

void RewardLevelUpPurchResponse::MergeFrom(const RewardLevelUpPurchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLevelUpPurchResponse::CopyFrom(const RewardLevelUpPurchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLevelUpPurchResponse::IsInitialized() const {

  return true;
}

void RewardLevelUpPurchResponse::Swap(RewardLevelUpPurchResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLevelUpPurchResponse::GetTypeName() const {
  return "main.RewardLevelUpPurchResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardSalaryEntryRequest::RewardSalaryEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardSalaryEntryRequest)
}

void RewardSalaryEntryRequest::InitAsDefaultInstance() {
}

RewardSalaryEntryRequest::RewardSalaryEntryRequest(const RewardSalaryEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardSalaryEntryRequest)
}

void RewardSalaryEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardSalaryEntryRequest::~RewardSalaryEntryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardSalaryEntryRequest)
  SharedDtor();
}

void RewardSalaryEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardSalaryEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardSalaryEntryRequest& RewardSalaryEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardSalaryEntryRequest* RewardSalaryEntryRequest::default_instance_ = NULL;

RewardSalaryEntryRequest* RewardSalaryEntryRequest::New() const {
  return new RewardSalaryEntryRequest;
}

void RewardSalaryEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardSalaryEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardSalaryEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardSalaryEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardSalaryEntryRequest)
  return false;
#undef DO_
}

void RewardSalaryEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardSalaryEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardSalaryEntryRequest)
}

int RewardSalaryEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardSalaryEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardSalaryEntryRequest*>(&from));
}

void RewardSalaryEntryRequest::MergeFrom(const RewardSalaryEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardSalaryEntryRequest::CopyFrom(const RewardSalaryEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardSalaryEntryRequest::IsInitialized() const {

  return true;
}

void RewardSalaryEntryRequest::Swap(RewardSalaryEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardSalaryEntryRequest::GetTypeName() const {
  return "main.RewardSalaryEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardSalaryEntryResponse::kLevelCoinFieldNumber;
const int RewardSalaryEntryResponse::kLevelRewardTimeFieldNumber;
const int RewardSalaryEntryResponse::kPvpLevelFieldNumber;
const int RewardSalaryEntryResponse::kPvpLevelCoinFieldNumber;
const int RewardSalaryEntryResponse::kPvpRewardTimeFieldNumber;
const int RewardSalaryEntryResponse::kPveMinLevelFieldNumber;
const int RewardSalaryEntryResponse::kPvpMinLevelFieldNumber;
#endif  // !_MSC_VER

RewardSalaryEntryResponse::RewardSalaryEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardSalaryEntryResponse)
}

void RewardSalaryEntryResponse::InitAsDefaultInstance() {
}

RewardSalaryEntryResponse::RewardSalaryEntryResponse(const RewardSalaryEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardSalaryEntryResponse)
}

void RewardSalaryEntryResponse::SharedCtor() {
  _cached_size_ = 0;
  levelcoin_ = 0;
  levelrewardtime_ = 0;
  pvplevel_ = 0;
  pvplevelcoin_ = 0;
  pvprewardtime_ = 0;
  pveminlevel_ = 0;
  pvpminlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardSalaryEntryResponse::~RewardSalaryEntryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardSalaryEntryResponse)
  SharedDtor();
}

void RewardSalaryEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardSalaryEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardSalaryEntryResponse& RewardSalaryEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardSalaryEntryResponse* RewardSalaryEntryResponse::default_instance_ = NULL;

RewardSalaryEntryResponse* RewardSalaryEntryResponse::New() const {
  return new RewardSalaryEntryResponse;
}

void RewardSalaryEntryResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardSalaryEntryResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(levelcoin_, pvpminlevel_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardSalaryEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardSalaryEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 levelCoin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &levelcoin_)));
          set_has_levelcoin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_levelRewardTime;
        break;
      }

      // optional int32 levelRewardTime = 2;
      case 2: {
        if (tag == 16) {
         parse_levelRewardTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &levelrewardtime_)));
          set_has_levelrewardtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_pvpLevel;
        break;
      }

      // optional int32 pvpLevel = 3;
      case 3: {
        if (tag == 24) {
         parse_pvpLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pvplevel_)));
          set_has_pvplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_pvpLevelCoin;
        break;
      }

      // optional int32 pvpLevelCoin = 4;
      case 4: {
        if (tag == 32) {
         parse_pvpLevelCoin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pvplevelcoin_)));
          set_has_pvplevelcoin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pvpRewardTime;
        break;
      }

      // optional int32 pvpRewardTime = 5;
      case 5: {
        if (tag == 40) {
         parse_pvpRewardTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pvprewardtime_)));
          set_has_pvprewardtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_pveMinLevel;
        break;
      }

      // optional int32 pveMinLevel = 6;
      case 6: {
        if (tag == 48) {
         parse_pveMinLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pveminlevel_)));
          set_has_pveminlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_pvpMinLevel;
        break;
      }

      // optional int32 pvpMinLevel = 7;
      case 7: {
        if (tag == 56) {
         parse_pvpMinLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pvpminlevel_)));
          set_has_pvpminlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardSalaryEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardSalaryEntryResponse)
  return false;
#undef DO_
}

void RewardSalaryEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardSalaryEntryResponse)
  // optional int32 levelCoin = 1;
  if (has_levelcoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->levelcoin(), output);
  }

  // optional int32 levelRewardTime = 2;
  if (has_levelrewardtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->levelrewardtime(), output);
  }

  // optional int32 pvpLevel = 3;
  if (has_pvplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pvplevel(), output);
  }

  // optional int32 pvpLevelCoin = 4;
  if (has_pvplevelcoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->pvplevelcoin(), output);
  }

  // optional int32 pvpRewardTime = 5;
  if (has_pvprewardtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->pvprewardtime(), output);
  }

  // optional int32 pveMinLevel = 6;
  if (has_pveminlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->pveminlevel(), output);
  }

  // optional int32 pvpMinLevel = 7;
  if (has_pvpminlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->pvpminlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardSalaryEntryResponse)
}

int RewardSalaryEntryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 levelCoin = 1;
    if (has_levelcoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->levelcoin());
    }

    // optional int32 levelRewardTime = 2;
    if (has_levelrewardtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->levelrewardtime());
    }

    // optional int32 pvpLevel = 3;
    if (has_pvplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pvplevel());
    }

    // optional int32 pvpLevelCoin = 4;
    if (has_pvplevelcoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pvplevelcoin());
    }

    // optional int32 pvpRewardTime = 5;
    if (has_pvprewardtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pvprewardtime());
    }

    // optional int32 pveMinLevel = 6;
    if (has_pveminlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pveminlevel());
    }

    // optional int32 pvpMinLevel = 7;
    if (has_pvpminlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pvpminlevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardSalaryEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardSalaryEntryResponse*>(&from));
}

void RewardSalaryEntryResponse::MergeFrom(const RewardSalaryEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_levelcoin()) {
      set_levelcoin(from.levelcoin());
    }
    if (from.has_levelrewardtime()) {
      set_levelrewardtime(from.levelrewardtime());
    }
    if (from.has_pvplevel()) {
      set_pvplevel(from.pvplevel());
    }
    if (from.has_pvplevelcoin()) {
      set_pvplevelcoin(from.pvplevelcoin());
    }
    if (from.has_pvprewardtime()) {
      set_pvprewardtime(from.pvprewardtime());
    }
    if (from.has_pveminlevel()) {
      set_pveminlevel(from.pveminlevel());
    }
    if (from.has_pvpminlevel()) {
      set_pvpminlevel(from.pvpminlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardSalaryEntryResponse::CopyFrom(const RewardSalaryEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardSalaryEntryResponse::IsInitialized() const {

  return true;
}

void RewardSalaryEntryResponse::Swap(RewardSalaryEntryResponse* other) {
  if (other != this) {
    std::swap(levelcoin_, other->levelcoin_);
    std::swap(levelrewardtime_, other->levelrewardtime_);
    std::swap(pvplevel_, other->pvplevel_);
    std::swap(pvplevelcoin_, other->pvplevelcoin_);
    std::swap(pvprewardtime_, other->pvprewardtime_);
    std::swap(pveminlevel_, other->pveminlevel_);
    std::swap(pvpminlevel_, other->pvpminlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardSalaryEntryResponse::GetTypeName() const {
  return "main.RewardSalaryEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardGetSalaryRequest::kTypeFieldNumber;
#endif  // !_MSC_VER

RewardGetSalaryRequest::RewardGetSalaryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGetSalaryRequest)
}

void RewardGetSalaryRequest::InitAsDefaultInstance() {
}

RewardGetSalaryRequest::RewardGetSalaryRequest(const RewardGetSalaryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGetSalaryRequest)
}

void RewardGetSalaryRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGetSalaryRequest::~RewardGetSalaryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardGetSalaryRequest)
  SharedDtor();
}

void RewardGetSalaryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGetSalaryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGetSalaryRequest& RewardGetSalaryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGetSalaryRequest* RewardGetSalaryRequest::default_instance_ = NULL;

RewardGetSalaryRequest* RewardGetSalaryRequest::New() const {
  return new RewardGetSalaryRequest;
}

void RewardGetSalaryRequest::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGetSalaryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGetSalaryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGetSalaryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGetSalaryRequest)
  return false;
#undef DO_
}

void RewardGetSalaryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGetSalaryRequest)
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGetSalaryRequest)
}

int RewardGetSalaryRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGetSalaryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGetSalaryRequest*>(&from));
}

void RewardGetSalaryRequest::MergeFrom(const RewardGetSalaryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGetSalaryRequest::CopyFrom(const RewardGetSalaryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGetSalaryRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RewardGetSalaryRequest::Swap(RewardGetSalaryRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGetSalaryRequest::GetTypeName() const {
  return "main.RewardGetSalaryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardGetSalaryResponse::kResultFieldNumber;
#endif  // !_MSC_VER

RewardGetSalaryResponse::RewardGetSalaryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGetSalaryResponse)
}

void RewardGetSalaryResponse::InitAsDefaultInstance() {
}

RewardGetSalaryResponse::RewardGetSalaryResponse(const RewardGetSalaryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGetSalaryResponse)
}

void RewardGetSalaryResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGetSalaryResponse::~RewardGetSalaryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardGetSalaryResponse)
  SharedDtor();
}

void RewardGetSalaryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGetSalaryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGetSalaryResponse& RewardGetSalaryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGetSalaryResponse* RewardGetSalaryResponse::default_instance_ = NULL;

RewardGetSalaryResponse* RewardGetSalaryResponse::New() const {
  return new RewardGetSalaryResponse;
}

void RewardGetSalaryResponse::Clear() {
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGetSalaryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGetSalaryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGetSalaryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGetSalaryResponse)
  return false;
#undef DO_
}

void RewardGetSalaryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGetSalaryResponse)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGetSalaryResponse)
}

int RewardGetSalaryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGetSalaryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGetSalaryResponse*>(&from));
}

void RewardGetSalaryResponse::MergeFrom(const RewardGetSalaryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGetSalaryResponse::CopyFrom(const RewardGetSalaryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGetSalaryResponse::IsInitialized() const {

  return true;
}

void RewardGetSalaryResponse::Swap(RewardGetSalaryResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGetSalaryResponse::GetTypeName() const {
  return "main.RewardGetSalaryResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardRecoverPowerEntryRequest::RewardRecoverPowerEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRecoverPowerEntryRequest)
}

void RewardRecoverPowerEntryRequest::InitAsDefaultInstance() {
}

RewardRecoverPowerEntryRequest::RewardRecoverPowerEntryRequest(const RewardRecoverPowerEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRecoverPowerEntryRequest)
}

void RewardRecoverPowerEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRecoverPowerEntryRequest::~RewardRecoverPowerEntryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardRecoverPowerEntryRequest)
  SharedDtor();
}

void RewardRecoverPowerEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRecoverPowerEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRecoverPowerEntryRequest& RewardRecoverPowerEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRecoverPowerEntryRequest* RewardRecoverPowerEntryRequest::default_instance_ = NULL;

RewardRecoverPowerEntryRequest* RewardRecoverPowerEntryRequest::New() const {
  return new RewardRecoverPowerEntryRequest;
}

void RewardRecoverPowerEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRecoverPowerEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRecoverPowerEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRecoverPowerEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRecoverPowerEntryRequest)
  return false;
#undef DO_
}

void RewardRecoverPowerEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRecoverPowerEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRecoverPowerEntryRequest)
}

int RewardRecoverPowerEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRecoverPowerEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRecoverPowerEntryRequest*>(&from));
}

void RewardRecoverPowerEntryRequest::MergeFrom(const RewardRecoverPowerEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRecoverPowerEntryRequest::CopyFrom(const RewardRecoverPowerEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRecoverPowerEntryRequest::IsInitialized() const {

  return true;
}

void RewardRecoverPowerEntryRequest::Swap(RewardRecoverPowerEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRecoverPowerEntryRequest::GetTypeName() const {
  return "main.RewardRecoverPowerEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardRecoverPowerEntryResponse::kPowerFieldNumber;
const int RewardRecoverPowerEntryResponse::kEnableFieldNumber;
#endif  // !_MSC_VER

RewardRecoverPowerEntryResponse::RewardRecoverPowerEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRecoverPowerEntryResponse)
}

void RewardRecoverPowerEntryResponse::InitAsDefaultInstance() {
}

RewardRecoverPowerEntryResponse::RewardRecoverPowerEntryResponse(const RewardRecoverPowerEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRecoverPowerEntryResponse)
}

void RewardRecoverPowerEntryResponse::SharedCtor() {
  _cached_size_ = 0;
  power_ = 0;
  enable_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRecoverPowerEntryResponse::~RewardRecoverPowerEntryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardRecoverPowerEntryResponse)
  SharedDtor();
}

void RewardRecoverPowerEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRecoverPowerEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRecoverPowerEntryResponse& RewardRecoverPowerEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRecoverPowerEntryResponse* RewardRecoverPowerEntryResponse::default_instance_ = NULL;

RewardRecoverPowerEntryResponse* RewardRecoverPowerEntryResponse::New() const {
  return new RewardRecoverPowerEntryResponse;
}

void RewardRecoverPowerEntryResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardRecoverPowerEntryResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(power_, enable_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRecoverPowerEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRecoverPowerEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 power = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_enable;
        break;
      }

      // optional int32 enable = 2;
      case 2: {
        if (tag == 16) {
         parse_enable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enable_)));
          set_has_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRecoverPowerEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRecoverPowerEntryResponse)
  return false;
#undef DO_
}

void RewardRecoverPowerEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRecoverPowerEntryResponse)
  // optional int32 power = 1;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->power(), output);
  }

  // optional int32 enable = 2;
  if (has_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->enable(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRecoverPowerEntryResponse)
}

int RewardRecoverPowerEntryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 power = 1;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

    // optional int32 enable = 2;
    if (has_enable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enable());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRecoverPowerEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRecoverPowerEntryResponse*>(&from));
}

void RewardRecoverPowerEntryResponse::MergeFrom(const RewardRecoverPowerEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_power()) {
      set_power(from.power());
    }
    if (from.has_enable()) {
      set_enable(from.enable());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRecoverPowerEntryResponse::CopyFrom(const RewardRecoverPowerEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRecoverPowerEntryResponse::IsInitialized() const {

  return true;
}

void RewardRecoverPowerEntryResponse::Swap(RewardRecoverPowerEntryResponse* other) {
  if (other != this) {
    std::swap(power_, other->power_);
    std::swap(enable_, other->enable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRecoverPowerEntryResponse::GetTypeName() const {
  return "main.RewardRecoverPowerEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardRecoverPowerPurchRequest::RewardRecoverPowerPurchRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRecoverPowerPurchRequest)
}

void RewardRecoverPowerPurchRequest::InitAsDefaultInstance() {
}

RewardRecoverPowerPurchRequest::RewardRecoverPowerPurchRequest(const RewardRecoverPowerPurchRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRecoverPowerPurchRequest)
}

void RewardRecoverPowerPurchRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRecoverPowerPurchRequest::~RewardRecoverPowerPurchRequest() {
  // @@protoc_insertion_point(destructor:main.RewardRecoverPowerPurchRequest)
  SharedDtor();
}

void RewardRecoverPowerPurchRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRecoverPowerPurchRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRecoverPowerPurchRequest& RewardRecoverPowerPurchRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRecoverPowerPurchRequest* RewardRecoverPowerPurchRequest::default_instance_ = NULL;

RewardRecoverPowerPurchRequest* RewardRecoverPowerPurchRequest::New() const {
  return new RewardRecoverPowerPurchRequest;
}

void RewardRecoverPowerPurchRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRecoverPowerPurchRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRecoverPowerPurchRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRecoverPowerPurchRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRecoverPowerPurchRequest)
  return false;
#undef DO_
}

void RewardRecoverPowerPurchRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRecoverPowerPurchRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRecoverPowerPurchRequest)
}

int RewardRecoverPowerPurchRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRecoverPowerPurchRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRecoverPowerPurchRequest*>(&from));
}

void RewardRecoverPowerPurchRequest::MergeFrom(const RewardRecoverPowerPurchRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRecoverPowerPurchRequest::CopyFrom(const RewardRecoverPowerPurchRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRecoverPowerPurchRequest::IsInitialized() const {

  return true;
}

void RewardRecoverPowerPurchRequest::Swap(RewardRecoverPowerPurchRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRecoverPowerPurchRequest::GetTypeName() const {
  return "main.RewardRecoverPowerPurchRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardRecoverPowerPurchResponse::kResultFieldNumber;
#endif  // !_MSC_VER

RewardRecoverPowerPurchResponse::RewardRecoverPowerPurchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRecoverPowerPurchResponse)
}

void RewardRecoverPowerPurchResponse::InitAsDefaultInstance() {
}

RewardRecoverPowerPurchResponse::RewardRecoverPowerPurchResponse(const RewardRecoverPowerPurchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRecoverPowerPurchResponse)
}

void RewardRecoverPowerPurchResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRecoverPowerPurchResponse::~RewardRecoverPowerPurchResponse() {
  // @@protoc_insertion_point(destructor:main.RewardRecoverPowerPurchResponse)
  SharedDtor();
}

void RewardRecoverPowerPurchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRecoverPowerPurchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRecoverPowerPurchResponse& RewardRecoverPowerPurchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRecoverPowerPurchResponse* RewardRecoverPowerPurchResponse::default_instance_ = NULL;

RewardRecoverPowerPurchResponse* RewardRecoverPowerPurchResponse::New() const {
  return new RewardRecoverPowerPurchResponse;
}

void RewardRecoverPowerPurchResponse::Clear() {
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRecoverPowerPurchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRecoverPowerPurchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRecoverPowerPurchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRecoverPowerPurchResponse)
  return false;
#undef DO_
}

void RewardRecoverPowerPurchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRecoverPowerPurchResponse)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRecoverPowerPurchResponse)
}

int RewardRecoverPowerPurchResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRecoverPowerPurchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRecoverPowerPurchResponse*>(&from));
}

void RewardRecoverPowerPurchResponse::MergeFrom(const RewardRecoverPowerPurchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRecoverPowerPurchResponse::CopyFrom(const RewardRecoverPowerPurchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRecoverPowerPurchResponse::IsInitialized() const {

  return true;
}

void RewardRecoverPowerPurchResponse::Swap(RewardRecoverPowerPurchResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRecoverPowerPurchResponse::GetTypeName() const {
  return "main.RewardRecoverPowerPurchResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardGodPrayEntryRequest::RewardGodPrayEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGodPrayEntryRequest)
}

void RewardGodPrayEntryRequest::InitAsDefaultInstance() {
}

RewardGodPrayEntryRequest::RewardGodPrayEntryRequest(const RewardGodPrayEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGodPrayEntryRequest)
}

void RewardGodPrayEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGodPrayEntryRequest::~RewardGodPrayEntryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardGodPrayEntryRequest)
  SharedDtor();
}

void RewardGodPrayEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGodPrayEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGodPrayEntryRequest& RewardGodPrayEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGodPrayEntryRequest* RewardGodPrayEntryRequest::default_instance_ = NULL;

RewardGodPrayEntryRequest* RewardGodPrayEntryRequest::New() const {
  return new RewardGodPrayEntryRequest;
}

void RewardGodPrayEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGodPrayEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGodPrayEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGodPrayEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGodPrayEntryRequest)
  return false;
#undef DO_
}

void RewardGodPrayEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGodPrayEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGodPrayEntryRequest)
}

int RewardGodPrayEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGodPrayEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGodPrayEntryRequest*>(&from));
}

void RewardGodPrayEntryRequest::MergeFrom(const RewardGodPrayEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGodPrayEntryRequest::CopyFrom(const RewardGodPrayEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGodPrayEntryRequest::IsInitialized() const {

  return true;
}

void RewardGodPrayEntryRequest::Swap(RewardGodPrayEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGodPrayEntryRequest::GetTypeName() const {
  return "main.RewardGodPrayEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardGodPrayEntryResponse::kCurrentFieldNumber;
const int RewardGodPrayEntryResponse::kMaxFieldNumber;
const int RewardGodPrayEntryResponse::kCanDoFieldNumber;
const int RewardGodPrayEntryResponse::kGodRewardInfoFieldNumber;
#endif  // !_MSC_VER

RewardGodPrayEntryResponse::RewardGodPrayEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGodPrayEntryResponse)
}

void RewardGodPrayEntryResponse::InitAsDefaultInstance() {
}

RewardGodPrayEntryResponse::RewardGodPrayEntryResponse(const RewardGodPrayEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGodPrayEntryResponse)
}

void RewardGodPrayEntryResponse::SharedCtor() {
  _cached_size_ = 0;
  current_ = 0;
  max_ = 0;
  cando_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGodPrayEntryResponse::~RewardGodPrayEntryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardGodPrayEntryResponse)
  SharedDtor();
}

void RewardGodPrayEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGodPrayEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGodPrayEntryResponse& RewardGodPrayEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGodPrayEntryResponse* RewardGodPrayEntryResponse::default_instance_ = NULL;

RewardGodPrayEntryResponse* RewardGodPrayEntryResponse::New() const {
  return new RewardGodPrayEntryResponse;
}

void RewardGodPrayEntryResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardGodPrayEntryResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(current_, max_);
    cando_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  godrewardinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGodPrayEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGodPrayEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 current = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_)));
          set_has_current();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max;
        break;
      }

      // optional int32 max = 2;
      case 2: {
        if (tag == 16) {
         parse_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_)));
          set_has_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_canDo;
        break;
      }

      // optional int32 canDo = 3;
      case 3: {
        if (tag == 24) {
         parse_canDo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cando_)));
          set_has_cando();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_godRewardInfo;
        break;
      }

      // repeated .main.GodRewardInfo godRewardInfo = 4;
      case 4: {
        if (tag == 34) {
         parse_godRewardInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_godrewardinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_godRewardInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGodPrayEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGodPrayEntryResponse)
  return false;
#undef DO_
}

void RewardGodPrayEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGodPrayEntryResponse)
  // optional int32 current = 1;
  if (has_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->current(), output);
  }

  // optional int32 max = 2;
  if (has_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max(), output);
  }

  // optional int32 canDo = 3;
  if (has_cando()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->cando(), output);
  }

  // repeated .main.GodRewardInfo godRewardInfo = 4;
  for (int i = 0; i < this->godrewardinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->godrewardinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGodPrayEntryResponse)
}

int RewardGodPrayEntryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 current = 1;
    if (has_current()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current());
    }

    // optional int32 max = 2;
    if (has_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max());
    }

    // optional int32 canDo = 3;
    if (has_cando()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cando());
    }

  }
  // repeated .main.GodRewardInfo godRewardInfo = 4;
  total_size += 1 * this->godrewardinfo_size();
  for (int i = 0; i < this->godrewardinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->godrewardinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGodPrayEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGodPrayEntryResponse*>(&from));
}

void RewardGodPrayEntryResponse::MergeFrom(const RewardGodPrayEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  godrewardinfo_.MergeFrom(from.godrewardinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_current()) {
      set_current(from.current());
    }
    if (from.has_max()) {
      set_max(from.max());
    }
    if (from.has_cando()) {
      set_cando(from.cando());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGodPrayEntryResponse::CopyFrom(const RewardGodPrayEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGodPrayEntryResponse::IsInitialized() const {

  return true;
}

void RewardGodPrayEntryResponse::Swap(RewardGodPrayEntryResponse* other) {
  if (other != this) {
    std::swap(current_, other->current_);
    std::swap(max_, other->max_);
    std::swap(cando_, other->cando_);
    godrewardinfo_.Swap(&other->godrewardinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGodPrayEntryResponse::GetTypeName() const {
  return "main.RewardGodPrayEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int GodRewardInfo::kTypeFieldNumber;
const int GodRewardInfo::kItemIdFieldNumber;
const int GodRewardInfo::kCountFieldNumber;
#endif  // !_MSC_VER

GodRewardInfo::GodRewardInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.GodRewardInfo)
}

void GodRewardInfo::InitAsDefaultInstance() {
}

GodRewardInfo::GodRewardInfo(const GodRewardInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.GodRewardInfo)
}

void GodRewardInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  itemid_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GodRewardInfo::~GodRewardInfo() {
  // @@protoc_insertion_point(destructor:main.GodRewardInfo)
  SharedDtor();
}

void GodRewardInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GodRewardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GodRewardInfo& GodRewardInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

GodRewardInfo* GodRewardInfo::default_instance_ = NULL;

GodRewardInfo* GodRewardInfo::New() const {
  return new GodRewardInfo;
}

void GodRewardInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GodRewardInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GodRewardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.GodRewardInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_itemId;
        break;
      }

      // optional int32 itemId = 2;
      case 2: {
        if (tag == 16) {
         parse_itemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // optional int32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.GodRewardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.GodRewardInfo)
  return false;
#undef DO_
}

void GodRewardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.GodRewardInfo)
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 itemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional int32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.GodRewardInfo)
}

int GodRewardInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 itemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GodRewardInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GodRewardInfo*>(&from));
}

void GodRewardInfo::MergeFrom(const GodRewardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GodRewardInfo::CopyFrom(const GodRewardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GodRewardInfo::IsInitialized() const {

  return true;
}

void GodRewardInfo::Swap(GodRewardInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GodRewardInfo::GetTypeName() const {
  return "main.GodRewardInfo";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardGodPrayAddRequest::RewardGodPrayAddRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGodPrayAddRequest)
}

void RewardGodPrayAddRequest::InitAsDefaultInstance() {
}

RewardGodPrayAddRequest::RewardGodPrayAddRequest(const RewardGodPrayAddRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGodPrayAddRequest)
}

void RewardGodPrayAddRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGodPrayAddRequest::~RewardGodPrayAddRequest() {
  // @@protoc_insertion_point(destructor:main.RewardGodPrayAddRequest)
  SharedDtor();
}

void RewardGodPrayAddRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGodPrayAddRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGodPrayAddRequest& RewardGodPrayAddRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGodPrayAddRequest* RewardGodPrayAddRequest::default_instance_ = NULL;

RewardGodPrayAddRequest* RewardGodPrayAddRequest::New() const {
  return new RewardGodPrayAddRequest;
}

void RewardGodPrayAddRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGodPrayAddRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGodPrayAddRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGodPrayAddRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGodPrayAddRequest)
  return false;
#undef DO_
}

void RewardGodPrayAddRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGodPrayAddRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGodPrayAddRequest)
}

int RewardGodPrayAddRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGodPrayAddRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGodPrayAddRequest*>(&from));
}

void RewardGodPrayAddRequest::MergeFrom(const RewardGodPrayAddRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGodPrayAddRequest::CopyFrom(const RewardGodPrayAddRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGodPrayAddRequest::IsInitialized() const {

  return true;
}

void RewardGodPrayAddRequest::Swap(RewardGodPrayAddRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGodPrayAddRequest::GetTypeName() const {
  return "main.RewardGodPrayAddRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardGodPrayAddResponse::kResultFieldNumber;
const int RewardGodPrayAddResponse::kMaxFieldNumber;
const int RewardGodPrayAddResponse::kGodRewardInfoFieldNumber;
#endif  // !_MSC_VER

RewardGodPrayAddResponse::RewardGodPrayAddResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardGodPrayAddResponse)
}

void RewardGodPrayAddResponse::InitAsDefaultInstance() {
}

RewardGodPrayAddResponse::RewardGodPrayAddResponse(const RewardGodPrayAddResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardGodPrayAddResponse)
}

void RewardGodPrayAddResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  max_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardGodPrayAddResponse::~RewardGodPrayAddResponse() {
  // @@protoc_insertion_point(destructor:main.RewardGodPrayAddResponse)
  SharedDtor();
}

void RewardGodPrayAddResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardGodPrayAddResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardGodPrayAddResponse& RewardGodPrayAddResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardGodPrayAddResponse* RewardGodPrayAddResponse::default_instance_ = NULL;

RewardGodPrayAddResponse* RewardGodPrayAddResponse::New() const {
  return new RewardGodPrayAddResponse;
}

void RewardGodPrayAddResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardGodPrayAddResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(result_, max_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  godrewardinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardGodPrayAddResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardGodPrayAddResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max;
        break;
      }

      // optional int32 max = 2;
      case 2: {
        if (tag == 16) {
         parse_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_)));
          set_has_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_godRewardInfo;
        break;
      }

      // repeated .main.GodRewardInfo godRewardInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_godRewardInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_godrewardinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_godRewardInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardGodPrayAddResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardGodPrayAddResponse)
  return false;
#undef DO_
}

void RewardGodPrayAddResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardGodPrayAddResponse)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional int32 max = 2;
  if (has_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max(), output);
  }

  // repeated .main.GodRewardInfo godRewardInfo = 3;
  for (int i = 0; i < this->godrewardinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->godrewardinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardGodPrayAddResponse)
}

int RewardGodPrayAddResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional int32 max = 2;
    if (has_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max());
    }

  }
  // repeated .main.GodRewardInfo godRewardInfo = 3;
  total_size += 1 * this->godrewardinfo_size();
  for (int i = 0; i < this->godrewardinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->godrewardinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardGodPrayAddResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardGodPrayAddResponse*>(&from));
}

void RewardGodPrayAddResponse::MergeFrom(const RewardGodPrayAddResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  godrewardinfo_.MergeFrom(from.godrewardinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_max()) {
      set_max(from.max());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardGodPrayAddResponse::CopyFrom(const RewardGodPrayAddResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardGodPrayAddResponse::IsInitialized() const {

  return true;
}

void RewardGodPrayAddResponse::Swap(RewardGodPrayAddResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(max_, other->max_);
    godrewardinfo_.Swap(&other->godrewardinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardGodPrayAddResponse::GetTypeName() const {
  return "main.RewardGodPrayAddResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardRegLotteryEntryRequest::RewardRegLotteryEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRegLotteryEntryRequest)
}

void RewardRegLotteryEntryRequest::InitAsDefaultInstance() {
}

RewardRegLotteryEntryRequest::RewardRegLotteryEntryRequest(const RewardRegLotteryEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRegLotteryEntryRequest)
}

void RewardRegLotteryEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRegLotteryEntryRequest::~RewardRegLotteryEntryRequest() {
  // @@protoc_insertion_point(destructor:main.RewardRegLotteryEntryRequest)
  SharedDtor();
}

void RewardRegLotteryEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRegLotteryEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRegLotteryEntryRequest& RewardRegLotteryEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRegLotteryEntryRequest* RewardRegLotteryEntryRequest::default_instance_ = NULL;

RewardRegLotteryEntryRequest* RewardRegLotteryEntryRequest::New() const {
  return new RewardRegLotteryEntryRequest;
}

void RewardRegLotteryEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRegLotteryEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRegLotteryEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRegLotteryEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRegLotteryEntryRequest)
  return false;
#undef DO_
}

void RewardRegLotteryEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRegLotteryEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRegLotteryEntryRequest)
}

int RewardRegLotteryEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRegLotteryEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRegLotteryEntryRequest*>(&from));
}

void RewardRegLotteryEntryRequest::MergeFrom(const RewardRegLotteryEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRegLotteryEntryRequest::CopyFrom(const RewardRegLotteryEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRegLotteryEntryRequest::IsInitialized() const {

  return true;
}

void RewardRegLotteryEntryRequest::Swap(RewardRegLotteryEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRegLotteryEntryRequest::GetTypeName() const {
  return "main.RewardRegLotteryEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardRegLotteryEntryResponse::kLeftChanceFieldNumber;
const int RewardRegLotteryEntryResponse::kLeftTimeFieldNumber;
const int RewardRegLotteryEntryResponse::kCostGoldFieldNumber;
const int RewardRegLotteryEntryResponse::kGetGoldsFieldNumber;
#endif  // !_MSC_VER

RewardRegLotteryEntryResponse::RewardRegLotteryEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRegLotteryEntryResponse)
}

void RewardRegLotteryEntryResponse::InitAsDefaultInstance() {
}

RewardRegLotteryEntryResponse::RewardRegLotteryEntryResponse(const RewardRegLotteryEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRegLotteryEntryResponse)
}

void RewardRegLotteryEntryResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  leftchance_ = 0;
  lefttime_ = 0;
  costgold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRegLotteryEntryResponse::~RewardRegLotteryEntryResponse() {
  // @@protoc_insertion_point(destructor:main.RewardRegLotteryEntryResponse)
  SharedDtor();
}

void RewardRegLotteryEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRegLotteryEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRegLotteryEntryResponse& RewardRegLotteryEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRegLotteryEntryResponse* RewardRegLotteryEntryResponse::default_instance_ = NULL;

RewardRegLotteryEntryResponse* RewardRegLotteryEntryResponse::New() const {
  return new RewardRegLotteryEntryResponse;
}

void RewardRegLotteryEntryResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardRegLotteryEntryResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(leftchance_, lefttime_);
    costgold_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  getgolds_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRegLotteryEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRegLotteryEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 leftChance = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &leftchance_)));
          set_has_leftchance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_leftTime;
        break;
      }

      // optional int32 leftTime = 2;
      case 2: {
        if (tag == 16) {
         parse_leftTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lefttime_)));
          set_has_lefttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_costGold;
        break;
      }

      // optional int32 costGold = 3;
      case 3: {
        if (tag == 24) {
         parse_costGold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &costgold_)));
          set_has_costgold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_getGolds;
        break;
      }

      // repeated string getGolds = 4;
      case 4: {
        if (tag == 34) {
         parse_getGolds:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_getgolds()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_getGolds;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRegLotteryEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRegLotteryEntryResponse)
  return false;
#undef DO_
}

void RewardRegLotteryEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRegLotteryEntryResponse)
  // optional int32 leftChance = 1;
  if (has_leftchance()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->leftchance(), output);
  }

  // optional int32 leftTime = 2;
  if (has_lefttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lefttime(), output);
  }

  // optional int32 costGold = 3;
  if (has_costgold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->costgold(), output);
  }

  // repeated string getGolds = 4;
  for (int i = 0; i < this->getgolds_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->getgolds(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRegLotteryEntryResponse)
}

int RewardRegLotteryEntryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 leftChance = 1;
    if (has_leftchance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->leftchance());
    }

    // optional int32 leftTime = 2;
    if (has_lefttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lefttime());
    }

    // optional int32 costGold = 3;
    if (has_costgold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->costgold());
    }

  }
  // repeated string getGolds = 4;
  total_size += 1 * this->getgolds_size();
  for (int i = 0; i < this->getgolds_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->getgolds(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRegLotteryEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRegLotteryEntryResponse*>(&from));
}

void RewardRegLotteryEntryResponse::MergeFrom(const RewardRegLotteryEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  getgolds_.MergeFrom(from.getgolds_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_leftchance()) {
      set_leftchance(from.leftchance());
    }
    if (from.has_lefttime()) {
      set_lefttime(from.lefttime());
    }
    if (from.has_costgold()) {
      set_costgold(from.costgold());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRegLotteryEntryResponse::CopyFrom(const RewardRegLotteryEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRegLotteryEntryResponse::IsInitialized() const {

  return true;
}

void RewardRegLotteryEntryResponse::Swap(RewardRegLotteryEntryResponse* other) {
  if (other != this) {
    std::swap(leftchance_, other->leftchance_);
    std::swap(lefttime_, other->lefttime_);
    std::swap(costgold_, other->costgold_);
    getgolds_.Swap(&other->getgolds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRegLotteryEntryResponse::GetTypeName() const {
  return "main.RewardRegLotteryEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardRegLotteryGetRequest::RewardRegLotteryGetRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRegLotteryGetRequest)
}

void RewardRegLotteryGetRequest::InitAsDefaultInstance() {
}

RewardRegLotteryGetRequest::RewardRegLotteryGetRequest(const RewardRegLotteryGetRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRegLotteryGetRequest)
}

void RewardRegLotteryGetRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRegLotteryGetRequest::~RewardRegLotteryGetRequest() {
  // @@protoc_insertion_point(destructor:main.RewardRegLotteryGetRequest)
  SharedDtor();
}

void RewardRegLotteryGetRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRegLotteryGetRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRegLotteryGetRequest& RewardRegLotteryGetRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRegLotteryGetRequest* RewardRegLotteryGetRequest::default_instance_ = NULL;

RewardRegLotteryGetRequest* RewardRegLotteryGetRequest::New() const {
  return new RewardRegLotteryGetRequest;
}

void RewardRegLotteryGetRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRegLotteryGetRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRegLotteryGetRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRegLotteryGetRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRegLotteryGetRequest)
  return false;
#undef DO_
}

void RewardRegLotteryGetRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRegLotteryGetRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRegLotteryGetRequest)
}

int RewardRegLotteryGetRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRegLotteryGetRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRegLotteryGetRequest*>(&from));
}

void RewardRegLotteryGetRequest::MergeFrom(const RewardRegLotteryGetRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRegLotteryGetRequest::CopyFrom(const RewardRegLotteryGetRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRegLotteryGetRequest::IsInitialized() const {

  return true;
}

void RewardRegLotteryGetRequest::Swap(RewardRegLotteryGetRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRegLotteryGetRequest::GetTypeName() const {
  return "main.RewardRegLotteryGetRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardRegLotteryGetResponse::kReturnGoldFieldNumber;
const int RewardRegLotteryGetResponse::kNextCostGoldFieldNumber;
#endif  // !_MSC_VER

RewardRegLotteryGetResponse::RewardRegLotteryGetResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRegLotteryGetResponse)
}

void RewardRegLotteryGetResponse::InitAsDefaultInstance() {
}

RewardRegLotteryGetResponse::RewardRegLotteryGetResponse(const RewardRegLotteryGetResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRegLotteryGetResponse)
}

void RewardRegLotteryGetResponse::SharedCtor() {
  _cached_size_ = 0;
  returngold_ = 0;
  nextcostgold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRegLotteryGetResponse::~RewardRegLotteryGetResponse() {
  // @@protoc_insertion_point(destructor:main.RewardRegLotteryGetResponse)
  SharedDtor();
}

void RewardRegLotteryGetResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRegLotteryGetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRegLotteryGetResponse& RewardRegLotteryGetResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRegLotteryGetResponse* RewardRegLotteryGetResponse::default_instance_ = NULL;

RewardRegLotteryGetResponse* RewardRegLotteryGetResponse::New() const {
  return new RewardRegLotteryGetResponse;
}

void RewardRegLotteryGetResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardRegLotteryGetResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(returngold_, nextcostgold_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRegLotteryGetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRegLotteryGetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 returnGold = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &returngold_)));
          set_has_returngold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_nextCostGold;
        break;
      }

      // optional int32 nextCostGold = 2;
      case 2: {
        if (tag == 16) {
         parse_nextCostGold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nextcostgold_)));
          set_has_nextcostgold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRegLotteryGetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRegLotteryGetResponse)
  return false;
#undef DO_
}

void RewardRegLotteryGetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRegLotteryGetResponse)
  // optional int32 returnGold = 1;
  if (has_returngold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->returngold(), output);
  }

  // optional int32 nextCostGold = 2;
  if (has_nextcostgold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nextcostgold(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRegLotteryGetResponse)
}

int RewardRegLotteryGetResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 returnGold = 1;
    if (has_returngold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->returngold());
    }

    // optional int32 nextCostGold = 2;
    if (has_nextcostgold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nextcostgold());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRegLotteryGetResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRegLotteryGetResponse*>(&from));
}

void RewardRegLotteryGetResponse::MergeFrom(const RewardRegLotteryGetResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_returngold()) {
      set_returngold(from.returngold());
    }
    if (from.has_nextcostgold()) {
      set_nextcostgold(from.nextcostgold());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRegLotteryGetResponse::CopyFrom(const RewardRegLotteryGetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRegLotteryGetResponse::IsInitialized() const {

  return true;
}

void RewardRegLotteryGetResponse::Swap(RewardRegLotteryGetResponse* other) {
  if (other != this) {
    std::swap(returngold_, other->returngold_);
    std::swap(nextcostgold_, other->nextcostgold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRegLotteryGetResponse::GetTypeName() const {
  return "main.RewardRegLotteryGetResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardNoticeMessage::kUpdateFieldNumber;
#endif  // !_MSC_VER

RewardNoticeMessage::RewardNoticeMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardNoticeMessage)
}

void RewardNoticeMessage::InitAsDefaultInstance() {
}

RewardNoticeMessage::RewardNoticeMessage(const RewardNoticeMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardNoticeMessage)
}

void RewardNoticeMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardNoticeMessage::~RewardNoticeMessage() {
  // @@protoc_insertion_point(destructor:main.RewardNoticeMessage)
  SharedDtor();
}

void RewardNoticeMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardNoticeMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardNoticeMessage& RewardNoticeMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardNoticeMessage* RewardNoticeMessage::default_instance_ = NULL;

RewardNoticeMessage* RewardNoticeMessage::New() const {
  return new RewardNoticeMessage;
}

void RewardNoticeMessage::Clear() {
  update_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardNoticeMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardNoticeMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.RewardTypeState update = 1;
      case 1: {
        if (tag == 10) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_update()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_update;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardNoticeMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardNoticeMessage)
  return false;
#undef DO_
}

void RewardNoticeMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardNoticeMessage)
  // repeated .main.RewardTypeState update = 1;
  for (int i = 0; i < this->update_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->update(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardNoticeMessage)
}

int RewardNoticeMessage::ByteSize() const {
  int total_size = 0;

  // repeated .main.RewardTypeState update = 1;
  total_size += 1 * this->update_size();
  for (int i = 0; i < this->update_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->update(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardNoticeMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardNoticeMessage*>(&from));
}

void RewardNoticeMessage::MergeFrom(const RewardNoticeMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  update_.MergeFrom(from.update_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardNoticeMessage::CopyFrom(const RewardNoticeMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardNoticeMessage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->update())) return false;
  return true;
}

void RewardNoticeMessage::Swap(RewardNoticeMessage* other) {
  if (other != this) {
    update_.Swap(&other->update_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardNoticeMessage::GetTypeName() const {
  return "main.RewardNoticeMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardTypeState::kTypeFieldNumber;
const int RewardTypeState::kStateFieldNumber;
#endif  // !_MSC_VER

RewardTypeState::RewardTypeState()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardTypeState)
}

void RewardTypeState::InitAsDefaultInstance() {
}

RewardTypeState::RewardTypeState(const RewardTypeState& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardTypeState)
}

void RewardTypeState::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardTypeState::~RewardTypeState() {
  // @@protoc_insertion_point(destructor:main.RewardTypeState)
  SharedDtor();
}

void RewardTypeState::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardTypeState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardTypeState& RewardTypeState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardTypeState* RewardTypeState::default_instance_ = NULL;

RewardTypeState* RewardTypeState::New() const {
  return new RewardTypeState;
}

void RewardTypeState::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardTypeState*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, state_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardTypeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardTypeState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required int32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardTypeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardTypeState)
  return false;
#undef DO_
}

void RewardTypeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardTypeState)
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardTypeState)
}

int RewardTypeState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardTypeState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardTypeState*>(&from));
}

void RewardTypeState::MergeFrom(const RewardTypeState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardTypeState::CopyFrom(const RewardTypeState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardTypeState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RewardTypeState::Swap(RewardTypeState* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardTypeState::GetTypeName() const {
  return "main.RewardTypeState";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLianDanTimeRequest::kIndexFieldNumber;
#endif  // !_MSC_VER

RewardLianDanTimeRequest::RewardLianDanTimeRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLianDanTimeRequest)
}

void RewardLianDanTimeRequest::InitAsDefaultInstance() {
}

RewardLianDanTimeRequest::RewardLianDanTimeRequest(const RewardLianDanTimeRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLianDanTimeRequest)
}

void RewardLianDanTimeRequest::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLianDanTimeRequest::~RewardLianDanTimeRequest() {
  // @@protoc_insertion_point(destructor:main.RewardLianDanTimeRequest)
  SharedDtor();
}

void RewardLianDanTimeRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLianDanTimeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLianDanTimeRequest& RewardLianDanTimeRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLianDanTimeRequest* RewardLianDanTimeRequest::default_instance_ = NULL;

RewardLianDanTimeRequest* RewardLianDanTimeRequest::New() const {
  return new RewardLianDanTimeRequest;
}

void RewardLianDanTimeRequest::Clear() {
  index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLianDanTimeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLianDanTimeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLianDanTimeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLianDanTimeRequest)
  return false;
#undef DO_
}

void RewardLianDanTimeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLianDanTimeRequest)
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLianDanTimeRequest)
}

int RewardLianDanTimeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLianDanTimeRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLianDanTimeRequest*>(&from));
}

void RewardLianDanTimeRequest::MergeFrom(const RewardLianDanTimeRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLianDanTimeRequest::CopyFrom(const RewardLianDanTimeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLianDanTimeRequest::IsInitialized() const {

  return true;
}

void RewardLianDanTimeRequest::Swap(RewardLianDanTimeRequest* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLianDanTimeRequest::GetTypeName() const {
  return "main.RewardLianDanTimeRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLianDanTimeResponse::kTimeFieldNumber;
#endif  // !_MSC_VER

RewardLianDanTimeResponse::RewardLianDanTimeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLianDanTimeResponse)
}

void RewardLianDanTimeResponse::InitAsDefaultInstance() {
}

RewardLianDanTimeResponse::RewardLianDanTimeResponse(const RewardLianDanTimeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLianDanTimeResponse)
}

void RewardLianDanTimeResponse::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLianDanTimeResponse::~RewardLianDanTimeResponse() {
  // @@protoc_insertion_point(destructor:main.RewardLianDanTimeResponse)
  SharedDtor();
}

void RewardLianDanTimeResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLianDanTimeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLianDanTimeResponse& RewardLianDanTimeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLianDanTimeResponse* RewardLianDanTimeResponse::default_instance_ = NULL;

RewardLianDanTimeResponse* RewardLianDanTimeResponse::New() const {
  return new RewardLianDanTimeResponse;
}

void RewardLianDanTimeResponse::Clear() {
  time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLianDanTimeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLianDanTimeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLianDanTimeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLianDanTimeResponse)
  return false;
#undef DO_
}

void RewardLianDanTimeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLianDanTimeResponse)
  // optional int32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLianDanTimeResponse)
}

int RewardLianDanTimeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLianDanTimeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLianDanTimeResponse*>(&from));
}

void RewardLianDanTimeResponse::MergeFrom(const RewardLianDanTimeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLianDanTimeResponse::CopyFrom(const RewardLianDanTimeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLianDanTimeResponse::IsInitialized() const {

  return true;
}

void RewardLianDanTimeResponse::Swap(RewardLianDanTimeResponse* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLianDanTimeResponse::GetTypeName() const {
  return "main.RewardLianDanTimeResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLianDanRequest::kIndexFieldNumber;
const int RewardLianDanRequest::kIsHighFieldNumber;
#endif  // !_MSC_VER

RewardLianDanRequest::RewardLianDanRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLianDanRequest)
}

void RewardLianDanRequest::InitAsDefaultInstance() {
}

RewardLianDanRequest::RewardLianDanRequest(const RewardLianDanRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLianDanRequest)
}

void RewardLianDanRequest::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  ishigh_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLianDanRequest::~RewardLianDanRequest() {
  // @@protoc_insertion_point(destructor:main.RewardLianDanRequest)
  SharedDtor();
}

void RewardLianDanRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardLianDanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLianDanRequest& RewardLianDanRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLianDanRequest* RewardLianDanRequest::default_instance_ = NULL;

RewardLianDanRequest* RewardLianDanRequest::New() const {
  return new RewardLianDanRequest;
}

void RewardLianDanRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardLianDanRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(index_, ishigh_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLianDanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLianDanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_isHigh;
        break;
      }

      // optional int32 isHigh = 2;
      case 2: {
        if (tag == 16) {
         parse_isHigh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ishigh_)));
          set_has_ishigh();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLianDanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLianDanRequest)
  return false;
#undef DO_
}

void RewardLianDanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLianDanRequest)
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 isHigh = 2;
  if (has_ishigh()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ishigh(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLianDanRequest)
}

int RewardLianDanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 isHigh = 2;
    if (has_ishigh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ishigh());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLianDanRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLianDanRequest*>(&from));
}

void RewardLianDanRequest::MergeFrom(const RewardLianDanRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_ishigh()) {
      set_ishigh(from.ishigh());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLianDanRequest::CopyFrom(const RewardLianDanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLianDanRequest::IsInitialized() const {

  return true;
}

void RewardLianDanRequest::Swap(RewardLianDanRequest* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(ishigh_, other->ishigh_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLianDanRequest::GetTypeName() const {
  return "main.RewardLianDanRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardLianDanResponse::kStateFieldNumber;
const int RewardLianDanResponse::kItemIdFieldNumber;
const int RewardLianDanResponse::kPropsCardItemFieldNumber;
const int RewardLianDanResponse::kLianDanFieldNumber;
#endif  // !_MSC_VER

RewardLianDanResponse::RewardLianDanResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardLianDanResponse)
}

void RewardLianDanResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  propscarditem_ = const_cast< ::main::PropsCardItemProto*>(
      ::main::PropsCardItemProto::internal_default_instance());
#else
  propscarditem_ = const_cast< ::main::PropsCardItemProto*>(&::main::PropsCardItemProto::default_instance());
#endif
}

RewardLianDanResponse::RewardLianDanResponse(const RewardLianDanResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardLianDanResponse)
}

void RewardLianDanResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  itemid_ = 0;
  propscarditem_ = NULL;
  liandan_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardLianDanResponse::~RewardLianDanResponse() {
  // @@protoc_insertion_point(destructor:main.RewardLianDanResponse)
  SharedDtor();
}

void RewardLianDanResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete propscarditem_;
  }
}

void RewardLianDanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardLianDanResponse& RewardLianDanResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardLianDanResponse* RewardLianDanResponse::default_instance_ = NULL;

RewardLianDanResponse* RewardLianDanResponse::New() const {
  return new RewardLianDanResponse;
}

void RewardLianDanResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardLianDanResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(state_, itemid_);
    if (has_propscarditem()) {
      if (propscarditem_ != NULL) propscarditem_->::main::PropsCardItemProto::Clear();
    }
    liandan_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardLianDanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardLianDanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_itemId;
        break;
      }

      // optional int32 itemId = 2;
      case 2: {
        if (tag == 16) {
         parse_itemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_propsCardItem;
        break;
      }

      // optional .main.PropsCardItemProto propsCardItem = 3;
      case 3: {
        if (tag == 26) {
         parse_propsCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_propscarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_lianDan;
        break;
      }

      // optional int32 lianDan = 4;
      case 4: {
        if (tag == 32) {
         parse_lianDan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &liandan_)));
          set_has_liandan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardLianDanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardLianDanResponse)
  return false;
#undef DO_
}

void RewardLianDanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardLianDanResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional int32 itemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional .main.PropsCardItemProto propsCardItem = 3;
  if (has_propscarditem()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->propscarditem(), output);
  }

  // optional int32 lianDan = 4;
  if (has_liandan()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->liandan(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardLianDanResponse)
}

int RewardLianDanResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 itemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional .main.PropsCardItemProto propsCardItem = 3;
    if (has_propscarditem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->propscarditem());
    }

    // optional int32 lianDan = 4;
    if (has_liandan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->liandan());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardLianDanResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardLianDanResponse*>(&from));
}

void RewardLianDanResponse::MergeFrom(const RewardLianDanResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_propscarditem()) {
      mutable_propscarditem()->::main::PropsCardItemProto::MergeFrom(from.propscarditem());
    }
    if (from.has_liandan()) {
      set_liandan(from.liandan());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardLianDanResponse::CopyFrom(const RewardLianDanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardLianDanResponse::IsInitialized() const {

  return true;
}

void RewardLianDanResponse::Swap(RewardLianDanResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(itemid_, other->itemid_);
    std::swap(propscarditem_, other->propscarditem_);
    std::swap(liandan_, other->liandan_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardLianDanResponse::GetTypeName() const {
  return "main.RewardLianDanResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardRegLotteryPush::kNameFieldNumber;
const int RewardRegLotteryPush::kGoldFieldNumber;
#endif  // !_MSC_VER

RewardRegLotteryPush::RewardRegLotteryPush()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardRegLotteryPush)
}

void RewardRegLotteryPush::InitAsDefaultInstance() {
}

RewardRegLotteryPush::RewardRegLotteryPush(const RewardRegLotteryPush& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardRegLotteryPush)
}

void RewardRegLotteryPush::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardRegLotteryPush::~RewardRegLotteryPush() {
  // @@protoc_insertion_point(destructor:main.RewardRegLotteryPush)
  SharedDtor();
}

void RewardRegLotteryPush::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardRegLotteryPush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardRegLotteryPush& RewardRegLotteryPush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardRegLotteryPush* RewardRegLotteryPush::default_instance_ = NULL;

RewardRegLotteryPush* RewardRegLotteryPush::New() const {
  return new RewardRegLotteryPush;
}

void RewardRegLotteryPush::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    gold_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardRegLotteryPush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardRegLotteryPush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_gold;
        break;
      }

      // optional int32 gold = 2;
      case 2: {
        if (tag == 16) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardRegLotteryPush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardRegLotteryPush)
  return false;
#undef DO_
}

void RewardRegLotteryPush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardRegLotteryPush)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 gold = 2;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gold(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardRegLotteryPush)
}

int RewardRegLotteryPush::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 gold = 2;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardRegLotteryPush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardRegLotteryPush*>(&from));
}

void RewardRegLotteryPush::MergeFrom(const RewardRegLotteryPush& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardRegLotteryPush::CopyFrom(const RewardRegLotteryPush& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardRegLotteryPush::IsInitialized() const {

  return true;
}

void RewardRegLotteryPush::Swap(RewardRegLotteryPush* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(gold_, other->gold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardRegLotteryPush::GetTypeName() const {
  return "main.RewardRegLotteryPush";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardBindAccountRequest::RewardBindAccountRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindAccountRequest)
}

void RewardBindAccountRequest::InitAsDefaultInstance() {
}

RewardBindAccountRequest::RewardBindAccountRequest(const RewardBindAccountRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindAccountRequest)
}

void RewardBindAccountRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindAccountRequest::~RewardBindAccountRequest() {
  // @@protoc_insertion_point(destructor:main.RewardBindAccountRequest)
  SharedDtor();
}

void RewardBindAccountRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardBindAccountRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindAccountRequest& RewardBindAccountRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindAccountRequest* RewardBindAccountRequest::default_instance_ = NULL;

RewardBindAccountRequest* RewardBindAccountRequest::New() const {
  return new RewardBindAccountRequest;
}

void RewardBindAccountRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindAccountRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindAccountRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindAccountRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindAccountRequest)
  return false;
#undef DO_
}

void RewardBindAccountRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindAccountRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindAccountRequest)
}

int RewardBindAccountRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindAccountRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindAccountRequest*>(&from));
}

void RewardBindAccountRequest::MergeFrom(const RewardBindAccountRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindAccountRequest::CopyFrom(const RewardBindAccountRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindAccountRequest::IsInitialized() const {

  return true;
}

void RewardBindAccountRequest::Swap(RewardBindAccountRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindAccountRequest::GetTypeName() const {
  return "main.RewardBindAccountRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardBindAccountResponse::kStateFieldNumber;
const int RewardBindAccountResponse::kItemListFieldNumber;
#endif  // !_MSC_VER

RewardBindAccountResponse::RewardBindAccountResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindAccountResponse)
}

void RewardBindAccountResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  itemlist_ = const_cast< ::main::RewardItemListProto*>(
      ::main::RewardItemListProto::internal_default_instance());
#else
  itemlist_ = const_cast< ::main::RewardItemListProto*>(&::main::RewardItemListProto::default_instance());
#endif
}

RewardBindAccountResponse::RewardBindAccountResponse(const RewardBindAccountResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindAccountResponse)
}

void RewardBindAccountResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  itemlist_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindAccountResponse::~RewardBindAccountResponse() {
  // @@protoc_insertion_point(destructor:main.RewardBindAccountResponse)
  SharedDtor();
}

void RewardBindAccountResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete itemlist_;
  }
}

void RewardBindAccountResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindAccountResponse& RewardBindAccountResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindAccountResponse* RewardBindAccountResponse::default_instance_ = NULL;

RewardBindAccountResponse* RewardBindAccountResponse::New() const {
  return new RewardBindAccountResponse;
}

void RewardBindAccountResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    state_ = 0;
    if (has_itemlist()) {
      if (itemlist_ != NULL) itemlist_->::main::RewardItemListProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindAccountResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindAccountResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_itemList;
        break;
      }

      // optional .main.RewardItemListProto itemList = 2;
      case 2: {
        if (tag == 18) {
         parse_itemList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindAccountResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindAccountResponse)
  return false;
#undef DO_
}

void RewardBindAccountResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindAccountResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional .main.RewardItemListProto itemList = 2;
  if (has_itemlist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->itemlist(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindAccountResponse)
}

int RewardBindAccountResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional .main.RewardItemListProto itemList = 2;
    if (has_itemlist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemlist());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindAccountResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindAccountResponse*>(&from));
}

void RewardBindAccountResponse::MergeFrom(const RewardBindAccountResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_itemlist()) {
      mutable_itemlist()->::main::RewardItemListProto::MergeFrom(from.itemlist());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindAccountResponse::CopyFrom(const RewardBindAccountResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindAccountResponse::IsInitialized() const {

  return true;
}

void RewardBindAccountResponse::Swap(RewardBindAccountResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(itemlist_, other->itemlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindAccountResponse::GetTypeName() const {
  return "main.RewardBindAccountResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardItemListProto::kGoldFieldNumber;
const int RewardItemListProto::kCoinFieldNumber;
const int RewardItemListProto::kPvpScoreFieldNumber;
const int RewardItemListProto::kLianDanFieldNumber;
const int RewardItemListProto::kPropsCardItemFieldNumber;
const int RewardItemListProto::kOfficerCardItemFieldNumber;
const int RewardItemListProto::kEquipmentCardItemFieldNumber;
const int RewardItemListProto::kSoldierCardItemFieldNumber;
const int RewardItemListProto::kOfficerFragmentCardItemFieldNumber;
#endif  // !_MSC_VER

RewardItemListProto::RewardItemListProto()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardItemListProto)
}

void RewardItemListProto::InitAsDefaultInstance() {
}

RewardItemListProto::RewardItemListProto(const RewardItemListProto& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardItemListProto)
}

void RewardItemListProto::SharedCtor() {
  _cached_size_ = 0;
  gold_ = 0;
  coin_ = 0;
  pvpscore_ = 0;
  liandan_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardItemListProto::~RewardItemListProto() {
  // @@protoc_insertion_point(destructor:main.RewardItemListProto)
  SharedDtor();
}

void RewardItemListProto::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardItemListProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardItemListProto& RewardItemListProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardItemListProto* RewardItemListProto::default_instance_ = NULL;

RewardItemListProto* RewardItemListProto::New() const {
  return new RewardItemListProto;
}

void RewardItemListProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardItemListProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(gold_, liandan_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  propscarditem_.Clear();
  officercarditem_.Clear();
  equipmentcarditem_.Clear();
  soldiercarditem_.Clear();
  officerfragmentcarditem_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardItemListProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardItemListProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 gold = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_coin;
        break;
      }

      // optional int32 coin = 2;
      case 2: {
        if (tag == 16) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_pvpScore;
        break;
      }

      // optional int32 pvpScore = 3;
      case 3: {
        if (tag == 24) {
         parse_pvpScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pvpscore_)));
          set_has_pvpscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_lianDan;
        break;
      }

      // optional int32 lianDan = 4;
      case 4: {
        if (tag == 32) {
         parse_lianDan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &liandan_)));
          set_has_liandan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_propsCardItem;
        break;
      }

      // repeated .main.PropsCardItemProto propsCardItem = 5;
      case 5: {
        if (tag == 42) {
         parse_propsCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_propscarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_propsCardItem;
        if (input->ExpectTag(50)) goto parse_officerCardItem;
        break;
      }

      // repeated .main.OfficerCardItemProto officerCardItem = 6;
      case 6: {
        if (tag == 50) {
         parse_officerCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_officercarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_officerCardItem;
        if (input->ExpectTag(58)) goto parse_equipmentCardItem;
        break;
      }

      // repeated .main.EquipmentCardItemProto equipmentCardItem = 7;
      case 7: {
        if (tag == 58) {
         parse_equipmentCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_equipmentcarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_equipmentCardItem;
        if (input->ExpectTag(66)) goto parse_SoldierCardItem;
        break;
      }

      // repeated .main.SoldierCardItemProto SoldierCardItem = 8;
      case 8: {
        if (tag == 66) {
         parse_SoldierCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_soldiercarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_SoldierCardItem;
        if (input->ExpectTag(74)) goto parse_officerFragmentCardItem;
        break;
      }

      // repeated .main.OfficerFragmentCardItemProto officerFragmentCardItem = 9;
      case 9: {
        if (tag == 74) {
         parse_officerFragmentCardItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_officerfragmentcarditem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_officerFragmentCardItem;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardItemListProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardItemListProto)
  return false;
#undef DO_
}

void RewardItemListProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardItemListProto)
  // optional int32 gold = 1;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gold(), output);
  }

  // optional int32 coin = 2;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->coin(), output);
  }

  // optional int32 pvpScore = 3;
  if (has_pvpscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pvpscore(), output);
  }

  // optional int32 lianDan = 4;
  if (has_liandan()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->liandan(), output);
  }

  // repeated .main.PropsCardItemProto propsCardItem = 5;
  for (int i = 0; i < this->propscarditem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->propscarditem(i), output);
  }

  // repeated .main.OfficerCardItemProto officerCardItem = 6;
  for (int i = 0; i < this->officercarditem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->officercarditem(i), output);
  }

  // repeated .main.EquipmentCardItemProto equipmentCardItem = 7;
  for (int i = 0; i < this->equipmentcarditem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->equipmentcarditem(i), output);
  }

  // repeated .main.SoldierCardItemProto SoldierCardItem = 8;
  for (int i = 0; i < this->soldiercarditem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->soldiercarditem(i), output);
  }

  // repeated .main.OfficerFragmentCardItemProto officerFragmentCardItem = 9;
  for (int i = 0; i < this->officerfragmentcarditem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->officerfragmentcarditem(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardItemListProto)
}

int RewardItemListProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 gold = 1;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

    // optional int32 coin = 2;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional int32 pvpScore = 3;
    if (has_pvpscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pvpscore());
    }

    // optional int32 lianDan = 4;
    if (has_liandan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->liandan());
    }

  }
  // repeated .main.PropsCardItemProto propsCardItem = 5;
  total_size += 1 * this->propscarditem_size();
  for (int i = 0; i < this->propscarditem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->propscarditem(i));
  }

  // repeated .main.OfficerCardItemProto officerCardItem = 6;
  total_size += 1 * this->officercarditem_size();
  for (int i = 0; i < this->officercarditem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->officercarditem(i));
  }

  // repeated .main.EquipmentCardItemProto equipmentCardItem = 7;
  total_size += 1 * this->equipmentcarditem_size();
  for (int i = 0; i < this->equipmentcarditem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->equipmentcarditem(i));
  }

  // repeated .main.SoldierCardItemProto SoldierCardItem = 8;
  total_size += 1 * this->soldiercarditem_size();
  for (int i = 0; i < this->soldiercarditem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->soldiercarditem(i));
  }

  // repeated .main.OfficerFragmentCardItemProto officerFragmentCardItem = 9;
  total_size += 1 * this->officerfragmentcarditem_size();
  for (int i = 0; i < this->officerfragmentcarditem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->officerfragmentcarditem(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardItemListProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardItemListProto*>(&from));
}

void RewardItemListProto::MergeFrom(const RewardItemListProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  propscarditem_.MergeFrom(from.propscarditem_);
  officercarditem_.MergeFrom(from.officercarditem_);
  equipmentcarditem_.MergeFrom(from.equipmentcarditem_);
  soldiercarditem_.MergeFrom(from.soldiercarditem_);
  officerfragmentcarditem_.MergeFrom(from.officerfragmentcarditem_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_pvpscore()) {
      set_pvpscore(from.pvpscore());
    }
    if (from.has_liandan()) {
      set_liandan(from.liandan());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardItemListProto::CopyFrom(const RewardItemListProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardItemListProto::IsInitialized() const {

  return true;
}

void RewardItemListProto::Swap(RewardItemListProto* other) {
  if (other != this) {
    std::swap(gold_, other->gold_);
    std::swap(coin_, other->coin_);
    std::swap(pvpscore_, other->pvpscore_);
    std::swap(liandan_, other->liandan_);
    propscarditem_.Swap(&other->propscarditem_);
    officercarditem_.Swap(&other->officercarditem_);
    equipmentcarditem_.Swap(&other->equipmentcarditem_);
    soldiercarditem_.Swap(&other->soldiercarditem_);
    officerfragmentcarditem_.Swap(&other->officerfragmentcarditem_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardItemListProto::GetTypeName() const {
  return "main.RewardItemListProto";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardBindAccountInfoRequest::RewardBindAccountInfoRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindAccountInfoRequest)
}

void RewardBindAccountInfoRequest::InitAsDefaultInstance() {
}

RewardBindAccountInfoRequest::RewardBindAccountInfoRequest(const RewardBindAccountInfoRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindAccountInfoRequest)
}

void RewardBindAccountInfoRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindAccountInfoRequest::~RewardBindAccountInfoRequest() {
  // @@protoc_insertion_point(destructor:main.RewardBindAccountInfoRequest)
  SharedDtor();
}

void RewardBindAccountInfoRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardBindAccountInfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindAccountInfoRequest& RewardBindAccountInfoRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindAccountInfoRequest* RewardBindAccountInfoRequest::default_instance_ = NULL;

RewardBindAccountInfoRequest* RewardBindAccountInfoRequest::New() const {
  return new RewardBindAccountInfoRequest;
}

void RewardBindAccountInfoRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindAccountInfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindAccountInfoRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindAccountInfoRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindAccountInfoRequest)
  return false;
#undef DO_
}

void RewardBindAccountInfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindAccountInfoRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindAccountInfoRequest)
}

int RewardBindAccountInfoRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindAccountInfoRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindAccountInfoRequest*>(&from));
}

void RewardBindAccountInfoRequest::MergeFrom(const RewardBindAccountInfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindAccountInfoRequest::CopyFrom(const RewardBindAccountInfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindAccountInfoRequest::IsInitialized() const {

  return true;
}

void RewardBindAccountInfoRequest::Swap(RewardBindAccountInfoRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindAccountInfoRequest::GetTypeName() const {
  return "main.RewardBindAccountInfoRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardBindAccountInfoResponse::kStateFieldNumber;
const int RewardBindAccountInfoResponse::kRewardInfoFieldNumber;
const int RewardBindAccountInfoResponse::kMailStateFieldNumber;
const int RewardBindAccountInfoResponse::kMailFieldNumber;
const int RewardBindAccountInfoResponse::kMailRewardInfoFieldNumber;
#endif  // !_MSC_VER

RewardBindAccountInfoResponse::RewardBindAccountInfoResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindAccountInfoResponse)
}

void RewardBindAccountInfoResponse::InitAsDefaultInstance() {
}

RewardBindAccountInfoResponse::RewardBindAccountInfoResponse(const RewardBindAccountInfoResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindAccountInfoResponse)
}

void RewardBindAccountInfoResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  state_ = 0;
  mailstate_ = 0;
  mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindAccountInfoResponse::~RewardBindAccountInfoResponse() {
  // @@protoc_insertion_point(destructor:main.RewardBindAccountInfoResponse)
  SharedDtor();
}

void RewardBindAccountInfoResponse::SharedDtor() {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardBindAccountInfoResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindAccountInfoResponse& RewardBindAccountInfoResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindAccountInfoResponse* RewardBindAccountInfoResponse::default_instance_ = NULL;

RewardBindAccountInfoResponse* RewardBindAccountInfoResponse::New() const {
  return new RewardBindAccountInfoResponse;
}

void RewardBindAccountInfoResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardBindAccountInfoResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 13) {
    ZR_(state_, mailstate_);
    if (has_mail()) {
      if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mail_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  rewardinfo_.Clear();
  mailrewardinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindAccountInfoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindAccountInfoResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rewardInfo;
        break;
      }

      // repeated .main.RewardInfoProto rewardInfo = 2;
      case 2: {
        if (tag == 18) {
         parse_rewardInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rewardinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rewardInfo;
        if (input->ExpectTag(24)) goto parse_mailState;
        break;
      }

      // optional int32 mailState = 3;
      case 3: {
        if (tag == 24) {
         parse_mailState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mailstate_)));
          set_has_mailstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mail;
        break;
      }

      // optional string mail = 4;
      case 4: {
        if (tag == 34) {
         parse_mail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mailRewardInfo;
        break;
      }

      // repeated .main.RewardInfoProto mailRewardInfo = 5;
      case 5: {
        if (tag == 42) {
         parse_mailRewardInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mailrewardinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mailRewardInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindAccountInfoResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindAccountInfoResponse)
  return false;
#undef DO_
}

void RewardBindAccountInfoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindAccountInfoResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // repeated .main.RewardInfoProto rewardInfo = 2;
  for (int i = 0; i < this->rewardinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->rewardinfo(i), output);
  }

  // optional int32 mailState = 3;
  if (has_mailstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->mailstate(), output);
  }

  // optional string mail = 4;
  if (has_mail()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->mail(), output);
  }

  // repeated .main.RewardInfoProto mailRewardInfo = 5;
  for (int i = 0; i < this->mailrewardinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->mailrewardinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindAccountInfoResponse)
}

int RewardBindAccountInfoResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 mailState = 3;
    if (has_mailstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mailstate());
    }

    // optional string mail = 4;
    if (has_mail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mail());
    }

  }
  // repeated .main.RewardInfoProto rewardInfo = 2;
  total_size += 1 * this->rewardinfo_size();
  for (int i = 0; i < this->rewardinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rewardinfo(i));
  }

  // repeated .main.RewardInfoProto mailRewardInfo = 5;
  total_size += 1 * this->mailrewardinfo_size();
  for (int i = 0; i < this->mailrewardinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mailrewardinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindAccountInfoResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindAccountInfoResponse*>(&from));
}

void RewardBindAccountInfoResponse::MergeFrom(const RewardBindAccountInfoResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  rewardinfo_.MergeFrom(from.rewardinfo_);
  mailrewardinfo_.MergeFrom(from.mailrewardinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_mailstate()) {
      set_mailstate(from.mailstate());
    }
    if (from.has_mail()) {
      set_mail(from.mail());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindAccountInfoResponse::CopyFrom(const RewardBindAccountInfoResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindAccountInfoResponse::IsInitialized() const {

  return true;
}

void RewardBindAccountInfoResponse::Swap(RewardBindAccountInfoResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    rewardinfo_.Swap(&other->rewardinfo_);
    std::swap(mailstate_, other->mailstate_);
    std::swap(mail_, other->mail_);
    mailrewardinfo_.Swap(&other->mailrewardinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindAccountInfoResponse::GetTypeName() const {
  return "main.RewardBindAccountInfoResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BindMailRequest::kStateFieldNumber;
const int BindMailRequest::kMailFieldNumber;
#endif  // !_MSC_VER

BindMailRequest::BindMailRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BindMailRequest)
}

void BindMailRequest::InitAsDefaultInstance() {
}

BindMailRequest::BindMailRequest(const BindMailRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BindMailRequest)
}

void BindMailRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  state_ = 0;
  mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BindMailRequest::~BindMailRequest() {
  // @@protoc_insertion_point(destructor:main.BindMailRequest)
  SharedDtor();
}

void BindMailRequest::SharedDtor() {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BindMailRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BindMailRequest& BindMailRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

BindMailRequest* BindMailRequest::default_instance_ = NULL;

BindMailRequest* BindMailRequest::New() const {
  return new BindMailRequest;
}

void BindMailRequest::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    state_ = 0;
    if (has_mail()) {
      if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mail_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BindMailRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BindMailRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mail;
        break;
      }

      // optional string mail = 2;
      case 2: {
        if (tag == 18) {
         parse_mail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BindMailRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BindMailRequest)
  return false;
#undef DO_
}

void BindMailRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BindMailRequest)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional string mail = 2;
  if (has_mail()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mail(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BindMailRequest)
}

int BindMailRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional string mail = 2;
    if (has_mail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mail());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BindMailRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BindMailRequest*>(&from));
}

void BindMailRequest::MergeFrom(const BindMailRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_mail()) {
      set_mail(from.mail());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BindMailRequest::CopyFrom(const BindMailRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BindMailRequest::IsInitialized() const {

  return true;
}

void BindMailRequest::Swap(BindMailRequest* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(mail_, other->mail_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BindMailRequest::GetTypeName() const {
  return "main.BindMailRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int BindMailResponse::kStateFieldNumber;
#endif  // !_MSC_VER

BindMailResponse::BindMailResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.BindMailResponse)
}

void BindMailResponse::InitAsDefaultInstance() {
}

BindMailResponse::BindMailResponse(const BindMailResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.BindMailResponse)
}

void BindMailResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BindMailResponse::~BindMailResponse() {
  // @@protoc_insertion_point(destructor:main.BindMailResponse)
  SharedDtor();
}

void BindMailResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BindMailResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BindMailResponse& BindMailResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

BindMailResponse* BindMailResponse::default_instance_ = NULL;

BindMailResponse* BindMailResponse::New() const {
  return new BindMailResponse;
}

void BindMailResponse::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BindMailResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.BindMailResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.BindMailResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.BindMailResponse)
  return false;
#undef DO_
}

void BindMailResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.BindMailResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.BindMailResponse)
}

int BindMailResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BindMailResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BindMailResponse*>(&from));
}

void BindMailResponse::MergeFrom(const BindMailResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BindMailResponse::CopyFrom(const BindMailResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BindMailResponse::IsInitialized() const {

  return true;
}

void BindMailResponse::Swap(BindMailResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BindMailResponse::GetTypeName() const {
  return "main.BindMailResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RewardBindMailRequest::RewardBindMailRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindMailRequest)
}

void RewardBindMailRequest::InitAsDefaultInstance() {
}

RewardBindMailRequest::RewardBindMailRequest(const RewardBindMailRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindMailRequest)
}

void RewardBindMailRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindMailRequest::~RewardBindMailRequest() {
  // @@protoc_insertion_point(destructor:main.RewardBindMailRequest)
  SharedDtor();
}

void RewardBindMailRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardBindMailRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindMailRequest& RewardBindMailRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindMailRequest* RewardBindMailRequest::default_instance_ = NULL;

RewardBindMailRequest* RewardBindMailRequest::New() const {
  return new RewardBindMailRequest;
}

void RewardBindMailRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindMailRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindMailRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindMailRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindMailRequest)
  return false;
#undef DO_
}

void RewardBindMailRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindMailRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindMailRequest)
}

int RewardBindMailRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindMailRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindMailRequest*>(&from));
}

void RewardBindMailRequest::MergeFrom(const RewardBindMailRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindMailRequest::CopyFrom(const RewardBindMailRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindMailRequest::IsInitialized() const {

  return true;
}

void RewardBindMailRequest::Swap(RewardBindMailRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindMailRequest::GetTypeName() const {
  return "main.RewardBindMailRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardBindMailResponse::kStateFieldNumber;
const int RewardBindMailResponse::kItemListFieldNumber;
#endif  // !_MSC_VER

RewardBindMailResponse::RewardBindMailResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardBindMailResponse)
}

void RewardBindMailResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  itemlist_ = const_cast< ::main::RewardItemListProto*>(
      ::main::RewardItemListProto::internal_default_instance());
#else
  itemlist_ = const_cast< ::main::RewardItemListProto*>(&::main::RewardItemListProto::default_instance());
#endif
}

RewardBindMailResponse::RewardBindMailResponse(const RewardBindMailResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardBindMailResponse)
}

void RewardBindMailResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  itemlist_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardBindMailResponse::~RewardBindMailResponse() {
  // @@protoc_insertion_point(destructor:main.RewardBindMailResponse)
  SharedDtor();
}

void RewardBindMailResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete itemlist_;
  }
}

void RewardBindMailResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardBindMailResponse& RewardBindMailResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardBindMailResponse* RewardBindMailResponse::default_instance_ = NULL;

RewardBindMailResponse* RewardBindMailResponse::New() const {
  return new RewardBindMailResponse;
}

void RewardBindMailResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    state_ = 0;
    if (has_itemlist()) {
      if (itemlist_ != NULL) itemlist_->::main::RewardItemListProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardBindMailResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardBindMailResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_itemList;
        break;
      }

      // optional .main.RewardItemListProto itemList = 2;
      case 2: {
        if (tag == 18) {
         parse_itemList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardBindMailResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardBindMailResponse)
  return false;
#undef DO_
}

void RewardBindMailResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardBindMailResponse)
  // optional int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional .main.RewardItemListProto itemList = 2;
  if (has_itemlist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->itemlist(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardBindMailResponse)
}

int RewardBindMailResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional .main.RewardItemListProto itemList = 2;
    if (has_itemlist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemlist());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardBindMailResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardBindMailResponse*>(&from));
}

void RewardBindMailResponse::MergeFrom(const RewardBindMailResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_itemlist()) {
      mutable_itemlist()->::main::RewardItemListProto::MergeFrom(from.itemlist());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardBindMailResponse::CopyFrom(const RewardBindMailResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardBindMailResponse::IsInitialized() const {

  return true;
}

void RewardBindMailResponse::Swap(RewardBindMailResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(itemlist_, other->itemlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardBindMailResponse::GetTypeName() const {
  return "main.RewardBindMailResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ExchangeCodeEntryRequest::ExchangeCodeEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ExchangeCodeEntryRequest)
}

void ExchangeCodeEntryRequest::InitAsDefaultInstance() {
}

ExchangeCodeEntryRequest::ExchangeCodeEntryRequest(const ExchangeCodeEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ExchangeCodeEntryRequest)
}

void ExchangeCodeEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExchangeCodeEntryRequest::~ExchangeCodeEntryRequest() {
  // @@protoc_insertion_point(destructor:main.ExchangeCodeEntryRequest)
  SharedDtor();
}

void ExchangeCodeEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExchangeCodeEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExchangeCodeEntryRequest& ExchangeCodeEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

ExchangeCodeEntryRequest* ExchangeCodeEntryRequest::default_instance_ = NULL;

ExchangeCodeEntryRequest* ExchangeCodeEntryRequest::New() const {
  return new ExchangeCodeEntryRequest;
}

void ExchangeCodeEntryRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ExchangeCodeEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ExchangeCodeEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.ExchangeCodeEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ExchangeCodeEntryRequest)
  return false;
#undef DO_
}

void ExchangeCodeEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ExchangeCodeEntryRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ExchangeCodeEntryRequest)
}

int ExchangeCodeEntryRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExchangeCodeEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExchangeCodeEntryRequest*>(&from));
}

void ExchangeCodeEntryRequest::MergeFrom(const ExchangeCodeEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ExchangeCodeEntryRequest::CopyFrom(const ExchangeCodeEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeCodeEntryRequest::IsInitialized() const {

  return true;
}

void ExchangeCodeEntryRequest::Swap(ExchangeCodeEntryRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExchangeCodeEntryRequest::GetTypeName() const {
  return "main.ExchangeCodeEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ExchangeCodeEntryResponse::kInfoFieldNumber;
#endif  // !_MSC_VER

ExchangeCodeEntryResponse::ExchangeCodeEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ExchangeCodeEntryResponse)
}

void ExchangeCodeEntryResponse::InitAsDefaultInstance() {
}

ExchangeCodeEntryResponse::ExchangeCodeEntryResponse(const ExchangeCodeEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ExchangeCodeEntryResponse)
}

void ExchangeCodeEntryResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExchangeCodeEntryResponse::~ExchangeCodeEntryResponse() {
  // @@protoc_insertion_point(destructor:main.ExchangeCodeEntryResponse)
  SharedDtor();
}

void ExchangeCodeEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExchangeCodeEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExchangeCodeEntryResponse& ExchangeCodeEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

ExchangeCodeEntryResponse* ExchangeCodeEntryResponse::default_instance_ = NULL;

ExchangeCodeEntryResponse* ExchangeCodeEntryResponse::New() const {
  return new ExchangeCodeEntryResponse;
}

void ExchangeCodeEntryResponse::Clear() {
  info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ExchangeCodeEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ExchangeCodeEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string info = 1;
      case 1: {
        if (tag == 10) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.ExchangeCodeEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ExchangeCodeEntryResponse)
  return false;
#undef DO_
}

void ExchangeCodeEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ExchangeCodeEntryResponse)
  // repeated string info = 1;
  for (int i = 0; i < this->info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->info(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ExchangeCodeEntryResponse)
}

int ExchangeCodeEntryResponse::ByteSize() const {
  int total_size = 0;

  // repeated string info = 1;
  total_size += 1 * this->info_size();
  for (int i = 0; i < this->info_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExchangeCodeEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExchangeCodeEntryResponse*>(&from));
}

void ExchangeCodeEntryResponse::MergeFrom(const ExchangeCodeEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_.MergeFrom(from.info_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ExchangeCodeEntryResponse::CopyFrom(const ExchangeCodeEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeCodeEntryResponse::IsInitialized() const {

  return true;
}

void ExchangeCodeEntryResponse::Swap(ExchangeCodeEntryResponse* other) {
  if (other != this) {
    info_.Swap(&other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExchangeCodeEntryResponse::GetTypeName() const {
  return "main.ExchangeCodeEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int ExchangeCodeInfoRequest::kCodeFieldNumber;
#endif  // !_MSC_VER

ExchangeCodeInfoRequest::ExchangeCodeInfoRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ExchangeCodeInfoRequest)
}

void ExchangeCodeInfoRequest::InitAsDefaultInstance() {
}

ExchangeCodeInfoRequest::ExchangeCodeInfoRequest(const ExchangeCodeInfoRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ExchangeCodeInfoRequest)
}

void ExchangeCodeInfoRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExchangeCodeInfoRequest::~ExchangeCodeInfoRequest() {
  // @@protoc_insertion_point(destructor:main.ExchangeCodeInfoRequest)
  SharedDtor();
}

void ExchangeCodeInfoRequest::SharedDtor() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExchangeCodeInfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExchangeCodeInfoRequest& ExchangeCodeInfoRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

ExchangeCodeInfoRequest* ExchangeCodeInfoRequest::default_instance_ = NULL;

ExchangeCodeInfoRequest* ExchangeCodeInfoRequest::New() const {
  return new ExchangeCodeInfoRequest;
}

void ExchangeCodeInfoRequest::Clear() {
  if (has_code()) {
    if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      code_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ExchangeCodeInfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ExchangeCodeInfoRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string code = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_code()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.ExchangeCodeInfoRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ExchangeCodeInfoRequest)
  return false;
#undef DO_
}

void ExchangeCodeInfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ExchangeCodeInfoRequest)
  // optional string code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ExchangeCodeInfoRequest)
}

int ExchangeCodeInfoRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExchangeCodeInfoRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExchangeCodeInfoRequest*>(&from));
}

void ExchangeCodeInfoRequest::MergeFrom(const ExchangeCodeInfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ExchangeCodeInfoRequest::CopyFrom(const ExchangeCodeInfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeCodeInfoRequest::IsInitialized() const {

  return true;
}

void ExchangeCodeInfoRequest::Swap(ExchangeCodeInfoRequest* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExchangeCodeInfoRequest::GetTypeName() const {
  return "main.ExchangeCodeInfoRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ExchangeCodeInfoResponse::kStateFieldNumber;
const int ExchangeCodeInfoResponse::kRewardIdFieldNumber;
const int ExchangeCodeInfoResponse::kRewardInfoFieldNumber;
#endif  // !_MSC_VER

ExchangeCodeInfoResponse::ExchangeCodeInfoResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ExchangeCodeInfoResponse)
}

void ExchangeCodeInfoResponse::InitAsDefaultInstance() {
}

ExchangeCodeInfoResponse::ExchangeCodeInfoResponse(const ExchangeCodeInfoResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ExchangeCodeInfoResponse)
}

void ExchangeCodeInfoResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  rewardid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExchangeCodeInfoResponse::~ExchangeCodeInfoResponse() {
  // @@protoc_insertion_point(destructor:main.ExchangeCodeInfoResponse)
  SharedDtor();
}

void ExchangeCodeInfoResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExchangeCodeInfoResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExchangeCodeInfoResponse& ExchangeCodeInfoResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

ExchangeCodeInfoResponse* ExchangeCodeInfoResponse::default_instance_ = NULL;

ExchangeCodeInfoResponse* ExchangeCodeInfoResponse::New() const {
  return new ExchangeCodeInfoResponse;
}

void ExchangeCodeInfoResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ExchangeCodeInfoResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(state_, rewardid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  rewardinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ExchangeCodeInfoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ExchangeCodeInfoResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rewardId;
        break;
      }

      // optional int32 rewardId = 2;
      case 2: {
        if (tag == 16) {
         parse_rewardId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rewardid_)));
          set_has_rewardid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_rewardInfo;
        break;
      }

      // repeated .main.RewardInfoProto rewardInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_rewardInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rewardinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_rewardInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.ExchangeCodeInfoResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ExchangeCodeInfoResponse)
  return false;
#undef DO_
}

void ExchangeCodeInfoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ExchangeCodeInfoResponse)
  // required int32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->state(), output);
  }

  // optional int32 rewardId = 2;
  if (has_rewardid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rewardid(), output);
  }

  // repeated .main.RewardInfoProto rewardInfo = 3;
  for (int i = 0; i < this->rewardinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->rewardinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ExchangeCodeInfoResponse)
}

int ExchangeCodeInfoResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // optional int32 rewardId = 2;
    if (has_rewardid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rewardid());
    }

  }
  // repeated .main.RewardInfoProto rewardInfo = 3;
  total_size += 1 * this->rewardinfo_size();
  for (int i = 0; i < this->rewardinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rewardinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExchangeCodeInfoResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExchangeCodeInfoResponse*>(&from));
}

void ExchangeCodeInfoResponse::MergeFrom(const ExchangeCodeInfoResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  rewardinfo_.MergeFrom(from.rewardinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_rewardid()) {
      set_rewardid(from.rewardid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ExchangeCodeInfoResponse::CopyFrom(const ExchangeCodeInfoResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeCodeInfoResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExchangeCodeInfoResponse::Swap(ExchangeCodeInfoResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(rewardid_, other->rewardid_);
    rewardinfo_.Swap(&other->rewardinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExchangeCodeInfoResponse::GetTypeName() const {
  return "main.ExchangeCodeInfoResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RewardInfoProto::kTypeFieldNumber;
const int RewardInfoProto::kValueFieldNumber;
const int RewardInfoProto::kNumberFieldNumber;
#endif  // !_MSC_VER

RewardInfoProto::RewardInfoProto()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.RewardInfoProto)
}

void RewardInfoProto::InitAsDefaultInstance() {
}

RewardInfoProto::RewardInfoProto(const RewardInfoProto& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.RewardInfoProto)
}

void RewardInfoProto::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  value_ = 0;
  number_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RewardInfoProto::~RewardInfoProto() {
  // @@protoc_insertion_point(destructor:main.RewardInfoProto)
  SharedDtor();
}

void RewardInfoProto::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RewardInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RewardInfoProto& RewardInfoProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

RewardInfoProto* RewardInfoProto::default_instance_ = NULL;

RewardInfoProto* RewardInfoProto::New() const {
  return new RewardInfoProto;
}

void RewardInfoProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RewardInfoProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, number_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RewardInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.RewardInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_number;
        break;
      }

      // optional int32 number = 3;
      case 3: {
        if (tag == 24) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.RewardInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.RewardInfoProto)
  return false;
#undef DO_
}

void RewardInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.RewardInfoProto)
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  // optional int32 number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.RewardInfoProto)
}

int RewardInfoProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

    // optional int32 number = 3;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->number());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RewardInfoProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RewardInfoProto*>(&from));
}

void RewardInfoProto::MergeFrom(const RewardInfoProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RewardInfoProto::CopyFrom(const RewardInfoProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardInfoProto::IsInitialized() const {

  return true;
}

void RewardInfoProto::Swap(RewardInfoProto* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(value_, other->value_);
    std::swap(number_, other->number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RewardInfoProto::GetTypeName() const {
  return "main.RewardInfoProto";
}


// ===================================================================

#ifndef _MSC_VER
const int FirstPayRewardResponse::kFirstPayRewardItemProtoFieldNumber;
#endif  // !_MSC_VER

FirstPayRewardResponse::FirstPayRewardResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.FirstPayRewardResponse)
}

void FirstPayRewardResponse::InitAsDefaultInstance() {
}

FirstPayRewardResponse::FirstPayRewardResponse(const FirstPayRewardResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.FirstPayRewardResponse)
}

void FirstPayRewardResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstPayRewardResponse::~FirstPayRewardResponse() {
  // @@protoc_insertion_point(destructor:main.FirstPayRewardResponse)
  SharedDtor();
}

void FirstPayRewardResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FirstPayRewardResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FirstPayRewardResponse& FirstPayRewardResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

FirstPayRewardResponse* FirstPayRewardResponse::default_instance_ = NULL;

FirstPayRewardResponse* FirstPayRewardResponse::New() const {
  return new FirstPayRewardResponse;
}

void FirstPayRewardResponse::Clear() {
  firstpayrewarditemproto_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool FirstPayRewardResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.FirstPayRewardResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.FirstPayRewardItemProto firstPayRewardItemProto = 1;
      case 1: {
        if (tag == 10) {
         parse_firstPayRewardItemProto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_firstpayrewarditemproto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_firstPayRewardItemProto;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.FirstPayRewardResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.FirstPayRewardResponse)
  return false;
#undef DO_
}

void FirstPayRewardResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.FirstPayRewardResponse)
  // repeated .main.FirstPayRewardItemProto firstPayRewardItemProto = 1;
  for (int i = 0; i < this->firstpayrewarditemproto_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->firstpayrewarditemproto(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.FirstPayRewardResponse)
}

int FirstPayRewardResponse::ByteSize() const {
  int total_size = 0;

  // repeated .main.FirstPayRewardItemProto firstPayRewardItemProto = 1;
  total_size += 1 * this->firstpayrewarditemproto_size();
  for (int i = 0; i < this->firstpayrewarditemproto_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->firstpayrewarditemproto(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstPayRewardResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FirstPayRewardResponse*>(&from));
}

void FirstPayRewardResponse::MergeFrom(const FirstPayRewardResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  firstpayrewarditemproto_.MergeFrom(from.firstpayrewarditemproto_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void FirstPayRewardResponse::CopyFrom(const FirstPayRewardResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstPayRewardResponse::IsInitialized() const {

  return true;
}

void FirstPayRewardResponse::Swap(FirstPayRewardResponse* other) {
  if (other != this) {
    firstpayrewarditemproto_.Swap(&other->firstpayrewarditemproto_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FirstPayRewardResponse::GetTypeName() const {
  return "main.FirstPayRewardResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int FirstPayRewardItemProto::kItemTypeFieldNumber;
const int FirstPayRewardItemProto::kItemIdFieldNumber;
const int FirstPayRewardItemProto::kItemCountFieldNumber;
const int FirstPayRewardItemProto::kItemLevelFieldNumber;
#endif  // !_MSC_VER

FirstPayRewardItemProto::FirstPayRewardItemProto()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.FirstPayRewardItemProto)
}

void FirstPayRewardItemProto::InitAsDefaultInstance() {
}

FirstPayRewardItemProto::FirstPayRewardItemProto(const FirstPayRewardItemProto& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.FirstPayRewardItemProto)
}

void FirstPayRewardItemProto::SharedCtor() {
  _cached_size_ = 0;
  itemtype_ = 0;
  itemid_ = 0;
  itemcount_ = 0;
  itemlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstPayRewardItemProto::~FirstPayRewardItemProto() {
  // @@protoc_insertion_point(destructor:main.FirstPayRewardItemProto)
  SharedDtor();
}

void FirstPayRewardItemProto::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FirstPayRewardItemProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FirstPayRewardItemProto& FirstPayRewardItemProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

FirstPayRewardItemProto* FirstPayRewardItemProto::default_instance_ = NULL;

FirstPayRewardItemProto* FirstPayRewardItemProto::New() const {
  return new FirstPayRewardItemProto;
}

void FirstPayRewardItemProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FirstPayRewardItemProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemtype_, itemlevel_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool FirstPayRewardItemProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.FirstPayRewardItemProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 itemType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemtype_)));
          set_has_itemtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_itemId;
        break;
      }

      // optional int32 itemId = 2;
      case 2: {
        if (tag == 16) {
         parse_itemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemCount;
        break;
      }

      // optional int32 itemCount = 3;
      case 3: {
        if (tag == 24) {
         parse_itemCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemcount_)));
          set_has_itemcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_itemLevel;
        break;
      }

      // optional int32 itemLevel = 4;
      case 4: {
        if (tag == 32) {
         parse_itemLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemlevel_)));
          set_has_itemlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.FirstPayRewardItemProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.FirstPayRewardItemProto)
  return false;
#undef DO_
}

void FirstPayRewardItemProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.FirstPayRewardItemProto)
  // optional int32 itemType = 1;
  if (has_itemtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemtype(), output);
  }

  // optional int32 itemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional int32 itemCount = 3;
  if (has_itemcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->itemcount(), output);
  }

  // optional int32 itemLevel = 4;
  if (has_itemlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->itemlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.FirstPayRewardItemProto)
}

int FirstPayRewardItemProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 itemType = 1;
    if (has_itemtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemtype());
    }

    // optional int32 itemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 itemCount = 3;
    if (has_itemcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemcount());
    }

    // optional int32 itemLevel = 4;
    if (has_itemlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemlevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstPayRewardItemProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FirstPayRewardItemProto*>(&from));
}

void FirstPayRewardItemProto::MergeFrom(const FirstPayRewardItemProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemtype()) {
      set_itemtype(from.itemtype());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_itemcount()) {
      set_itemcount(from.itemcount());
    }
    if (from.has_itemlevel()) {
      set_itemlevel(from.itemlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void FirstPayRewardItemProto::CopyFrom(const FirstPayRewardItemProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstPayRewardItemProto::IsInitialized() const {

  return true;
}

void FirstPayRewardItemProto::Swap(FirstPayRewardItemProto* other) {
  if (other != this) {
    std::swap(itemtype_, other->itemtype_);
    std::swap(itemid_, other->itemid_);
    std::swap(itemcount_, other->itemcount_);
    std::swap(itemlevel_, other->itemlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FirstPayRewardItemProto::GetTypeName() const {
  return "main.FirstPayRewardItemProto";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

SigninDetailRequest::SigninDetailRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.SigninDetailRequest)
}

void SigninDetailRequest::InitAsDefaultInstance() {
}

SigninDetailRequest::SigninDetailRequest(const SigninDetailRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.SigninDetailRequest)
}

void SigninDetailRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SigninDetailRequest::~SigninDetailRequest() {
  // @@protoc_insertion_point(destructor:main.SigninDetailRequest)
  SharedDtor();
}

void SigninDetailRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SigninDetailRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigninDetailRequest& SigninDetailRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

SigninDetailRequest* SigninDetailRequest::default_instance_ = NULL;

SigninDetailRequest* SigninDetailRequest::New() const {
  return new SigninDetailRequest;
}

void SigninDetailRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SigninDetailRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.SigninDetailRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.SigninDetailRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.SigninDetailRequest)
  return false;
#undef DO_
}

void SigninDetailRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.SigninDetailRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.SigninDetailRequest)
}

int SigninDetailRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigninDetailRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigninDetailRequest*>(&from));
}

void SigninDetailRequest::MergeFrom(const SigninDetailRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SigninDetailRequest::CopyFrom(const SigninDetailRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigninDetailRequest::IsInitialized() const {

  return true;
}

void SigninDetailRequest::Swap(SigninDetailRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SigninDetailRequest::GetTypeName() const {
  return "main.SigninDetailRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int SigninDetailResponse::kCellsFieldNumber;
const int SigninDetailResponse::kMonthFieldNumber;
const int SigninDetailResponse::kDayFieldNumber;
#endif  // !_MSC_VER

SigninDetailResponse::SigninDetailResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.SigninDetailResponse)
}

void SigninDetailResponse::InitAsDefaultInstance() {
}

SigninDetailResponse::SigninDetailResponse(const SigninDetailResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.SigninDetailResponse)
}

void SigninDetailResponse::SharedCtor() {
  _cached_size_ = 0;
  month_ = 0;
  day_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SigninDetailResponse::~SigninDetailResponse() {
  // @@protoc_insertion_point(destructor:main.SigninDetailResponse)
  SharedDtor();
}

void SigninDetailResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SigninDetailResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigninDetailResponse& SigninDetailResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

SigninDetailResponse* SigninDetailResponse::default_instance_ = NULL;

SigninDetailResponse* SigninDetailResponse::New() const {
  return new SigninDetailResponse;
}

void SigninDetailResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SigninDetailResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(month_, day_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  cells_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SigninDetailResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.SigninDetailResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .main.SigninCell cells = 1;
      case 1: {
        if (tag == 10) {
         parse_cells:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cells()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_cells;
        if (input->ExpectTag(16)) goto parse_month;
        break;
      }

      // required int32 month = 2;
      case 2: {
        if (tag == 16) {
         parse_month:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &month_)));
          set_has_month();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_day;
        break;
      }

      // required int32 day = 3;
      case 3: {
        if (tag == 24) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.SigninDetailResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.SigninDetailResponse)
  return false;
#undef DO_
}

void SigninDetailResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.SigninDetailResponse)
  // repeated .main.SigninCell cells = 1;
  for (int i = 0; i < this->cells_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->cells(i), output);
  }

  // required int32 month = 2;
  if (has_month()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->month(), output);
  }

  // required int32 day = 3;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->day(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.SigninDetailResponse)
}

int SigninDetailResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int32 month = 2;
    if (has_month()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->month());
    }

    // required int32 day = 3;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->day());
    }

  }
  // repeated .main.SigninCell cells = 1;
  total_size += 1 * this->cells_size();
  for (int i = 0; i < this->cells_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cells(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigninDetailResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigninDetailResponse*>(&from));
}

void SigninDetailResponse::MergeFrom(const SigninDetailResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  cells_.MergeFrom(from.cells_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_month()) {
      set_month(from.month());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SigninDetailResponse::CopyFrom(const SigninDetailResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigninDetailResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->cells())) return false;
  return true;
}

void SigninDetailResponse::Swap(SigninDetailResponse* other) {
  if (other != this) {
    cells_.Swap(&other->cells_);
    std::swap(month_, other->month_);
    std::swap(day_, other->day_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SigninDetailResponse::GetTypeName() const {
  return "main.SigninDetailResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int SigninCell::kItemDataFieldNumber;
const int SigninCell::kStateFieldNumber;
const int SigninCell::kShowStringFieldNumber;
const int SigninCell::kNiubilityFieldNumber;
const int SigninCell::kItemDescFieldNumber;
const int SigninCell::kVipDescFieldNumber;
#endif  // !_MSC_VER

SigninCell::SigninCell()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.SigninCell)
}

void SigninCell::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  itemdata_ = const_cast< ::main::ItemDataProto*>(
      ::main::ItemDataProto::internal_default_instance());
#else
  itemdata_ = const_cast< ::main::ItemDataProto*>(&::main::ItemDataProto::default_instance());
#endif
}

SigninCell::SigninCell(const SigninCell& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.SigninCell)
}

void SigninCell::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  itemdata_ = NULL;
  state_ = 0;
  showstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  niubility_ = 0;
  itemdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vipdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SigninCell::~SigninCell() {
  // @@protoc_insertion_point(destructor:main.SigninCell)
  SharedDtor();
}

void SigninCell::SharedDtor() {
  if (showstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete showstring_;
  }
  if (itemdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemdesc_;
  }
  if (vipdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vipdesc_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete itemdata_;
  }
}

void SigninCell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigninCell& SigninCell::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

SigninCell* SigninCell::default_instance_ = NULL;

SigninCell* SigninCell::New() const {
  return new SigninCell;
}

void SigninCell::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SigninCell*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(state_, niubility_);
    if (has_itemdata()) {
      if (itemdata_ != NULL) itemdata_->::main::ItemDataProto::Clear();
    }
    if (has_showstring()) {
      if (showstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        showstring_->clear();
      }
    }
    if (has_itemdesc()) {
      if (itemdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        itemdesc_->clear();
      }
    }
    if (has_vipdesc()) {
      if (vipdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vipdesc_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SigninCell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.SigninCell)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .main.ItemDataProto itemData = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required .main.SignState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::main::SignState_IsValid(value)) {
            set_state(static_cast< ::main::SignState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_showString;
        break;
      }

      // required string showString = 3;
      case 3: {
        if (tag == 26) {
         parse_showString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_showstring()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_niubility;
        break;
      }

      // required int32 niubility = 4;
      case 4: {
        if (tag == 32) {
         parse_niubility:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &niubility_)));
          set_has_niubility();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_itemDesc;
        break;
      }

      // required string itemDesc = 5;
      case 5: {
        if (tag == 42) {
         parse_itemDesc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_itemdesc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_vipDesc;
        break;
      }

      // required string vipDesc = 6;
      case 6: {
        if (tag == 50) {
         parse_vipDesc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vipdesc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.SigninCell)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.SigninCell)
  return false;
#undef DO_
}

void SigninCell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.SigninCell)
  // required .main.ItemDataProto itemData = 1;
  if (has_itemdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->itemdata(), output);
  }

  // required .main.SignState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // required string showString = 3;
  if (has_showstring()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->showstring(), output);
  }

  // required int32 niubility = 4;
  if (has_niubility()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->niubility(), output);
  }

  // required string itemDesc = 5;
  if (has_itemdesc()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->itemdesc(), output);
  }

  // required string vipDesc = 6;
  if (has_vipdesc()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->vipdesc(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.SigninCell)
}

int SigninCell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .main.ItemDataProto itemData = 1;
    if (has_itemdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemdata());
    }

    // required .main.SignState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required string showString = 3;
    if (has_showstring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->showstring());
    }

    // required int32 niubility = 4;
    if (has_niubility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->niubility());
    }

    // required string itemDesc = 5;
    if (has_itemdesc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->itemdesc());
    }

    // required string vipDesc = 6;
    if (has_vipdesc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vipdesc());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigninCell::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigninCell*>(&from));
}

void SigninCell::MergeFrom(const SigninCell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemdata()) {
      mutable_itemdata()->::main::ItemDataProto::MergeFrom(from.itemdata());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_showstring()) {
      set_showstring(from.showstring());
    }
    if (from.has_niubility()) {
      set_niubility(from.niubility());
    }
    if (from.has_itemdesc()) {
      set_itemdesc(from.itemdesc());
    }
    if (from.has_vipdesc()) {
      set_vipdesc(from.vipdesc());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SigninCell::CopyFrom(const SigninCell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigninCell::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_itemdata()) {
    if (!this->itemdata().IsInitialized()) return false;
  }
  return true;
}

void SigninCell::Swap(SigninCell* other) {
  if (other != this) {
    std::swap(itemdata_, other->itemdata_);
    std::swap(state_, other->state_);
    std::swap(showstring_, other->showstring_);
    std::swap(niubility_, other->niubility_);
    std::swap(itemdesc_, other->itemdesc_);
    std::swap(vipdesc_, other->vipdesc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SigninCell::GetTypeName() const {
  return "main.SigninCell";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

SigninRewardRequest::SigninRewardRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.SigninRewardRequest)
}

void SigninRewardRequest::InitAsDefaultInstance() {
}

SigninRewardRequest::SigninRewardRequest(const SigninRewardRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.SigninRewardRequest)
}

void SigninRewardRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SigninRewardRequest::~SigninRewardRequest() {
  // @@protoc_insertion_point(destructor:main.SigninRewardRequest)
  SharedDtor();
}

void SigninRewardRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SigninRewardRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigninRewardRequest& SigninRewardRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

SigninRewardRequest* SigninRewardRequest::default_instance_ = NULL;

SigninRewardRequest* SigninRewardRequest::New() const {
  return new SigninRewardRequest;
}

void SigninRewardRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SigninRewardRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.SigninRewardRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:main.SigninRewardRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.SigninRewardRequest)
  return false;
#undef DO_
}

void SigninRewardRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.SigninRewardRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.SigninRewardRequest)
}

int SigninRewardRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigninRewardRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigninRewardRequest*>(&from));
}

void SigninRewardRequest::MergeFrom(const SigninRewardRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SigninRewardRequest::CopyFrom(const SigninRewardRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigninRewardRequest::IsInitialized() const {

  return true;
}

void SigninRewardRequest::Swap(SigninRewardRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SigninRewardRequest::GetTypeName() const {
  return "main.SigninRewardRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int SigninRewardResponse::kRewardStateFieldNumber;
const int SigninRewardResponse::kItemDataFieldNumber;
const int SigninRewardResponse::kDayFieldNumber;
const int SigninRewardResponse::kCellStateFieldNumber;
const int SigninRewardResponse::kNiubilityFieldNumber;
#endif  // !_MSC_VER

SigninRewardResponse::SigninRewardResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.SigninRewardResponse)
}

void SigninRewardResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  itemdata_ = const_cast< ::main::ItemDataProto*>(
      ::main::ItemDataProto::internal_default_instance());
#else
  itemdata_ = const_cast< ::main::ItemDataProto*>(&::main::ItemDataProto::default_instance());
#endif
}

SigninRewardResponse::SigninRewardResponse(const SigninRewardResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.SigninRewardResponse)
}

void SigninRewardResponse::SharedCtor() {
  _cached_size_ = 0;
  rewardstate_ = 0;
  itemdata_ = NULL;
  day_ = 0;
  cellstate_ = 0;
  niubility_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SigninRewardResponse::~SigninRewardResponse() {
  // @@protoc_insertion_point(destructor:main.SigninRewardResponse)
  SharedDtor();
}

void SigninRewardResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete itemdata_;
  }
}

void SigninRewardResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigninRewardResponse& SigninRewardResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_RewardModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_RewardModule_2eproto();
#endif
  return *default_instance_;
}

SigninRewardResponse* SigninRewardResponse::default_instance_ = NULL;

SigninRewardResponse* SigninRewardResponse::New() const {
  return new SigninRewardResponse;
}

void SigninRewardResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SigninRewardResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(rewardstate_, niubility_);
    if (has_itemdata()) {
      if (itemdata_ != NULL) itemdata_->::main::ItemDataProto::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SigninRewardResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.SigninRewardResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 rewardState = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rewardstate_)));
          set_has_rewardstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_itemData;
        break;
      }

      // required .main.ItemDataProto itemData = 2;
      case 2: {
        if (tag == 18) {
         parse_itemData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_day;
        break;
      }

      // required int32 day = 3;
      case 3: {
        if (tag == 24) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cellState;
        break;
      }

      // required .main.SignState cellState = 4;
      case 4: {
        if (tag == 32) {
         parse_cellState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::main::SignState_IsValid(value)) {
            set_cellstate(static_cast< ::main::SignState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_niubility;
        break;
      }

      // required int32 niubility = 5;
      case 5: {
        if (tag == 40) {
         parse_niubility:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &niubility_)));
          set_has_niubility();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.SigninRewardResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.SigninRewardResponse)
  return false;
#undef DO_
}

void SigninRewardResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.SigninRewardResponse)
  // required int32 rewardState = 1;
  if (has_rewardstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->rewardstate(), output);
  }

  // required .main.ItemDataProto itemData = 2;
  if (has_itemdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->itemdata(), output);
  }

  // required int32 day = 3;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->day(), output);
  }

  // required .main.SignState cellState = 4;
  if (has_cellstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->cellstate(), output);
  }

  // required int32 niubility = 5;
  if (has_niubility()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->niubility(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.SigninRewardResponse)
}

int SigninRewardResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 rewardState = 1;
    if (has_rewardstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rewardstate());
    }

    // required .main.ItemDataProto itemData = 2;
    if (has_itemdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemdata());
    }

    // required int32 day = 3;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->day());
    }

    // required .main.SignState cellState = 4;
    if (has_cellstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cellstate());
    }

    // required int32 niubility = 5;
    if (has_niubility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->niubility());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigninRewardResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigninRewardResponse*>(&from));
}

void SigninRewardResponse::MergeFrom(const SigninRewardResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rewardstate()) {
      set_rewardstate(from.rewardstate());
    }
    if (from.has_itemdata()) {
      mutable_itemdata()->::main::ItemDataProto::MergeFrom(from.itemdata());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
    if (from.has_cellstate()) {
      set_cellstate(from.cellstate());
    }
    if (from.has_niubility()) {
      set_niubility(from.niubility());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SigninRewardResponse::CopyFrom(const SigninRewardResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigninRewardResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_itemdata()) {
    if (!this->itemdata().IsInitialized()) return false;
  }
  return true;
}

void SigninRewardResponse::Swap(SigninRewardResponse* other) {
  if (other != this) {
    std::swap(rewardstate_, other->rewardstate_);
    std::swap(itemdata_, other->itemdata_);
    std::swap(day_, other->day_);
    std::swap(cellstate_, other->cellstate_);
    std::swap(niubility_, other->niubility_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SigninRewardResponse::GetTypeName() const {
  return "main.SigninRewardResponse";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

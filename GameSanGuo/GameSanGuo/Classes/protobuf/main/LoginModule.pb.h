// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LoginModule.proto

#ifndef PROTOBUF_LoginModule_2eproto__INCLUDED
#define PROTOBUF_LoginModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "RoleModule.pb.h"
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LoginModule_2eproto();
void protobuf_AssignDesc_LoginModule_2eproto();
void protobuf_ShutdownFile_LoginModule_2eproto();

class LoginRequest;
class LoginResponse;
class PvPLoginRequest;
class HeartBeatRequest;
class HeartBeatResponse;
class CDKEYRequest;
class CDKEYResponse;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string loginKey = 1;
  inline bool has_loginkey() const;
  inline void clear_loginkey();
  static const int kLoginKeyFieldNumber = 1;
  inline const ::std::string& loginkey() const;
  inline void set_loginkey(const ::std::string& value);
  inline void set_loginkey(const char* value);
  inline void set_loginkey(const char* value, size_t size);
  inline ::std::string* mutable_loginkey();
  inline ::std::string* release_loginkey();
  inline void set_allocated_loginkey(::std::string* loginkey);

  // required string userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required int32 serverId = 3;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // required int32 channelId = 4;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 4;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // required int32 subChannelId = 5;
  inline bool has_subchannelid() const;
  inline void clear_subchannelid();
  static const int kSubChannelIdFieldNumber = 5;
  inline ::google::protobuf::int32 subchannelid() const;
  inline void set_subchannelid(::google::protobuf::int32 value);

  // required string nickName = 6;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string token = 7;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 7;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:main.LoginRequest)
 private:
  inline void set_has_loginkey();
  inline void clear_has_loginkey();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_subchannelid();
  inline void clear_has_subchannelid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* loginkey_;
  ::std::string* userid_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 channelid_;
  ::std::string* nickname_;
  ::std::string* token_;
  ::google::protobuf::int32 subchannelid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1 [default = 0];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // optional int32 hasRole = 3 [default = 0];
  inline bool has_hasrole() const;
  inline void clear_hasrole();
  static const int kHasRoleFieldNumber = 3;
  inline ::google::protobuf::int32 hasrole() const;
  inline void set_hasrole(::google::protobuf::int32 value);

  // optional int32 CDKEY = 4 [default = 0];
  inline bool has_cdkey() const;
  inline void clear_cdkey();
  static const int kCDKEYFieldNumber = 4;
  inline ::google::protobuf::int32 cdkey() const;
  inline void set_cdkey(::google::protobuf::int32 value);

  // optional .main.RoleResponse roleResponse = 5;
  inline bool has_roleresponse() const;
  inline void clear_roleresponse();
  static const int kRoleResponseFieldNumber = 5;
  inline const ::main::RoleResponse& roleresponse() const;
  inline ::main::RoleResponse* mutable_roleresponse();
  inline ::main::RoleResponse* release_roleresponse();
  inline void set_allocated_roleresponse(::main::RoleResponse* roleresponse);

  // @@protoc_insertion_point(class_scope:main.LoginResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_hasrole();
  inline void clear_has_hasrole();
  inline void set_has_cdkey();
  inline void clear_has_cdkey();
  inline void set_has_roleresponse();
  inline void clear_has_roleresponse();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 hasrole_;
  ::main::RoleResponse* roleresponse_;
  ::google::protobuf::int32 cdkey_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class PvPLoginRequest : public ::google::protobuf::MessageLite {
 public:
  PvPLoginRequest();
  virtual ~PvPLoginRequest();

  PvPLoginRequest(const PvPLoginRequest& from);

  inline PvPLoginRequest& operator=(const PvPLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PvPLoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvPLoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvPLoginRequest* other);

  // implements Message ----------------------------------------------

  PvPLoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvPLoginRequest& from);
  void MergeFrom(const PvPLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string accountId = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // required int32 serverId = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // optional string fightId = 3;
  inline bool has_fightid() const;
  inline void clear_fightid();
  static const int kFightIdFieldNumber = 3;
  inline const ::std::string& fightid() const;
  inline void set_fightid(const ::std::string& value);
  inline void set_fightid(const char* value);
  inline void set_fightid(const char* value, size_t size);
  inline ::std::string* mutable_fightid();
  inline ::std::string* release_fightid();
  inline void set_allocated_fightid(::std::string* fightid);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 channelId = 5;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 5;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // optional int32 roleId = 6;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 6;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.PvPLoginRequest)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_fightid();
  inline void clear_has_fightid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* accountid_;
  ::std::string* fightid_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 channelid_;
  ::google::protobuf::int32 roleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static PvPLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatRequest : public ::google::protobuf::MessageLite {
 public:
  HeartBeatRequest();
  virtual ~HeartBeatRequest();

  HeartBeatRequest(const HeartBeatRequest& from);

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HeartBeatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartBeatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartBeatRequest* other);

  // implements Message ----------------------------------------------

  HeartBeatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartBeatRequest& from);
  void MergeFrom(const HeartBeatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.HeartBeatRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatResponse : public ::google::protobuf::MessageLite {
 public:
  HeartBeatResponse();
  virtual ~HeartBeatResponse();

  HeartBeatResponse(const HeartBeatResponse& from);

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HeartBeatResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartBeatResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartBeatResponse* other);

  // implements Message ----------------------------------------------

  HeartBeatResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartBeatResponse& from);
  void MergeFrom(const HeartBeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1 [default = 0];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.HeartBeatResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class CDKEYRequest : public ::google::protobuf::MessageLite {
 public:
  CDKEYRequest();
  virtual ~CDKEYRequest();

  CDKEYRequest(const CDKEYRequest& from);

  inline CDKEYRequest& operator=(const CDKEYRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CDKEYRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CDKEYRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CDKEYRequest* other);

  // implements Message ----------------------------------------------

  CDKEYRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CDKEYRequest& from);
  void MergeFrom(const CDKEYRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string CDKEY = 1;
  inline bool has_cdkey() const;
  inline void clear_cdkey();
  static const int kCDKEYFieldNumber = 1;
  inline const ::std::string& cdkey() const;
  inline void set_cdkey(const ::std::string& value);
  inline void set_cdkey(const char* value);
  inline void set_cdkey(const char* value, size_t size);
  inline ::std::string* mutable_cdkey();
  inline ::std::string* release_cdkey();
  inline void set_allocated_cdkey(::std::string* cdkey);

  // @@protoc_insertion_point(class_scope:main.CDKEYRequest)
 private:
  inline void set_has_cdkey();
  inline void clear_has_cdkey();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cdkey_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static CDKEYRequest* default_instance_;
};
// -------------------------------------------------------------------

class CDKEYResponse : public ::google::protobuf::MessageLite {
 public:
  CDKEYResponse();
  virtual ~CDKEYResponse();

  CDKEYResponse(const CDKEYResponse& from);

  inline CDKEYResponse& operator=(const CDKEYResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CDKEYResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CDKEYResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CDKEYResponse* other);

  // implements Message ----------------------------------------------

  CDKEYResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CDKEYResponse& from);
  void MergeFrom(const CDKEYResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.CDKEYResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginModule_2eproto();
  friend void protobuf_ShutdownFile_LoginModule_2eproto();

  void InitAsDefaultInstance();
  static CDKEYResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string loginKey = 1;
inline bool LoginRequest::has_loginkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_loginkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_loginkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_loginkey() {
  if (loginkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginkey_->clear();
  }
  clear_has_loginkey();
}
inline const ::std::string& LoginRequest::loginkey() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.loginKey)
  return *loginkey_;
}
inline void LoginRequest::set_loginkey(const ::std::string& value) {
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(value);
  // @@protoc_insertion_point(field_set:main.LoginRequest.loginKey)
}
inline void LoginRequest::set_loginkey(const char* value) {
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.LoginRequest.loginKey)
}
inline void LoginRequest::set_loginkey(const char* value, size_t size) {
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.LoginRequest.loginKey)
}
inline ::std::string* LoginRequest::mutable_loginkey() {
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.LoginRequest.loginKey)
  return loginkey_;
}
inline ::std::string* LoginRequest::release_loginkey() {
  clear_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loginkey_;
    loginkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_loginkey(::std::string* loginkey) {
  if (loginkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loginkey_;
  }
  if (loginkey) {
    set_has_loginkey();
    loginkey_ = loginkey;
  } else {
    clear_has_loginkey();
    loginkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginRequest.loginKey)
}

// required string userId = 2;
inline bool LoginRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LoginRequest::userid() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.userId)
  return *userid_;
}
inline void LoginRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:main.LoginRequest.userId)
}
inline void LoginRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.LoginRequest.userId)
}
inline void LoginRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.LoginRequest.userId)
}
inline ::std::string* LoginRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.LoginRequest.userId)
  return userid_;
}
inline ::std::string* LoginRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginRequest.userId)
}

// required int32 serverId = 3;
inline bool LoginRequest::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 LoginRequest::serverid() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.serverId)
  return serverid_;
}
inline void LoginRequest::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:main.LoginRequest.serverId)
}

// required int32 channelId = 4;
inline bool LoginRequest::has_channelid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_channelid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 LoginRequest::channelid() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.channelId)
  return channelid_;
}
inline void LoginRequest::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
  // @@protoc_insertion_point(field_set:main.LoginRequest.channelId)
}

// required int32 subChannelId = 5;
inline bool LoginRequest::has_subchannelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_subchannelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_subchannelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_subchannelid() {
  subchannelid_ = 0;
  clear_has_subchannelid();
}
inline ::google::protobuf::int32 LoginRequest::subchannelid() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.subChannelId)
  return subchannelid_;
}
inline void LoginRequest::set_subchannelid(::google::protobuf::int32 value) {
  set_has_subchannelid();
  subchannelid_ = value;
  // @@protoc_insertion_point(field_set:main.LoginRequest.subChannelId)
}

// required string nickName = 6;
inline bool LoginRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequest::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& LoginRequest::nickname() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.nickName)
  return *nickname_;
}
inline void LoginRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:main.LoginRequest.nickName)
}
inline void LoginRequest::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.LoginRequest.nickName)
}
inline void LoginRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.LoginRequest.nickName)
}
inline ::std::string* LoginRequest::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.LoginRequest.nickName)
  return nickname_;
}
inline ::std::string* LoginRequest::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginRequest.nickName)
}

// optional string token = 7;
inline bool LoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginRequest::token() const {
  // @@protoc_insertion_point(field_get:main.LoginRequest.token)
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:main.LoginRequest.token)
}
inline void LoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.LoginRequest.token)
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.LoginRequest.token)
}
inline ::std::string* LoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.LoginRequest.token)
  return token_;
}
inline ::std::string* LoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginRequest.token)
}

// -------------------------------------------------------------------

// LoginResponse

// optional int32 state = 1 [default = 0];
inline bool LoginResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 LoginResponse::state() const {
  // @@protoc_insertion_point(field_get:main.LoginResponse.state)
  return state_;
}
inline void LoginResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.LoginResponse.state)
}

// optional string failMsg = 2;
inline bool LoginResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& LoginResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.LoginResponse.failMsg)
  return *failmsg_;
}
inline void LoginResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.LoginResponse.failMsg)
}
inline void LoginResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.LoginResponse.failMsg)
}
inline void LoginResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.LoginResponse.failMsg)
}
inline ::std::string* LoginResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.LoginResponse.failMsg)
  return failmsg_;
}
inline ::std::string* LoginResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginResponse.failMsg)
}

// optional int32 hasRole = 3 [default = 0];
inline bool LoginResponse::has_hasrole() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_hasrole() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_hasrole() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_hasrole() {
  hasrole_ = 0;
  clear_has_hasrole();
}
inline ::google::protobuf::int32 LoginResponse::hasrole() const {
  // @@protoc_insertion_point(field_get:main.LoginResponse.hasRole)
  return hasrole_;
}
inline void LoginResponse::set_hasrole(::google::protobuf::int32 value) {
  set_has_hasrole();
  hasrole_ = value;
  // @@protoc_insertion_point(field_set:main.LoginResponse.hasRole)
}

// optional int32 CDKEY = 4 [default = 0];
inline bool LoginResponse::has_cdkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_cdkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_cdkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_cdkey() {
  cdkey_ = 0;
  clear_has_cdkey();
}
inline ::google::protobuf::int32 LoginResponse::cdkey() const {
  // @@protoc_insertion_point(field_get:main.LoginResponse.CDKEY)
  return cdkey_;
}
inline void LoginResponse::set_cdkey(::google::protobuf::int32 value) {
  set_has_cdkey();
  cdkey_ = value;
  // @@protoc_insertion_point(field_set:main.LoginResponse.CDKEY)
}

// optional .main.RoleResponse roleResponse = 5;
inline bool LoginResponse::has_roleresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_roleresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_roleresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_roleresponse() {
  if (roleresponse_ != NULL) roleresponse_->::main::RoleResponse::Clear();
  clear_has_roleresponse();
}
inline const ::main::RoleResponse& LoginResponse::roleresponse() const {
  // @@protoc_insertion_point(field_get:main.LoginResponse.roleResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return roleresponse_ != NULL ? *roleresponse_ : *default_instance().roleresponse_;
#else
  return roleresponse_ != NULL ? *roleresponse_ : *default_instance_->roleresponse_;
#endif
}
inline ::main::RoleResponse* LoginResponse::mutable_roleresponse() {
  set_has_roleresponse();
  if (roleresponse_ == NULL) roleresponse_ = new ::main::RoleResponse;
  // @@protoc_insertion_point(field_mutable:main.LoginResponse.roleResponse)
  return roleresponse_;
}
inline ::main::RoleResponse* LoginResponse::release_roleresponse() {
  clear_has_roleresponse();
  ::main::RoleResponse* temp = roleresponse_;
  roleresponse_ = NULL;
  return temp;
}
inline void LoginResponse::set_allocated_roleresponse(::main::RoleResponse* roleresponse) {
  delete roleresponse_;
  roleresponse_ = roleresponse;
  if (roleresponse) {
    set_has_roleresponse();
  } else {
    clear_has_roleresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:main.LoginResponse.roleResponse)
}

// -------------------------------------------------------------------

// PvPLoginRequest

// required string accountId = 1;
inline bool PvPLoginRequest::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvPLoginRequest::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvPLoginRequest::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvPLoginRequest::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& PvPLoginRequest::accountid() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.accountId)
  return *accountid_;
}
inline void PvPLoginRequest::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.accountId)
}
inline void PvPLoginRequest::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PvPLoginRequest.accountId)
}
inline void PvPLoginRequest::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PvPLoginRequest.accountId)
}
inline ::std::string* PvPLoginRequest::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PvPLoginRequest.accountId)
  return accountid_;
}
inline ::std::string* PvPLoginRequest::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PvPLoginRequest::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PvPLoginRequest.accountId)
}

// required int32 serverId = 2;
inline bool PvPLoginRequest::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvPLoginRequest::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvPLoginRequest::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvPLoginRequest::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 PvPLoginRequest::serverid() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.serverId)
  return serverid_;
}
inline void PvPLoginRequest::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.serverId)
}

// optional string fightId = 3;
inline bool PvPLoginRequest::has_fightid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvPLoginRequest::set_has_fightid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvPLoginRequest::clear_has_fightid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvPLoginRequest::clear_fightid() {
  if (fightid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_->clear();
  }
  clear_has_fightid();
}
inline const ::std::string& PvPLoginRequest::fightid() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.fightId)
  return *fightid_;
}
inline void PvPLoginRequest::set_fightid(const ::std::string& value) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(value);
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.fightId)
}
inline void PvPLoginRequest::set_fightid(const char* value) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PvPLoginRequest.fightId)
}
inline void PvPLoginRequest::set_fightid(const char* value, size_t size) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PvPLoginRequest.fightId)
}
inline ::std::string* PvPLoginRequest::mutable_fightid() {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PvPLoginRequest.fightId)
  return fightid_;
}
inline ::std::string* PvPLoginRequest::release_fightid() {
  clear_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fightid_;
    fightid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PvPLoginRequest::set_allocated_fightid(::std::string* fightid) {
  if (fightid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fightid_;
  }
  if (fightid) {
    set_has_fightid();
    fightid_ = fightid;
  } else {
    clear_has_fightid();
    fightid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PvPLoginRequest.fightId)
}

// optional int32 type = 4;
inline bool PvPLoginRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvPLoginRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvPLoginRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvPLoginRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PvPLoginRequest::type() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.type)
  return type_;
}
inline void PvPLoginRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.type)
}

// optional int32 channelId = 5;
inline bool PvPLoginRequest::has_channelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvPLoginRequest::set_has_channelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvPLoginRequest::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvPLoginRequest::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 PvPLoginRequest::channelid() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.channelId)
  return channelid_;
}
inline void PvPLoginRequest::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.channelId)
}

// optional int32 roleId = 6;
inline bool PvPLoginRequest::has_roleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvPLoginRequest::set_has_roleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvPLoginRequest::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvPLoginRequest::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 PvPLoginRequest::roleid() const {
  // @@protoc_insertion_point(field_get:main.PvPLoginRequest.roleId)
  return roleid_;
}
inline void PvPLoginRequest::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.PvPLoginRequest.roleId)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// -------------------------------------------------------------------

// HeartBeatResponse

// optional int32 state = 1 [default = 0];
inline bool HeartBeatResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeatResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeatResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeatResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 HeartBeatResponse::state() const {
  // @@protoc_insertion_point(field_get:main.HeartBeatResponse.state)
  return state_;
}
inline void HeartBeatResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.HeartBeatResponse.state)
}

// -------------------------------------------------------------------

// CDKEYRequest

// optional string CDKEY = 1;
inline bool CDKEYRequest::has_cdkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDKEYRequest::set_has_cdkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDKEYRequest::clear_has_cdkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDKEYRequest::clear_cdkey() {
  if (cdkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdkey_->clear();
  }
  clear_has_cdkey();
}
inline const ::std::string& CDKEYRequest::cdkey() const {
  // @@protoc_insertion_point(field_get:main.CDKEYRequest.CDKEY)
  return *cdkey_;
}
inline void CDKEYRequest::set_cdkey(const ::std::string& value) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(value);
  // @@protoc_insertion_point(field_set:main.CDKEYRequest.CDKEY)
}
inline void CDKEYRequest::set_cdkey(const char* value) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.CDKEYRequest.CDKEY)
}
inline void CDKEYRequest::set_cdkey(const char* value, size_t size) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.CDKEYRequest.CDKEY)
}
inline ::std::string* CDKEYRequest::mutable_cdkey() {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.CDKEYRequest.CDKEY)
  return cdkey_;
}
inline ::std::string* CDKEYRequest::release_cdkey() {
  clear_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cdkey_;
    cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CDKEYRequest::set_allocated_cdkey(::std::string* cdkey) {
  if (cdkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cdkey_;
  }
  if (cdkey) {
    set_has_cdkey();
    cdkey_ = cdkey;
  } else {
    clear_has_cdkey();
    cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.CDKEYRequest.CDKEY)
}

// -------------------------------------------------------------------

// CDKEYResponse

// optional int32 state = 1;
inline bool CDKEYResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDKEYResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDKEYResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDKEYResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 CDKEYResponse::state() const {
  // @@protoc_insertion_point(field_get:main.CDKEYResponse.state)
  return state_;
}
inline void CDKEYResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.CDKEYResponse.state)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LoginModule_2eproto__INCLUDED

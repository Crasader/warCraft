// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RewardModule.proto

#ifndef PROTOBUF_RewardModule_2eproto__INCLUDED
#define PROTOBUF_RewardModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ItemModule.pb.h"
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RewardModule_2eproto();
void protobuf_AssignDesc_RewardModule_2eproto();
void protobuf_ShutdownFile_RewardModule_2eproto();

class RewardLevelUpEntryRequest;
class RewardLevelUpEntryResponse;
class RewardLevelUpPurchRequest;
class RewardLevelUpPurchResponse;
class RewardSalaryEntryRequest;
class RewardSalaryEntryResponse;
class RewardGetSalaryRequest;
class RewardGetSalaryResponse;
class RewardRecoverPowerEntryRequest;
class RewardRecoverPowerEntryResponse;
class RewardRecoverPowerPurchRequest;
class RewardRecoverPowerPurchResponse;
class RewardGodPrayEntryRequest;
class RewardGodPrayEntryResponse;
class GodRewardInfo;
class RewardGodPrayAddRequest;
class RewardGodPrayAddResponse;
class RewardRegLotteryEntryRequest;
class RewardRegLotteryEntryResponse;
class RewardRegLotteryGetRequest;
class RewardRegLotteryGetResponse;
class RewardNoticeMessage;
class RewardTypeState;
class RewardLianDanTimeRequest;
class RewardLianDanTimeResponse;
class RewardLianDanRequest;
class RewardLianDanResponse;
class RewardRegLotteryPush;
class RewardBindAccountRequest;
class RewardBindAccountResponse;
class RewardItemListProto;
class RewardBindAccountInfoRequest;
class RewardBindAccountInfoResponse;
class BindMailRequest;
class BindMailResponse;
class RewardBindMailRequest;
class RewardBindMailResponse;
class ExchangeCodeEntryRequest;
class ExchangeCodeEntryResponse;
class ExchangeCodeInfoRequest;
class ExchangeCodeInfoResponse;
class RewardInfoProto;
class FirstPayRewardResponse;
class FirstPayRewardItemProto;
class SigninDetailRequest;
class SigninDetailResponse;
class SigninCell;
class SigninRewardRequest;
class SigninRewardResponse;

enum SignState {
  NORMAL_HAS = 0,
  NORMAL_NO = 1,
  NORMAL_CAN = 2,
  VIP_HALF = 3
};
bool SignState_IsValid(int value);
const SignState SignState_MIN = NORMAL_HAS;
const SignState SignState_MAX = VIP_HALF;
const int SignState_ARRAYSIZE = SignState_MAX + 1;

// ===================================================================

class RewardLevelUpEntryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardLevelUpEntryRequest();
  virtual ~RewardLevelUpEntryRequest();

  RewardLevelUpEntryRequest(const RewardLevelUpEntryRequest& from);

  inline RewardLevelUpEntryRequest& operator=(const RewardLevelUpEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLevelUpEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLevelUpEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLevelUpEntryRequest* other);

  // implements Message ----------------------------------------------

  RewardLevelUpEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLevelUpEntryRequest& from);
  void MergeFrom(const RewardLevelUpEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardLevelUpEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLevelUpEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardLevelUpEntryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardLevelUpEntryResponse();
  virtual ~RewardLevelUpEntryResponse();

  RewardLevelUpEntryResponse(const RewardLevelUpEntryResponse& from);

  inline RewardLevelUpEntryResponse& operator=(const RewardLevelUpEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLevelUpEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLevelUpEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLevelUpEntryResponse* other);

  // implements Message ----------------------------------------------

  RewardLevelUpEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLevelUpEntryResponse& from);
  void MergeFrom(const RewardLevelUpEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline ::google::protobuf::int32 records(int index) const;
  inline void set_records(int index, ::google::protobuf::int32 value);
  inline void add_records(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      records() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:main.RewardLevelUpEntryResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > records_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLevelUpEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardLevelUpPurchRequest : public ::google::protobuf::MessageLite {
 public:
  RewardLevelUpPurchRequest();
  virtual ~RewardLevelUpPurchRequest();

  RewardLevelUpPurchRequest(const RewardLevelUpPurchRequest& from);

  inline RewardLevelUpPurchRequest& operator=(const RewardLevelUpPurchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLevelUpPurchRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLevelUpPurchRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLevelUpPurchRequest* other);

  // implements Message ----------------------------------------------

  RewardLevelUpPurchRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLevelUpPurchRequest& from);
  void MergeFrom(const RewardLevelUpPurchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLevelUpPurchRequest)
 private:
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLevelUpPurchRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardLevelUpPurchResponse : public ::google::protobuf::MessageLite {
 public:
  RewardLevelUpPurchResponse();
  virtual ~RewardLevelUpPurchResponse();

  RewardLevelUpPurchResponse(const RewardLevelUpPurchResponse& from);

  inline RewardLevelUpPurchResponse& operator=(const RewardLevelUpPurchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLevelUpPurchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLevelUpPurchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLevelUpPurchResponse* other);

  // implements Message ----------------------------------------------

  RewardLevelUpPurchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLevelUpPurchResponse& from);
  void MergeFrom(const RewardLevelUpPurchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLevelUpPurchResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLevelUpPurchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardSalaryEntryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardSalaryEntryRequest();
  virtual ~RewardSalaryEntryRequest();

  RewardSalaryEntryRequest(const RewardSalaryEntryRequest& from);

  inline RewardSalaryEntryRequest& operator=(const RewardSalaryEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardSalaryEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardSalaryEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardSalaryEntryRequest* other);

  // implements Message ----------------------------------------------

  RewardSalaryEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardSalaryEntryRequest& from);
  void MergeFrom(const RewardSalaryEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardSalaryEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardSalaryEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardSalaryEntryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardSalaryEntryResponse();
  virtual ~RewardSalaryEntryResponse();

  RewardSalaryEntryResponse(const RewardSalaryEntryResponse& from);

  inline RewardSalaryEntryResponse& operator=(const RewardSalaryEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardSalaryEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardSalaryEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardSalaryEntryResponse* other);

  // implements Message ----------------------------------------------

  RewardSalaryEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardSalaryEntryResponse& from);
  void MergeFrom(const RewardSalaryEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 levelCoin = 1;
  inline bool has_levelcoin() const;
  inline void clear_levelcoin();
  static const int kLevelCoinFieldNumber = 1;
  inline ::google::protobuf::int32 levelcoin() const;
  inline void set_levelcoin(::google::protobuf::int32 value);

  // optional int32 levelRewardTime = 2;
  inline bool has_levelrewardtime() const;
  inline void clear_levelrewardtime();
  static const int kLevelRewardTimeFieldNumber = 2;
  inline ::google::protobuf::int32 levelrewardtime() const;
  inline void set_levelrewardtime(::google::protobuf::int32 value);

  // optional int32 pvpLevel = 3;
  inline bool has_pvplevel() const;
  inline void clear_pvplevel();
  static const int kPvpLevelFieldNumber = 3;
  inline ::google::protobuf::int32 pvplevel() const;
  inline void set_pvplevel(::google::protobuf::int32 value);

  // optional int32 pvpLevelCoin = 4;
  inline bool has_pvplevelcoin() const;
  inline void clear_pvplevelcoin();
  static const int kPvpLevelCoinFieldNumber = 4;
  inline ::google::protobuf::int32 pvplevelcoin() const;
  inline void set_pvplevelcoin(::google::protobuf::int32 value);

  // optional int32 pvpRewardTime = 5;
  inline bool has_pvprewardtime() const;
  inline void clear_pvprewardtime();
  static const int kPvpRewardTimeFieldNumber = 5;
  inline ::google::protobuf::int32 pvprewardtime() const;
  inline void set_pvprewardtime(::google::protobuf::int32 value);

  // optional int32 pveMinLevel = 6;
  inline bool has_pveminlevel() const;
  inline void clear_pveminlevel();
  static const int kPveMinLevelFieldNumber = 6;
  inline ::google::protobuf::int32 pveminlevel() const;
  inline void set_pveminlevel(::google::protobuf::int32 value);

  // optional int32 pvpMinLevel = 7;
  inline bool has_pvpminlevel() const;
  inline void clear_pvpminlevel();
  static const int kPvpMinLevelFieldNumber = 7;
  inline ::google::protobuf::int32 pvpminlevel() const;
  inline void set_pvpminlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardSalaryEntryResponse)
 private:
  inline void set_has_levelcoin();
  inline void clear_has_levelcoin();
  inline void set_has_levelrewardtime();
  inline void clear_has_levelrewardtime();
  inline void set_has_pvplevel();
  inline void clear_has_pvplevel();
  inline void set_has_pvplevelcoin();
  inline void clear_has_pvplevelcoin();
  inline void set_has_pvprewardtime();
  inline void clear_has_pvprewardtime();
  inline void set_has_pveminlevel();
  inline void clear_has_pveminlevel();
  inline void set_has_pvpminlevel();
  inline void clear_has_pvpminlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 levelcoin_;
  ::google::protobuf::int32 levelrewardtime_;
  ::google::protobuf::int32 pvplevel_;
  ::google::protobuf::int32 pvplevelcoin_;
  ::google::protobuf::int32 pvprewardtime_;
  ::google::protobuf::int32 pveminlevel_;
  ::google::protobuf::int32 pvpminlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardSalaryEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardGetSalaryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardGetSalaryRequest();
  virtual ~RewardGetSalaryRequest();

  RewardGetSalaryRequest(const RewardGetSalaryRequest& from);

  inline RewardGetSalaryRequest& operator=(const RewardGetSalaryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGetSalaryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGetSalaryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGetSalaryRequest* other);

  // implements Message ----------------------------------------------

  RewardGetSalaryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGetSalaryRequest& from);
  void MergeFrom(const RewardGetSalaryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardGetSalaryRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGetSalaryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardGetSalaryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardGetSalaryResponse();
  virtual ~RewardGetSalaryResponse();

  RewardGetSalaryResponse(const RewardGetSalaryResponse& from);

  inline RewardGetSalaryResponse& operator=(const RewardGetSalaryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGetSalaryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGetSalaryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGetSalaryResponse* other);

  // implements Message ----------------------------------------------

  RewardGetSalaryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGetSalaryResponse& from);
  void MergeFrom(const RewardGetSalaryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardGetSalaryResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGetSalaryResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardRecoverPowerEntryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardRecoverPowerEntryRequest();
  virtual ~RewardRecoverPowerEntryRequest();

  RewardRecoverPowerEntryRequest(const RewardRecoverPowerEntryRequest& from);

  inline RewardRecoverPowerEntryRequest& operator=(const RewardRecoverPowerEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRecoverPowerEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRecoverPowerEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRecoverPowerEntryRequest* other);

  // implements Message ----------------------------------------------

  RewardRecoverPowerEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRecoverPowerEntryRequest& from);
  void MergeFrom(const RewardRecoverPowerEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardRecoverPowerEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRecoverPowerEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardRecoverPowerEntryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardRecoverPowerEntryResponse();
  virtual ~RewardRecoverPowerEntryResponse();

  RewardRecoverPowerEntryResponse(const RewardRecoverPowerEntryResponse& from);

  inline RewardRecoverPowerEntryResponse& operator=(const RewardRecoverPowerEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRecoverPowerEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRecoverPowerEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRecoverPowerEntryResponse* other);

  // implements Message ----------------------------------------------

  RewardRecoverPowerEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRecoverPowerEntryResponse& from);
  void MergeFrom(const RewardRecoverPowerEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 power = 1;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 1;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 enable = 2;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 2;
  inline ::google::protobuf::int32 enable() const;
  inline void set_enable(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardRecoverPowerEntryResponse)
 private:
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 enable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRecoverPowerEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardRecoverPowerPurchRequest : public ::google::protobuf::MessageLite {
 public:
  RewardRecoverPowerPurchRequest();
  virtual ~RewardRecoverPowerPurchRequest();

  RewardRecoverPowerPurchRequest(const RewardRecoverPowerPurchRequest& from);

  inline RewardRecoverPowerPurchRequest& operator=(const RewardRecoverPowerPurchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRecoverPowerPurchRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRecoverPowerPurchRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRecoverPowerPurchRequest* other);

  // implements Message ----------------------------------------------

  RewardRecoverPowerPurchRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRecoverPowerPurchRequest& from);
  void MergeFrom(const RewardRecoverPowerPurchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardRecoverPowerPurchRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRecoverPowerPurchRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardRecoverPowerPurchResponse : public ::google::protobuf::MessageLite {
 public:
  RewardRecoverPowerPurchResponse();
  virtual ~RewardRecoverPowerPurchResponse();

  RewardRecoverPowerPurchResponse(const RewardRecoverPowerPurchResponse& from);

  inline RewardRecoverPowerPurchResponse& operator=(const RewardRecoverPowerPurchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRecoverPowerPurchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRecoverPowerPurchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRecoverPowerPurchResponse* other);

  // implements Message ----------------------------------------------

  RewardRecoverPowerPurchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRecoverPowerPurchResponse& from);
  void MergeFrom(const RewardRecoverPowerPurchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardRecoverPowerPurchResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRecoverPowerPurchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardGodPrayEntryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardGodPrayEntryRequest();
  virtual ~RewardGodPrayEntryRequest();

  RewardGodPrayEntryRequest(const RewardGodPrayEntryRequest& from);

  inline RewardGodPrayEntryRequest& operator=(const RewardGodPrayEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGodPrayEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGodPrayEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGodPrayEntryRequest* other);

  // implements Message ----------------------------------------------

  RewardGodPrayEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGodPrayEntryRequest& from);
  void MergeFrom(const RewardGodPrayEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardGodPrayEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGodPrayEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardGodPrayEntryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardGodPrayEntryResponse();
  virtual ~RewardGodPrayEntryResponse();

  RewardGodPrayEntryResponse(const RewardGodPrayEntryResponse& from);

  inline RewardGodPrayEntryResponse& operator=(const RewardGodPrayEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGodPrayEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGodPrayEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGodPrayEntryResponse* other);

  // implements Message ----------------------------------------------

  RewardGodPrayEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGodPrayEntryResponse& from);
  void MergeFrom(const RewardGodPrayEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 current = 1;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 1;
  inline ::google::protobuf::int32 current() const;
  inline void set_current(::google::protobuf::int32 value);

  // optional int32 max = 2;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline ::google::protobuf::int32 max() const;
  inline void set_max(::google::protobuf::int32 value);

  // optional int32 canDo = 3;
  inline bool has_cando() const;
  inline void clear_cando();
  static const int kCanDoFieldNumber = 3;
  inline ::google::protobuf::int32 cando() const;
  inline void set_cando(::google::protobuf::int32 value);

  // repeated .main.GodRewardInfo godRewardInfo = 4;
  inline int godrewardinfo_size() const;
  inline void clear_godrewardinfo();
  static const int kGodRewardInfoFieldNumber = 4;
  inline const ::main::GodRewardInfo& godrewardinfo(int index) const;
  inline ::main::GodRewardInfo* mutable_godrewardinfo(int index);
  inline ::main::GodRewardInfo* add_godrewardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >&
      godrewardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >*
      mutable_godrewardinfo();

  // @@protoc_insertion_point(class_scope:main.RewardGodPrayEntryResponse)
 private:
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_cando();
  inline void clear_has_cando();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 current_;
  ::google::protobuf::int32 max_;
  ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo > godrewardinfo_;
  ::google::protobuf::int32 cando_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGodPrayEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class GodRewardInfo : public ::google::protobuf::MessageLite {
 public:
  GodRewardInfo();
  virtual ~GodRewardInfo();

  GodRewardInfo(const GodRewardInfo& from);

  inline GodRewardInfo& operator=(const GodRewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GodRewardInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GodRewardInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GodRewardInfo* other);

  // implements Message ----------------------------------------------

  GodRewardInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GodRewardInfo& from);
  void MergeFrom(const GodRewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.GodRewardInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static GodRewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class RewardGodPrayAddRequest : public ::google::protobuf::MessageLite {
 public:
  RewardGodPrayAddRequest();
  virtual ~RewardGodPrayAddRequest();

  RewardGodPrayAddRequest(const RewardGodPrayAddRequest& from);

  inline RewardGodPrayAddRequest& operator=(const RewardGodPrayAddRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGodPrayAddRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGodPrayAddRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGodPrayAddRequest* other);

  // implements Message ----------------------------------------------

  RewardGodPrayAddRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGodPrayAddRequest& from);
  void MergeFrom(const RewardGodPrayAddRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardGodPrayAddRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGodPrayAddRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardGodPrayAddResponse : public ::google::protobuf::MessageLite {
 public:
  RewardGodPrayAddResponse();
  virtual ~RewardGodPrayAddResponse();

  RewardGodPrayAddResponse(const RewardGodPrayAddResponse& from);

  inline RewardGodPrayAddResponse& operator=(const RewardGodPrayAddResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardGodPrayAddResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardGodPrayAddResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardGodPrayAddResponse* other);

  // implements Message ----------------------------------------------

  RewardGodPrayAddResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardGodPrayAddResponse& from);
  void MergeFrom(const RewardGodPrayAddResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 max = 2;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline ::google::protobuf::int32 max() const;
  inline void set_max(::google::protobuf::int32 value);

  // repeated .main.GodRewardInfo godRewardInfo = 3;
  inline int godrewardinfo_size() const;
  inline void clear_godrewardinfo();
  static const int kGodRewardInfoFieldNumber = 3;
  inline const ::main::GodRewardInfo& godrewardinfo(int index) const;
  inline ::main::GodRewardInfo* mutable_godrewardinfo(int index);
  inline ::main::GodRewardInfo* add_godrewardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >&
      godrewardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >*
      mutable_godrewardinfo();

  // @@protoc_insertion_point(class_scope:main.RewardGodPrayAddResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_max();
  inline void clear_has_max();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 max_;
  ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo > godrewardinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardGodPrayAddResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardRegLotteryEntryRequest : public ::google::protobuf::MessageLite {
 public:
  RewardRegLotteryEntryRequest();
  virtual ~RewardRegLotteryEntryRequest();

  RewardRegLotteryEntryRequest(const RewardRegLotteryEntryRequest& from);

  inline RewardRegLotteryEntryRequest& operator=(const RewardRegLotteryEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRegLotteryEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRegLotteryEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRegLotteryEntryRequest* other);

  // implements Message ----------------------------------------------

  RewardRegLotteryEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRegLotteryEntryRequest& from);
  void MergeFrom(const RewardRegLotteryEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardRegLotteryEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRegLotteryEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardRegLotteryEntryResponse : public ::google::protobuf::MessageLite {
 public:
  RewardRegLotteryEntryResponse();
  virtual ~RewardRegLotteryEntryResponse();

  RewardRegLotteryEntryResponse(const RewardRegLotteryEntryResponse& from);

  inline RewardRegLotteryEntryResponse& operator=(const RewardRegLotteryEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRegLotteryEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRegLotteryEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRegLotteryEntryResponse* other);

  // implements Message ----------------------------------------------

  RewardRegLotteryEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRegLotteryEntryResponse& from);
  void MergeFrom(const RewardRegLotteryEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 leftChance = 1;
  inline bool has_leftchance() const;
  inline void clear_leftchance();
  static const int kLeftChanceFieldNumber = 1;
  inline ::google::protobuf::int32 leftchance() const;
  inline void set_leftchance(::google::protobuf::int32 value);

  // optional int32 leftTime = 2;
  inline bool has_lefttime() const;
  inline void clear_lefttime();
  static const int kLeftTimeFieldNumber = 2;
  inline ::google::protobuf::int32 lefttime() const;
  inline void set_lefttime(::google::protobuf::int32 value);

  // optional int32 costGold = 3;
  inline bool has_costgold() const;
  inline void clear_costgold();
  static const int kCostGoldFieldNumber = 3;
  inline ::google::protobuf::int32 costgold() const;
  inline void set_costgold(::google::protobuf::int32 value);

  // repeated string getGolds = 4;
  inline int getgolds_size() const;
  inline void clear_getgolds();
  static const int kGetGoldsFieldNumber = 4;
  inline const ::std::string& getgolds(int index) const;
  inline ::std::string* mutable_getgolds(int index);
  inline void set_getgolds(int index, const ::std::string& value);
  inline void set_getgolds(int index, const char* value);
  inline void set_getgolds(int index, const char* value, size_t size);
  inline ::std::string* add_getgolds();
  inline void add_getgolds(const ::std::string& value);
  inline void add_getgolds(const char* value);
  inline void add_getgolds(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& getgolds() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_getgolds();

  // @@protoc_insertion_point(class_scope:main.RewardRegLotteryEntryResponse)
 private:
  inline void set_has_leftchance();
  inline void clear_has_leftchance();
  inline void set_has_lefttime();
  inline void clear_has_lefttime();
  inline void set_has_costgold();
  inline void clear_has_costgold();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 leftchance_;
  ::google::protobuf::int32 lefttime_;
  ::google::protobuf::RepeatedPtrField< ::std::string> getgolds_;
  ::google::protobuf::int32 costgold_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRegLotteryEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardRegLotteryGetRequest : public ::google::protobuf::MessageLite {
 public:
  RewardRegLotteryGetRequest();
  virtual ~RewardRegLotteryGetRequest();

  RewardRegLotteryGetRequest(const RewardRegLotteryGetRequest& from);

  inline RewardRegLotteryGetRequest& operator=(const RewardRegLotteryGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRegLotteryGetRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRegLotteryGetRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRegLotteryGetRequest* other);

  // implements Message ----------------------------------------------

  RewardRegLotteryGetRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRegLotteryGetRequest& from);
  void MergeFrom(const RewardRegLotteryGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardRegLotteryGetRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRegLotteryGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardRegLotteryGetResponse : public ::google::protobuf::MessageLite {
 public:
  RewardRegLotteryGetResponse();
  virtual ~RewardRegLotteryGetResponse();

  RewardRegLotteryGetResponse(const RewardRegLotteryGetResponse& from);

  inline RewardRegLotteryGetResponse& operator=(const RewardRegLotteryGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRegLotteryGetResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRegLotteryGetResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRegLotteryGetResponse* other);

  // implements Message ----------------------------------------------

  RewardRegLotteryGetResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRegLotteryGetResponse& from);
  void MergeFrom(const RewardRegLotteryGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 returnGold = 1;
  inline bool has_returngold() const;
  inline void clear_returngold();
  static const int kReturnGoldFieldNumber = 1;
  inline ::google::protobuf::int32 returngold() const;
  inline void set_returngold(::google::protobuf::int32 value);

  // optional int32 nextCostGold = 2;
  inline bool has_nextcostgold() const;
  inline void clear_nextcostgold();
  static const int kNextCostGoldFieldNumber = 2;
  inline ::google::protobuf::int32 nextcostgold() const;
  inline void set_nextcostgold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardRegLotteryGetResponse)
 private:
  inline void set_has_returngold();
  inline void clear_has_returngold();
  inline void set_has_nextcostgold();
  inline void clear_has_nextcostgold();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 returngold_;
  ::google::protobuf::int32 nextcostgold_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRegLotteryGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardNoticeMessage : public ::google::protobuf::MessageLite {
 public:
  RewardNoticeMessage();
  virtual ~RewardNoticeMessage();

  RewardNoticeMessage(const RewardNoticeMessage& from);

  inline RewardNoticeMessage& operator=(const RewardNoticeMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardNoticeMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardNoticeMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardNoticeMessage* other);

  // implements Message ----------------------------------------------

  RewardNoticeMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardNoticeMessage& from);
  void MergeFrom(const RewardNoticeMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.RewardTypeState update = 1;
  inline int update_size() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 1;
  inline const ::main::RewardTypeState& update(int index) const;
  inline ::main::RewardTypeState* mutable_update(int index);
  inline ::main::RewardTypeState* add_update();
  inline const ::google::protobuf::RepeatedPtrField< ::main::RewardTypeState >&
      update() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::RewardTypeState >*
      mutable_update();

  // @@protoc_insertion_point(class_scope:main.RewardNoticeMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::RewardTypeState > update_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardNoticeMessage* default_instance_;
};
// -------------------------------------------------------------------

class RewardTypeState : public ::google::protobuf::MessageLite {
 public:
  RewardTypeState();
  virtual ~RewardTypeState();

  RewardTypeState(const RewardTypeState& from);

  inline RewardTypeState& operator=(const RewardTypeState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardTypeState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardTypeState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardTypeState* other);

  // implements Message ----------------------------------------------

  RewardTypeState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardTypeState& from);
  void MergeFrom(const RewardTypeState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardTypeState)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardTypeState* default_instance_;
};
// -------------------------------------------------------------------

class RewardLianDanTimeRequest : public ::google::protobuf::MessageLite {
 public:
  RewardLianDanTimeRequest();
  virtual ~RewardLianDanTimeRequest();

  RewardLianDanTimeRequest(const RewardLianDanTimeRequest& from);

  inline RewardLianDanTimeRequest& operator=(const RewardLianDanTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLianDanTimeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLianDanTimeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLianDanTimeRequest* other);

  // implements Message ----------------------------------------------

  RewardLianDanTimeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLianDanTimeRequest& from);
  void MergeFrom(const RewardLianDanTimeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLianDanTimeRequest)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLianDanTimeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardLianDanTimeResponse : public ::google::protobuf::MessageLite {
 public:
  RewardLianDanTimeResponse();
  virtual ~RewardLianDanTimeResponse();

  RewardLianDanTimeResponse(const RewardLianDanTimeResponse& from);

  inline RewardLianDanTimeResponse& operator=(const RewardLianDanTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLianDanTimeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLianDanTimeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLianDanTimeResponse* other);

  // implements Message ----------------------------------------------

  RewardLianDanTimeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLianDanTimeResponse& from);
  void MergeFrom(const RewardLianDanTimeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLianDanTimeResponse)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLianDanTimeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardLianDanRequest : public ::google::protobuf::MessageLite {
 public:
  RewardLianDanRequest();
  virtual ~RewardLianDanRequest();

  RewardLianDanRequest(const RewardLianDanRequest& from);

  inline RewardLianDanRequest& operator=(const RewardLianDanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLianDanRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLianDanRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLianDanRequest* other);

  // implements Message ----------------------------------------------

  RewardLianDanRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLianDanRequest& from);
  void MergeFrom(const RewardLianDanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 isHigh = 2;
  inline bool has_ishigh() const;
  inline void clear_ishigh();
  static const int kIsHighFieldNumber = 2;
  inline ::google::protobuf::int32 ishigh() const;
  inline void set_ishigh(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLianDanRequest)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_ishigh();
  inline void clear_has_ishigh();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 ishigh_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLianDanRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardLianDanResponse : public ::google::protobuf::MessageLite {
 public:
  RewardLianDanResponse();
  virtual ~RewardLianDanResponse();

  RewardLianDanResponse(const RewardLianDanResponse& from);

  inline RewardLianDanResponse& operator=(const RewardLianDanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardLianDanResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardLianDanResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardLianDanResponse* other);

  // implements Message ----------------------------------------------

  RewardLianDanResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardLianDanResponse& from);
  void MergeFrom(const RewardLianDanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional .main.PropsCardItemProto propsCardItem = 3;
  inline bool has_propscarditem() const;
  inline void clear_propscarditem();
  static const int kPropsCardItemFieldNumber = 3;
  inline const ::main::PropsCardItemProto& propscarditem() const;
  inline ::main::PropsCardItemProto* mutable_propscarditem();
  inline ::main::PropsCardItemProto* release_propscarditem();
  inline void set_allocated_propscarditem(::main::PropsCardItemProto* propscarditem);

  // optional int32 lianDan = 4;
  inline bool has_liandan() const;
  inline void clear_liandan();
  static const int kLianDanFieldNumber = 4;
  inline ::google::protobuf::int32 liandan() const;
  inline void set_liandan(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardLianDanResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_propscarditem();
  inline void clear_has_propscarditem();
  inline void set_has_liandan();
  inline void clear_has_liandan();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 itemid_;
  ::main::PropsCardItemProto* propscarditem_;
  ::google::protobuf::int32 liandan_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardLianDanResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardRegLotteryPush : public ::google::protobuf::MessageLite {
 public:
  RewardRegLotteryPush();
  virtual ~RewardRegLotteryPush();

  RewardRegLotteryPush(const RewardRegLotteryPush& from);

  inline RewardRegLotteryPush& operator=(const RewardRegLotteryPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardRegLotteryPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardRegLotteryPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardRegLotteryPush* other);

  // implements Message ----------------------------------------------

  RewardRegLotteryPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardRegLotteryPush& from);
  void MergeFrom(const RewardRegLotteryPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardRegLotteryPush)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_gold();
  inline void clear_has_gold();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 gold_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardRegLotteryPush* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindAccountRequest : public ::google::protobuf::MessageLite {
 public:
  RewardBindAccountRequest();
  virtual ~RewardBindAccountRequest();

  RewardBindAccountRequest(const RewardBindAccountRequest& from);

  inline RewardBindAccountRequest& operator=(const RewardBindAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindAccountRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindAccountRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindAccountRequest* other);

  // implements Message ----------------------------------------------

  RewardBindAccountRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindAccountRequest& from);
  void MergeFrom(const RewardBindAccountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardBindAccountRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindAccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindAccountResponse : public ::google::protobuf::MessageLite {
 public:
  RewardBindAccountResponse();
  virtual ~RewardBindAccountResponse();

  RewardBindAccountResponse(const RewardBindAccountResponse& from);

  inline RewardBindAccountResponse& operator=(const RewardBindAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindAccountResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindAccountResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindAccountResponse* other);

  // implements Message ----------------------------------------------

  RewardBindAccountResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindAccountResponse& from);
  void MergeFrom(const RewardBindAccountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional .main.RewardItemListProto itemList = 2;
  inline bool has_itemlist() const;
  inline void clear_itemlist();
  static const int kItemListFieldNumber = 2;
  inline const ::main::RewardItemListProto& itemlist() const;
  inline ::main::RewardItemListProto* mutable_itemlist();
  inline ::main::RewardItemListProto* release_itemlist();
  inline void set_allocated_itemlist(::main::RewardItemListProto* itemlist);

  // @@protoc_insertion_point(class_scope:main.RewardBindAccountResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_itemlist();
  inline void clear_has_itemlist();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::RewardItemListProto* itemlist_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindAccountResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardItemListProto : public ::google::protobuf::MessageLite {
 public:
  RewardItemListProto();
  virtual ~RewardItemListProto();

  RewardItemListProto(const RewardItemListProto& from);

  inline RewardItemListProto& operator=(const RewardItemListProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardItemListProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardItemListProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardItemListProto* other);

  // implements Message ----------------------------------------------

  RewardItemListProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardItemListProto& from);
  void MergeFrom(const RewardItemListProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 pvpScore = 3;
  inline bool has_pvpscore() const;
  inline void clear_pvpscore();
  static const int kPvpScoreFieldNumber = 3;
  inline ::google::protobuf::int32 pvpscore() const;
  inline void set_pvpscore(::google::protobuf::int32 value);

  // optional int32 lianDan = 4;
  inline bool has_liandan() const;
  inline void clear_liandan();
  static const int kLianDanFieldNumber = 4;
  inline ::google::protobuf::int32 liandan() const;
  inline void set_liandan(::google::protobuf::int32 value);

  // repeated .main.PropsCardItemProto propsCardItem = 5;
  inline int propscarditem_size() const;
  inline void clear_propscarditem();
  static const int kPropsCardItemFieldNumber = 5;
  inline const ::main::PropsCardItemProto& propscarditem(int index) const;
  inline ::main::PropsCardItemProto* mutable_propscarditem(int index);
  inline ::main::PropsCardItemProto* add_propscarditem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::PropsCardItemProto >&
      propscarditem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::PropsCardItemProto >*
      mutable_propscarditem();

  // repeated .main.OfficerCardItemProto officerCardItem = 6;
  inline int officercarditem_size() const;
  inline void clear_officercarditem();
  static const int kOfficerCardItemFieldNumber = 6;
  inline const ::main::OfficerCardItemProto& officercarditem(int index) const;
  inline ::main::OfficerCardItemProto* mutable_officercarditem(int index);
  inline ::main::OfficerCardItemProto* add_officercarditem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::OfficerCardItemProto >&
      officercarditem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::OfficerCardItemProto >*
      mutable_officercarditem();

  // repeated .main.EquipmentCardItemProto equipmentCardItem = 7;
  inline int equipmentcarditem_size() const;
  inline void clear_equipmentcarditem();
  static const int kEquipmentCardItemFieldNumber = 7;
  inline const ::main::EquipmentCardItemProto& equipmentcarditem(int index) const;
  inline ::main::EquipmentCardItemProto* mutable_equipmentcarditem(int index);
  inline ::main::EquipmentCardItemProto* add_equipmentcarditem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::EquipmentCardItemProto >&
      equipmentcarditem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::EquipmentCardItemProto >*
      mutable_equipmentcarditem();

  // repeated .main.SoldierCardItemProto SoldierCardItem = 8;
  inline int soldiercarditem_size() const;
  inline void clear_soldiercarditem();
  static const int kSoldierCardItemFieldNumber = 8;
  inline const ::main::SoldierCardItemProto& soldiercarditem(int index) const;
  inline ::main::SoldierCardItemProto* mutable_soldiercarditem(int index);
  inline ::main::SoldierCardItemProto* add_soldiercarditem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::SoldierCardItemProto >&
      soldiercarditem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::SoldierCardItemProto >*
      mutable_soldiercarditem();

  // repeated .main.OfficerFragmentCardItemProto officerFragmentCardItem = 9;
  inline int officerfragmentcarditem_size() const;
  inline void clear_officerfragmentcarditem();
  static const int kOfficerFragmentCardItemFieldNumber = 9;
  inline const ::main::OfficerFragmentCardItemProto& officerfragmentcarditem(int index) const;
  inline ::main::OfficerFragmentCardItemProto* mutable_officerfragmentcarditem(int index);
  inline ::main::OfficerFragmentCardItemProto* add_officerfragmentcarditem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::OfficerFragmentCardItemProto >&
      officerfragmentcarditem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::OfficerFragmentCardItemProto >*
      mutable_officerfragmentcarditem();

  // @@protoc_insertion_point(class_scope:main.RewardItemListProto)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_pvpscore();
  inline void clear_has_pvpscore();
  inline void set_has_liandan();
  inline void clear_has_liandan();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 pvpscore_;
  ::google::protobuf::int32 liandan_;
  ::google::protobuf::RepeatedPtrField< ::main::PropsCardItemProto > propscarditem_;
  ::google::protobuf::RepeatedPtrField< ::main::OfficerCardItemProto > officercarditem_;
  ::google::protobuf::RepeatedPtrField< ::main::EquipmentCardItemProto > equipmentcarditem_;
  ::google::protobuf::RepeatedPtrField< ::main::SoldierCardItemProto > soldiercarditem_;
  ::google::protobuf::RepeatedPtrField< ::main::OfficerFragmentCardItemProto > officerfragmentcarditem_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardItemListProto* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindAccountInfoRequest : public ::google::protobuf::MessageLite {
 public:
  RewardBindAccountInfoRequest();
  virtual ~RewardBindAccountInfoRequest();

  RewardBindAccountInfoRequest(const RewardBindAccountInfoRequest& from);

  inline RewardBindAccountInfoRequest& operator=(const RewardBindAccountInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindAccountInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindAccountInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindAccountInfoRequest* other);

  // implements Message ----------------------------------------------

  RewardBindAccountInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindAccountInfoRequest& from);
  void MergeFrom(const RewardBindAccountInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardBindAccountInfoRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindAccountInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindAccountInfoResponse : public ::google::protobuf::MessageLite {
 public:
  RewardBindAccountInfoResponse();
  virtual ~RewardBindAccountInfoResponse();

  RewardBindAccountInfoResponse(const RewardBindAccountInfoResponse& from);

  inline RewardBindAccountInfoResponse& operator=(const RewardBindAccountInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindAccountInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindAccountInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindAccountInfoResponse* other);

  // implements Message ----------------------------------------------

  RewardBindAccountInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindAccountInfoResponse& from);
  void MergeFrom(const RewardBindAccountInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // repeated .main.RewardInfoProto rewardInfo = 2;
  inline int rewardinfo_size() const;
  inline void clear_rewardinfo();
  static const int kRewardInfoFieldNumber = 2;
  inline const ::main::RewardInfoProto& rewardinfo(int index) const;
  inline ::main::RewardInfoProto* mutable_rewardinfo(int index);
  inline ::main::RewardInfoProto* add_rewardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
      rewardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
      mutable_rewardinfo();

  // optional int32 mailState = 3;
  inline bool has_mailstate() const;
  inline void clear_mailstate();
  static const int kMailStateFieldNumber = 3;
  inline ::google::protobuf::int32 mailstate() const;
  inline void set_mailstate(::google::protobuf::int32 value);

  // optional string mail = 4;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 4;
  inline const ::std::string& mail() const;
  inline void set_mail(const ::std::string& value);
  inline void set_mail(const char* value);
  inline void set_mail(const char* value, size_t size);
  inline ::std::string* mutable_mail();
  inline ::std::string* release_mail();
  inline void set_allocated_mail(::std::string* mail);

  // repeated .main.RewardInfoProto mailRewardInfo = 5;
  inline int mailrewardinfo_size() const;
  inline void clear_mailrewardinfo();
  static const int kMailRewardInfoFieldNumber = 5;
  inline const ::main::RewardInfoProto& mailrewardinfo(int index) const;
  inline ::main::RewardInfoProto* mutable_mailrewardinfo(int index);
  inline ::main::RewardInfoProto* add_mailrewardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
      mailrewardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
      mutable_mailrewardinfo();

  // @@protoc_insertion_point(class_scope:main.RewardBindAccountInfoResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_mailstate();
  inline void clear_has_mailstate();
  inline void set_has_mail();
  inline void clear_has_mail();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto > rewardinfo_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 mailstate_;
  ::std::string* mail_;
  ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto > mailrewardinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindAccountInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class BindMailRequest : public ::google::protobuf::MessageLite {
 public:
  BindMailRequest();
  virtual ~BindMailRequest();

  BindMailRequest(const BindMailRequest& from);

  inline BindMailRequest& operator=(const BindMailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BindMailRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BindMailRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BindMailRequest* other);

  // implements Message ----------------------------------------------

  BindMailRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BindMailRequest& from);
  void MergeFrom(const BindMailRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string mail = 2;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 2;
  inline const ::std::string& mail() const;
  inline void set_mail(const ::std::string& value);
  inline void set_mail(const char* value);
  inline void set_mail(const char* value, size_t size);
  inline ::std::string* mutable_mail();
  inline ::std::string* release_mail();
  inline void set_allocated_mail(::std::string* mail);

  // @@protoc_insertion_point(class_scope:main.BindMailRequest)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_mail();
  inline void clear_has_mail();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mail_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static BindMailRequest* default_instance_;
};
// -------------------------------------------------------------------

class BindMailResponse : public ::google::protobuf::MessageLite {
 public:
  BindMailResponse();
  virtual ~BindMailResponse();

  BindMailResponse(const BindMailResponse& from);

  inline BindMailResponse& operator=(const BindMailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BindMailResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BindMailResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BindMailResponse* other);

  // implements Message ----------------------------------------------

  BindMailResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BindMailResponse& from);
  void MergeFrom(const BindMailResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.BindMailResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static BindMailResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindMailRequest : public ::google::protobuf::MessageLite {
 public:
  RewardBindMailRequest();
  virtual ~RewardBindMailRequest();

  RewardBindMailRequest(const RewardBindMailRequest& from);

  inline RewardBindMailRequest& operator=(const RewardBindMailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindMailRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindMailRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindMailRequest* other);

  // implements Message ----------------------------------------------

  RewardBindMailRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindMailRequest& from);
  void MergeFrom(const RewardBindMailRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.RewardBindMailRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindMailRequest* default_instance_;
};
// -------------------------------------------------------------------

class RewardBindMailResponse : public ::google::protobuf::MessageLite {
 public:
  RewardBindMailResponse();
  virtual ~RewardBindMailResponse();

  RewardBindMailResponse(const RewardBindMailResponse& from);

  inline RewardBindMailResponse& operator=(const RewardBindMailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardBindMailResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardBindMailResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardBindMailResponse* other);

  // implements Message ----------------------------------------------

  RewardBindMailResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardBindMailResponse& from);
  void MergeFrom(const RewardBindMailResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional .main.RewardItemListProto itemList = 2;
  inline bool has_itemlist() const;
  inline void clear_itemlist();
  static const int kItemListFieldNumber = 2;
  inline const ::main::RewardItemListProto& itemlist() const;
  inline ::main::RewardItemListProto* mutable_itemlist();
  inline ::main::RewardItemListProto* release_itemlist();
  inline void set_allocated_itemlist(::main::RewardItemListProto* itemlist);

  // @@protoc_insertion_point(class_scope:main.RewardBindMailResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_itemlist();
  inline void clear_has_itemlist();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::RewardItemListProto* itemlist_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardBindMailResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeCodeEntryRequest : public ::google::protobuf::MessageLite {
 public:
  ExchangeCodeEntryRequest();
  virtual ~ExchangeCodeEntryRequest();

  ExchangeCodeEntryRequest(const ExchangeCodeEntryRequest& from);

  inline ExchangeCodeEntryRequest& operator=(const ExchangeCodeEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExchangeCodeEntryRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeCodeEntryRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeCodeEntryRequest* other);

  // implements Message ----------------------------------------------

  ExchangeCodeEntryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeCodeEntryRequest& from);
  void MergeFrom(const ExchangeCodeEntryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ExchangeCodeEntryRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static ExchangeCodeEntryRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeCodeEntryResponse : public ::google::protobuf::MessageLite {
 public:
  ExchangeCodeEntryResponse();
  virtual ~ExchangeCodeEntryResponse();

  ExchangeCodeEntryResponse(const ExchangeCodeEntryResponse& from);

  inline ExchangeCodeEntryResponse& operator=(const ExchangeCodeEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExchangeCodeEntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeCodeEntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeCodeEntryResponse* other);

  // implements Message ----------------------------------------------

  ExchangeCodeEntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeCodeEntryResponse& from);
  void MergeFrom(const ExchangeCodeEntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info(int index) const;
  inline ::std::string* mutable_info(int index);
  inline void set_info(int index, const ::std::string& value);
  inline void set_info(int index, const char* value);
  inline void set_info(int index, const char* value, size_t size);
  inline ::std::string* add_info();
  inline void add_info(const ::std::string& value);
  inline void add_info(const char* value);
  inline void add_info(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_info();

  // @@protoc_insertion_point(class_scope:main.ExchangeCodeEntryResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static ExchangeCodeEntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeCodeInfoRequest : public ::google::protobuf::MessageLite {
 public:
  ExchangeCodeInfoRequest();
  virtual ~ExchangeCodeInfoRequest();

  ExchangeCodeInfoRequest(const ExchangeCodeInfoRequest& from);

  inline ExchangeCodeInfoRequest& operator=(const ExchangeCodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExchangeCodeInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeCodeInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeCodeInfoRequest* other);

  // implements Message ----------------------------------------------

  ExchangeCodeInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeCodeInfoRequest& from);
  void MergeFrom(const ExchangeCodeInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:main.ExchangeCodeInfoRequest)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static ExchangeCodeInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeCodeInfoResponse : public ::google::protobuf::MessageLite {
 public:
  ExchangeCodeInfoResponse();
  virtual ~ExchangeCodeInfoResponse();

  ExchangeCodeInfoResponse(const ExchangeCodeInfoResponse& from);

  inline ExchangeCodeInfoResponse& operator=(const ExchangeCodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExchangeCodeInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeCodeInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeCodeInfoResponse* other);

  // implements Message ----------------------------------------------

  ExchangeCodeInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeCodeInfoResponse& from);
  void MergeFrom(const ExchangeCodeInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 rewardId = 2;
  inline bool has_rewardid() const;
  inline void clear_rewardid();
  static const int kRewardIdFieldNumber = 2;
  inline ::google::protobuf::int32 rewardid() const;
  inline void set_rewardid(::google::protobuf::int32 value);

  // repeated .main.RewardInfoProto rewardInfo = 3;
  inline int rewardinfo_size() const;
  inline void clear_rewardinfo();
  static const int kRewardInfoFieldNumber = 3;
  inline const ::main::RewardInfoProto& rewardinfo(int index) const;
  inline ::main::RewardInfoProto* mutable_rewardinfo(int index);
  inline ::main::RewardInfoProto* add_rewardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
      rewardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
      mutable_rewardinfo();

  // @@protoc_insertion_point(class_scope:main.ExchangeCodeInfoResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_rewardid();
  inline void clear_has_rewardid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 rewardid_;
  ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto > rewardinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static ExchangeCodeInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class RewardInfoProto : public ::google::protobuf::MessageLite {
 public:
  RewardInfoProto();
  virtual ~RewardInfoProto();

  RewardInfoProto(const RewardInfoProto& from);

  inline RewardInfoProto& operator=(const RewardInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RewardInfoProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewardInfoProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RewardInfoProto* other);

  // implements Message ----------------------------------------------

  RewardInfoProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewardInfoProto& from);
  void MergeFrom(const RewardInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RewardInfoProto)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_number();
  inline void clear_has_number();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static RewardInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class FirstPayRewardResponse : public ::google::protobuf::MessageLite {
 public:
  FirstPayRewardResponse();
  virtual ~FirstPayRewardResponse();

  FirstPayRewardResponse(const FirstPayRewardResponse& from);

  inline FirstPayRewardResponse& operator=(const FirstPayRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FirstPayRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FirstPayRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FirstPayRewardResponse* other);

  // implements Message ----------------------------------------------

  FirstPayRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FirstPayRewardResponse& from);
  void MergeFrom(const FirstPayRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.FirstPayRewardItemProto firstPayRewardItemProto = 1;
  inline int firstpayrewarditemproto_size() const;
  inline void clear_firstpayrewarditemproto();
  static const int kFirstPayRewardItemProtoFieldNumber = 1;
  inline const ::main::FirstPayRewardItemProto& firstpayrewarditemproto(int index) const;
  inline ::main::FirstPayRewardItemProto* mutable_firstpayrewarditemproto(int index);
  inline ::main::FirstPayRewardItemProto* add_firstpayrewarditemproto();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FirstPayRewardItemProto >&
      firstpayrewarditemproto() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FirstPayRewardItemProto >*
      mutable_firstpayrewarditemproto();

  // @@protoc_insertion_point(class_scope:main.FirstPayRewardResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::FirstPayRewardItemProto > firstpayrewarditemproto_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static FirstPayRewardResponse* default_instance_;
};
// -------------------------------------------------------------------

class FirstPayRewardItemProto : public ::google::protobuf::MessageLite {
 public:
  FirstPayRewardItemProto();
  virtual ~FirstPayRewardItemProto();

  FirstPayRewardItemProto(const FirstPayRewardItemProto& from);

  inline FirstPayRewardItemProto& operator=(const FirstPayRewardItemProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FirstPayRewardItemProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FirstPayRewardItemProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FirstPayRewardItemProto* other);

  // implements Message ----------------------------------------------

  FirstPayRewardItemProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FirstPayRewardItemProto& from);
  void MergeFrom(const FirstPayRewardItemProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemType = 1;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 1;
  inline ::google::protobuf::int32 itemtype() const;
  inline void set_itemtype(::google::protobuf::int32 value);

  // optional int32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemCount = 3;
  inline bool has_itemcount() const;
  inline void clear_itemcount();
  static const int kItemCountFieldNumber = 3;
  inline ::google::protobuf::int32 itemcount() const;
  inline void set_itemcount(::google::protobuf::int32 value);

  // optional int32 itemLevel = 4;
  inline bool has_itemlevel() const;
  inline void clear_itemlevel();
  static const int kItemLevelFieldNumber = 4;
  inline ::google::protobuf::int32 itemlevel() const;
  inline void set_itemlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FirstPayRewardItemProto)
 private:
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemcount();
  inline void clear_has_itemcount();
  inline void set_has_itemlevel();
  inline void clear_has_itemlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemtype_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemcount_;
  ::google::protobuf::int32 itemlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static FirstPayRewardItemProto* default_instance_;
};
// -------------------------------------------------------------------

class SigninDetailRequest : public ::google::protobuf::MessageLite {
 public:
  SigninDetailRequest();
  virtual ~SigninDetailRequest();

  SigninDetailRequest(const SigninDetailRequest& from);

  inline SigninDetailRequest& operator=(const SigninDetailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SigninDetailRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SigninDetailRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SigninDetailRequest* other);

  // implements Message ----------------------------------------------

  SigninDetailRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SigninDetailRequest& from);
  void MergeFrom(const SigninDetailRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.SigninDetailRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static SigninDetailRequest* default_instance_;
};
// -------------------------------------------------------------------

class SigninDetailResponse : public ::google::protobuf::MessageLite {
 public:
  SigninDetailResponse();
  virtual ~SigninDetailResponse();

  SigninDetailResponse(const SigninDetailResponse& from);

  inline SigninDetailResponse& operator=(const SigninDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SigninDetailResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SigninDetailResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SigninDetailResponse* other);

  // implements Message ----------------------------------------------

  SigninDetailResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SigninDetailResponse& from);
  void MergeFrom(const SigninDetailResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.SigninCell cells = 1;
  inline int cells_size() const;
  inline void clear_cells();
  static const int kCellsFieldNumber = 1;
  inline const ::main::SigninCell& cells(int index) const;
  inline ::main::SigninCell* mutable_cells(int index);
  inline ::main::SigninCell* add_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::main::SigninCell >&
      cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::SigninCell >*
      mutable_cells();

  // required int32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);

  // required int32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.SigninDetailResponse)
 private:
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::SigninCell > cells_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static SigninDetailResponse* default_instance_;
};
// -------------------------------------------------------------------

class SigninCell : public ::google::protobuf::MessageLite {
 public:
  SigninCell();
  virtual ~SigninCell();

  SigninCell(const SigninCell& from);

  inline SigninCell& operator=(const SigninCell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SigninCell& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SigninCell* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SigninCell* other);

  // implements Message ----------------------------------------------

  SigninCell* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SigninCell& from);
  void MergeFrom(const SigninCell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .main.ItemDataProto itemData = 1;
  inline bool has_itemdata() const;
  inline void clear_itemdata();
  static const int kItemDataFieldNumber = 1;
  inline const ::main::ItemDataProto& itemdata() const;
  inline ::main::ItemDataProto* mutable_itemdata();
  inline ::main::ItemDataProto* release_itemdata();
  inline void set_allocated_itemdata(::main::ItemDataProto* itemdata);

  // required .main.SignState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::main::SignState state() const;
  inline void set_state(::main::SignState value);

  // required string showString = 3;
  inline bool has_showstring() const;
  inline void clear_showstring();
  static const int kShowStringFieldNumber = 3;
  inline const ::std::string& showstring() const;
  inline void set_showstring(const ::std::string& value);
  inline void set_showstring(const char* value);
  inline void set_showstring(const char* value, size_t size);
  inline ::std::string* mutable_showstring();
  inline ::std::string* release_showstring();
  inline void set_allocated_showstring(::std::string* showstring);

  // required int32 niubility = 4;
  inline bool has_niubility() const;
  inline void clear_niubility();
  static const int kNiubilityFieldNumber = 4;
  inline ::google::protobuf::int32 niubility() const;
  inline void set_niubility(::google::protobuf::int32 value);

  // required string itemDesc = 5;
  inline bool has_itemdesc() const;
  inline void clear_itemdesc();
  static const int kItemDescFieldNumber = 5;
  inline const ::std::string& itemdesc() const;
  inline void set_itemdesc(const ::std::string& value);
  inline void set_itemdesc(const char* value);
  inline void set_itemdesc(const char* value, size_t size);
  inline ::std::string* mutable_itemdesc();
  inline ::std::string* release_itemdesc();
  inline void set_allocated_itemdesc(::std::string* itemdesc);

  // required string vipDesc = 6;
  inline bool has_vipdesc() const;
  inline void clear_vipdesc();
  static const int kVipDescFieldNumber = 6;
  inline const ::std::string& vipdesc() const;
  inline void set_vipdesc(const ::std::string& value);
  inline void set_vipdesc(const char* value);
  inline void set_vipdesc(const char* value, size_t size);
  inline ::std::string* mutable_vipdesc();
  inline ::std::string* release_vipdesc();
  inline void set_allocated_vipdesc(::std::string* vipdesc);

  // @@protoc_insertion_point(class_scope:main.SigninCell)
 private:
  inline void set_has_itemdata();
  inline void clear_has_itemdata();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_showstring();
  inline void clear_has_showstring();
  inline void set_has_niubility();
  inline void clear_has_niubility();
  inline void set_has_itemdesc();
  inline void clear_has_itemdesc();
  inline void set_has_vipdesc();
  inline void clear_has_vipdesc();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::ItemDataProto* itemdata_;
  ::std::string* showstring_;
  int state_;
  ::google::protobuf::int32 niubility_;
  ::std::string* itemdesc_;
  ::std::string* vipdesc_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static SigninCell* default_instance_;
};
// -------------------------------------------------------------------

class SigninRewardRequest : public ::google::protobuf::MessageLite {
 public:
  SigninRewardRequest();
  virtual ~SigninRewardRequest();

  SigninRewardRequest(const SigninRewardRequest& from);

  inline SigninRewardRequest& operator=(const SigninRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SigninRewardRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SigninRewardRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SigninRewardRequest* other);

  // implements Message ----------------------------------------------

  SigninRewardRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SigninRewardRequest& from);
  void MergeFrom(const SigninRewardRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.SigninRewardRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static SigninRewardRequest* default_instance_;
};
// -------------------------------------------------------------------

class SigninRewardResponse : public ::google::protobuf::MessageLite {
 public:
  SigninRewardResponse();
  virtual ~SigninRewardResponse();

  SigninRewardResponse(const SigninRewardResponse& from);

  inline SigninRewardResponse& operator=(const SigninRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SigninRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SigninRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SigninRewardResponse* other);

  // implements Message ----------------------------------------------

  SigninRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SigninRewardResponse& from);
  void MergeFrom(const SigninRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rewardState = 1;
  inline bool has_rewardstate() const;
  inline void clear_rewardstate();
  static const int kRewardStateFieldNumber = 1;
  inline ::google::protobuf::int32 rewardstate() const;
  inline void set_rewardstate(::google::protobuf::int32 value);

  // required .main.ItemDataProto itemData = 2;
  inline bool has_itemdata() const;
  inline void clear_itemdata();
  static const int kItemDataFieldNumber = 2;
  inline const ::main::ItemDataProto& itemdata() const;
  inline ::main::ItemDataProto* mutable_itemdata();
  inline ::main::ItemDataProto* release_itemdata();
  inline void set_allocated_itemdata(::main::ItemDataProto* itemdata);

  // required int32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // required .main.SignState cellState = 4;
  inline bool has_cellstate() const;
  inline void clear_cellstate();
  static const int kCellStateFieldNumber = 4;
  inline ::main::SignState cellstate() const;
  inline void set_cellstate(::main::SignState value);

  // required int32 niubility = 5;
  inline bool has_niubility() const;
  inline void clear_niubility();
  static const int kNiubilityFieldNumber = 5;
  inline ::google::protobuf::int32 niubility() const;
  inline void set_niubility(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.SigninRewardResponse)
 private:
  inline void set_has_rewardstate();
  inline void clear_has_rewardstate();
  inline void set_has_itemdata();
  inline void clear_has_itemdata();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_cellstate();
  inline void clear_has_cellstate();
  inline void set_has_niubility();
  inline void clear_has_niubility();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::ItemDataProto* itemdata_;
  ::google::protobuf::int32 rewardstate_;
  ::google::protobuf::int32 day_;
  int cellstate_;
  ::google::protobuf::int32 niubility_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RewardModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RewardModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_RewardModule_2eproto();
  friend void protobuf_ShutdownFile_RewardModule_2eproto();

  void InitAsDefaultInstance();
  static SigninRewardResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// RewardLevelUpEntryRequest

// -------------------------------------------------------------------

// RewardLevelUpEntryResponse

// repeated int32 records = 1;
inline int RewardLevelUpEntryResponse::records_size() const {
  return records_.size();
}
inline void RewardLevelUpEntryResponse::clear_records() {
  records_.Clear();
}
inline ::google::protobuf::int32 RewardLevelUpEntryResponse::records(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardLevelUpEntryResponse.records)
  return records_.Get(index);
}
inline void RewardLevelUpEntryResponse::set_records(int index, ::google::protobuf::int32 value) {
  records_.Set(index, value);
  // @@protoc_insertion_point(field_set:main.RewardLevelUpEntryResponse.records)
}
inline void RewardLevelUpEntryResponse::add_records(::google::protobuf::int32 value) {
  records_.Add(value);
  // @@protoc_insertion_point(field_add:main.RewardLevelUpEntryResponse.records)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RewardLevelUpEntryResponse::records() const {
  // @@protoc_insertion_point(field_list:main.RewardLevelUpEntryResponse.records)
  return records_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RewardLevelUpEntryResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardLevelUpEntryResponse.records)
  return &records_;
}

// -------------------------------------------------------------------

// RewardLevelUpPurchRequest

// required int32 level = 1;
inline bool RewardLevelUpPurchRequest::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLevelUpPurchRequest::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLevelUpPurchRequest::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLevelUpPurchRequest::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RewardLevelUpPurchRequest::level() const {
  // @@protoc_insertion_point(field_get:main.RewardLevelUpPurchRequest.level)
  return level_;
}
inline void RewardLevelUpPurchRequest::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLevelUpPurchRequest.level)
}

// -------------------------------------------------------------------

// RewardLevelUpPurchResponse

// optional int32 result = 1;
inline bool RewardLevelUpPurchResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLevelUpPurchResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLevelUpPurchResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLevelUpPurchResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RewardLevelUpPurchResponse::result() const {
  // @@protoc_insertion_point(field_get:main.RewardLevelUpPurchResponse.result)
  return result_;
}
inline void RewardLevelUpPurchResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLevelUpPurchResponse.result)
}

// -------------------------------------------------------------------

// RewardSalaryEntryRequest

// -------------------------------------------------------------------

// RewardSalaryEntryResponse

// optional int32 levelCoin = 1;
inline bool RewardSalaryEntryResponse::has_levelcoin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_levelcoin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardSalaryEntryResponse::clear_has_levelcoin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardSalaryEntryResponse::clear_levelcoin() {
  levelcoin_ = 0;
  clear_has_levelcoin();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::levelcoin() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.levelCoin)
  return levelcoin_;
}
inline void RewardSalaryEntryResponse::set_levelcoin(::google::protobuf::int32 value) {
  set_has_levelcoin();
  levelcoin_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.levelCoin)
}

// optional int32 levelRewardTime = 2;
inline bool RewardSalaryEntryResponse::has_levelrewardtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_levelrewardtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardSalaryEntryResponse::clear_has_levelrewardtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardSalaryEntryResponse::clear_levelrewardtime() {
  levelrewardtime_ = 0;
  clear_has_levelrewardtime();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::levelrewardtime() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.levelRewardTime)
  return levelrewardtime_;
}
inline void RewardSalaryEntryResponse::set_levelrewardtime(::google::protobuf::int32 value) {
  set_has_levelrewardtime();
  levelrewardtime_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.levelRewardTime)
}

// optional int32 pvpLevel = 3;
inline bool RewardSalaryEntryResponse::has_pvplevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_pvplevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardSalaryEntryResponse::clear_has_pvplevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardSalaryEntryResponse::clear_pvplevel() {
  pvplevel_ = 0;
  clear_has_pvplevel();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::pvplevel() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.pvpLevel)
  return pvplevel_;
}
inline void RewardSalaryEntryResponse::set_pvplevel(::google::protobuf::int32 value) {
  set_has_pvplevel();
  pvplevel_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.pvpLevel)
}

// optional int32 pvpLevelCoin = 4;
inline bool RewardSalaryEntryResponse::has_pvplevelcoin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_pvplevelcoin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewardSalaryEntryResponse::clear_has_pvplevelcoin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewardSalaryEntryResponse::clear_pvplevelcoin() {
  pvplevelcoin_ = 0;
  clear_has_pvplevelcoin();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::pvplevelcoin() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.pvpLevelCoin)
  return pvplevelcoin_;
}
inline void RewardSalaryEntryResponse::set_pvplevelcoin(::google::protobuf::int32 value) {
  set_has_pvplevelcoin();
  pvplevelcoin_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.pvpLevelCoin)
}

// optional int32 pvpRewardTime = 5;
inline bool RewardSalaryEntryResponse::has_pvprewardtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_pvprewardtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RewardSalaryEntryResponse::clear_has_pvprewardtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RewardSalaryEntryResponse::clear_pvprewardtime() {
  pvprewardtime_ = 0;
  clear_has_pvprewardtime();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::pvprewardtime() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.pvpRewardTime)
  return pvprewardtime_;
}
inline void RewardSalaryEntryResponse::set_pvprewardtime(::google::protobuf::int32 value) {
  set_has_pvprewardtime();
  pvprewardtime_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.pvpRewardTime)
}

// optional int32 pveMinLevel = 6;
inline bool RewardSalaryEntryResponse::has_pveminlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_pveminlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RewardSalaryEntryResponse::clear_has_pveminlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RewardSalaryEntryResponse::clear_pveminlevel() {
  pveminlevel_ = 0;
  clear_has_pveminlevel();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::pveminlevel() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.pveMinLevel)
  return pveminlevel_;
}
inline void RewardSalaryEntryResponse::set_pveminlevel(::google::protobuf::int32 value) {
  set_has_pveminlevel();
  pveminlevel_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.pveMinLevel)
}

// optional int32 pvpMinLevel = 7;
inline bool RewardSalaryEntryResponse::has_pvpminlevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RewardSalaryEntryResponse::set_has_pvpminlevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RewardSalaryEntryResponse::clear_has_pvpminlevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RewardSalaryEntryResponse::clear_pvpminlevel() {
  pvpminlevel_ = 0;
  clear_has_pvpminlevel();
}
inline ::google::protobuf::int32 RewardSalaryEntryResponse::pvpminlevel() const {
  // @@protoc_insertion_point(field_get:main.RewardSalaryEntryResponse.pvpMinLevel)
  return pvpminlevel_;
}
inline void RewardSalaryEntryResponse::set_pvpminlevel(::google::protobuf::int32 value) {
  set_has_pvpminlevel();
  pvpminlevel_ = value;
  // @@protoc_insertion_point(field_set:main.RewardSalaryEntryResponse.pvpMinLevel)
}

// -------------------------------------------------------------------

// RewardGetSalaryRequest

// required int32 type = 1;
inline bool RewardGetSalaryRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardGetSalaryRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardGetSalaryRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardGetSalaryRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RewardGetSalaryRequest::type() const {
  // @@protoc_insertion_point(field_get:main.RewardGetSalaryRequest.type)
  return type_;
}
inline void RewardGetSalaryRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGetSalaryRequest.type)
}

// -------------------------------------------------------------------

// RewardGetSalaryResponse

// optional int32 result = 1;
inline bool RewardGetSalaryResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardGetSalaryResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardGetSalaryResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardGetSalaryResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RewardGetSalaryResponse::result() const {
  // @@protoc_insertion_point(field_get:main.RewardGetSalaryResponse.result)
  return result_;
}
inline void RewardGetSalaryResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGetSalaryResponse.result)
}

// -------------------------------------------------------------------

// RewardRecoverPowerEntryRequest

// -------------------------------------------------------------------

// RewardRecoverPowerEntryResponse

// optional int32 power = 1;
inline bool RewardRecoverPowerEntryResponse::has_power() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardRecoverPowerEntryResponse::set_has_power() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardRecoverPowerEntryResponse::clear_has_power() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardRecoverPowerEntryResponse::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 RewardRecoverPowerEntryResponse::power() const {
  // @@protoc_insertion_point(field_get:main.RewardRecoverPowerEntryResponse.power)
  return power_;
}
inline void RewardRecoverPowerEntryResponse::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRecoverPowerEntryResponse.power)
}

// optional int32 enable = 2;
inline bool RewardRecoverPowerEntryResponse::has_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardRecoverPowerEntryResponse::set_has_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardRecoverPowerEntryResponse::clear_has_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardRecoverPowerEntryResponse::clear_enable() {
  enable_ = 0;
  clear_has_enable();
}
inline ::google::protobuf::int32 RewardRecoverPowerEntryResponse::enable() const {
  // @@protoc_insertion_point(field_get:main.RewardRecoverPowerEntryResponse.enable)
  return enable_;
}
inline void RewardRecoverPowerEntryResponse::set_enable(::google::protobuf::int32 value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRecoverPowerEntryResponse.enable)
}

// -------------------------------------------------------------------

// RewardRecoverPowerPurchRequest

// -------------------------------------------------------------------

// RewardRecoverPowerPurchResponse

// optional int32 result = 1;
inline bool RewardRecoverPowerPurchResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardRecoverPowerPurchResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardRecoverPowerPurchResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardRecoverPowerPurchResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RewardRecoverPowerPurchResponse::result() const {
  // @@protoc_insertion_point(field_get:main.RewardRecoverPowerPurchResponse.result)
  return result_;
}
inline void RewardRecoverPowerPurchResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRecoverPowerPurchResponse.result)
}

// -------------------------------------------------------------------

// RewardGodPrayEntryRequest

// -------------------------------------------------------------------

// RewardGodPrayEntryResponse

// optional int32 current = 1;
inline bool RewardGodPrayEntryResponse::has_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardGodPrayEntryResponse::set_has_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardGodPrayEntryResponse::clear_has_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardGodPrayEntryResponse::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline ::google::protobuf::int32 RewardGodPrayEntryResponse::current() const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayEntryResponse.current)
  return current_;
}
inline void RewardGodPrayEntryResponse::set_current(::google::protobuf::int32 value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGodPrayEntryResponse.current)
}

// optional int32 max = 2;
inline bool RewardGodPrayEntryResponse::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardGodPrayEntryResponse::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardGodPrayEntryResponse::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardGodPrayEntryResponse::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 RewardGodPrayEntryResponse::max() const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayEntryResponse.max)
  return max_;
}
inline void RewardGodPrayEntryResponse::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGodPrayEntryResponse.max)
}

// optional int32 canDo = 3;
inline bool RewardGodPrayEntryResponse::has_cando() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardGodPrayEntryResponse::set_has_cando() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardGodPrayEntryResponse::clear_has_cando() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardGodPrayEntryResponse::clear_cando() {
  cando_ = 0;
  clear_has_cando();
}
inline ::google::protobuf::int32 RewardGodPrayEntryResponse::cando() const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayEntryResponse.canDo)
  return cando_;
}
inline void RewardGodPrayEntryResponse::set_cando(::google::protobuf::int32 value) {
  set_has_cando();
  cando_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGodPrayEntryResponse.canDo)
}

// repeated .main.GodRewardInfo godRewardInfo = 4;
inline int RewardGodPrayEntryResponse::godrewardinfo_size() const {
  return godrewardinfo_.size();
}
inline void RewardGodPrayEntryResponse::clear_godrewardinfo() {
  godrewardinfo_.Clear();
}
inline const ::main::GodRewardInfo& RewardGodPrayEntryResponse::godrewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayEntryResponse.godRewardInfo)
  return godrewardinfo_.Get(index);
}
inline ::main::GodRewardInfo* RewardGodPrayEntryResponse::mutable_godrewardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardGodPrayEntryResponse.godRewardInfo)
  return godrewardinfo_.Mutable(index);
}
inline ::main::GodRewardInfo* RewardGodPrayEntryResponse::add_godrewardinfo() {
  // @@protoc_insertion_point(field_add:main.RewardGodPrayEntryResponse.godRewardInfo)
  return godrewardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >&
RewardGodPrayEntryResponse::godrewardinfo() const {
  // @@protoc_insertion_point(field_list:main.RewardGodPrayEntryResponse.godRewardInfo)
  return godrewardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >*
RewardGodPrayEntryResponse::mutable_godrewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardGodPrayEntryResponse.godRewardInfo)
  return &godrewardinfo_;
}

// -------------------------------------------------------------------

// GodRewardInfo

// optional int32 type = 1;
inline bool GodRewardInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GodRewardInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GodRewardInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GodRewardInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GodRewardInfo::type() const {
  // @@protoc_insertion_point(field_get:main.GodRewardInfo.type)
  return type_;
}
inline void GodRewardInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.GodRewardInfo.type)
}

// optional int32 itemId = 2;
inline bool GodRewardInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GodRewardInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GodRewardInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GodRewardInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 GodRewardInfo::itemid() const {
  // @@protoc_insertion_point(field_get:main.GodRewardInfo.itemId)
  return itemid_;
}
inline void GodRewardInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:main.GodRewardInfo.itemId)
}

// optional int32 count = 3;
inline bool GodRewardInfo::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GodRewardInfo::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GodRewardInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GodRewardInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GodRewardInfo::count() const {
  // @@protoc_insertion_point(field_get:main.GodRewardInfo.count)
  return count_;
}
inline void GodRewardInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:main.GodRewardInfo.count)
}

// -------------------------------------------------------------------

// RewardGodPrayAddRequest

// -------------------------------------------------------------------

// RewardGodPrayAddResponse

// optional int32 result = 1;
inline bool RewardGodPrayAddResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardGodPrayAddResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardGodPrayAddResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardGodPrayAddResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RewardGodPrayAddResponse::result() const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayAddResponse.result)
  return result_;
}
inline void RewardGodPrayAddResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGodPrayAddResponse.result)
}

// optional int32 max = 2;
inline bool RewardGodPrayAddResponse::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardGodPrayAddResponse::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardGodPrayAddResponse::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardGodPrayAddResponse::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 RewardGodPrayAddResponse::max() const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayAddResponse.max)
  return max_;
}
inline void RewardGodPrayAddResponse::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:main.RewardGodPrayAddResponse.max)
}

// repeated .main.GodRewardInfo godRewardInfo = 3;
inline int RewardGodPrayAddResponse::godrewardinfo_size() const {
  return godrewardinfo_.size();
}
inline void RewardGodPrayAddResponse::clear_godrewardinfo() {
  godrewardinfo_.Clear();
}
inline const ::main::GodRewardInfo& RewardGodPrayAddResponse::godrewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardGodPrayAddResponse.godRewardInfo)
  return godrewardinfo_.Get(index);
}
inline ::main::GodRewardInfo* RewardGodPrayAddResponse::mutable_godrewardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardGodPrayAddResponse.godRewardInfo)
  return godrewardinfo_.Mutable(index);
}
inline ::main::GodRewardInfo* RewardGodPrayAddResponse::add_godrewardinfo() {
  // @@protoc_insertion_point(field_add:main.RewardGodPrayAddResponse.godRewardInfo)
  return godrewardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >&
RewardGodPrayAddResponse::godrewardinfo() const {
  // @@protoc_insertion_point(field_list:main.RewardGodPrayAddResponse.godRewardInfo)
  return godrewardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::GodRewardInfo >*
RewardGodPrayAddResponse::mutable_godrewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardGodPrayAddResponse.godRewardInfo)
  return &godrewardinfo_;
}

// -------------------------------------------------------------------

// RewardRegLotteryEntryRequest

// -------------------------------------------------------------------

// RewardRegLotteryEntryResponse

// optional int32 leftChance = 1;
inline bool RewardRegLotteryEntryResponse::has_leftchance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardRegLotteryEntryResponse::set_has_leftchance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardRegLotteryEntryResponse::clear_has_leftchance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardRegLotteryEntryResponse::clear_leftchance() {
  leftchance_ = 0;
  clear_has_leftchance();
}
inline ::google::protobuf::int32 RewardRegLotteryEntryResponse::leftchance() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryEntryResponse.leftChance)
  return leftchance_;
}
inline void RewardRegLotteryEntryResponse::set_leftchance(::google::protobuf::int32 value) {
  set_has_leftchance();
  leftchance_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryEntryResponse.leftChance)
}

// optional int32 leftTime = 2;
inline bool RewardRegLotteryEntryResponse::has_lefttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardRegLotteryEntryResponse::set_has_lefttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardRegLotteryEntryResponse::clear_has_lefttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardRegLotteryEntryResponse::clear_lefttime() {
  lefttime_ = 0;
  clear_has_lefttime();
}
inline ::google::protobuf::int32 RewardRegLotteryEntryResponse::lefttime() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryEntryResponse.leftTime)
  return lefttime_;
}
inline void RewardRegLotteryEntryResponse::set_lefttime(::google::protobuf::int32 value) {
  set_has_lefttime();
  lefttime_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryEntryResponse.leftTime)
}

// optional int32 costGold = 3;
inline bool RewardRegLotteryEntryResponse::has_costgold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardRegLotteryEntryResponse::set_has_costgold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardRegLotteryEntryResponse::clear_has_costgold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardRegLotteryEntryResponse::clear_costgold() {
  costgold_ = 0;
  clear_has_costgold();
}
inline ::google::protobuf::int32 RewardRegLotteryEntryResponse::costgold() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryEntryResponse.costGold)
  return costgold_;
}
inline void RewardRegLotteryEntryResponse::set_costgold(::google::protobuf::int32 value) {
  set_has_costgold();
  costgold_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryEntryResponse.costGold)
}

// repeated string getGolds = 4;
inline int RewardRegLotteryEntryResponse::getgolds_size() const {
  return getgolds_.size();
}
inline void RewardRegLotteryEntryResponse::clear_getgolds() {
  getgolds_.Clear();
}
inline const ::std::string& RewardRegLotteryEntryResponse::getgolds(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryEntryResponse.getGolds)
  return getgolds_.Get(index);
}
inline ::std::string* RewardRegLotteryEntryResponse::mutable_getgolds(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardRegLotteryEntryResponse.getGolds)
  return getgolds_.Mutable(index);
}
inline void RewardRegLotteryEntryResponse::set_getgolds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryEntryResponse.getGolds)
  getgolds_.Mutable(index)->assign(value);
}
inline void RewardRegLotteryEntryResponse::set_getgolds(int index, const char* value) {
  getgolds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:main.RewardRegLotteryEntryResponse.getGolds)
}
inline void RewardRegLotteryEntryResponse::set_getgolds(int index, const char* value, size_t size) {
  getgolds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.RewardRegLotteryEntryResponse.getGolds)
}
inline ::std::string* RewardRegLotteryEntryResponse::add_getgolds() {
  return getgolds_.Add();
}
inline void RewardRegLotteryEntryResponse::add_getgolds(const ::std::string& value) {
  getgolds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:main.RewardRegLotteryEntryResponse.getGolds)
}
inline void RewardRegLotteryEntryResponse::add_getgolds(const char* value) {
  getgolds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:main.RewardRegLotteryEntryResponse.getGolds)
}
inline void RewardRegLotteryEntryResponse::add_getgolds(const char* value, size_t size) {
  getgolds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:main.RewardRegLotteryEntryResponse.getGolds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RewardRegLotteryEntryResponse::getgolds() const {
  // @@protoc_insertion_point(field_list:main.RewardRegLotteryEntryResponse.getGolds)
  return getgolds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RewardRegLotteryEntryResponse::mutable_getgolds() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardRegLotteryEntryResponse.getGolds)
  return &getgolds_;
}

// -------------------------------------------------------------------

// RewardRegLotteryGetRequest

// -------------------------------------------------------------------

// RewardRegLotteryGetResponse

// optional int32 returnGold = 1;
inline bool RewardRegLotteryGetResponse::has_returngold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardRegLotteryGetResponse::set_has_returngold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardRegLotteryGetResponse::clear_has_returngold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardRegLotteryGetResponse::clear_returngold() {
  returngold_ = 0;
  clear_has_returngold();
}
inline ::google::protobuf::int32 RewardRegLotteryGetResponse::returngold() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryGetResponse.returnGold)
  return returngold_;
}
inline void RewardRegLotteryGetResponse::set_returngold(::google::protobuf::int32 value) {
  set_has_returngold();
  returngold_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryGetResponse.returnGold)
}

// optional int32 nextCostGold = 2;
inline bool RewardRegLotteryGetResponse::has_nextcostgold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardRegLotteryGetResponse::set_has_nextcostgold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardRegLotteryGetResponse::clear_has_nextcostgold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardRegLotteryGetResponse::clear_nextcostgold() {
  nextcostgold_ = 0;
  clear_has_nextcostgold();
}
inline ::google::protobuf::int32 RewardRegLotteryGetResponse::nextcostgold() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryGetResponse.nextCostGold)
  return nextcostgold_;
}
inline void RewardRegLotteryGetResponse::set_nextcostgold(::google::protobuf::int32 value) {
  set_has_nextcostgold();
  nextcostgold_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryGetResponse.nextCostGold)
}

// -------------------------------------------------------------------

// RewardNoticeMessage

// repeated .main.RewardTypeState update = 1;
inline int RewardNoticeMessage::update_size() const {
  return update_.size();
}
inline void RewardNoticeMessage::clear_update() {
  update_.Clear();
}
inline const ::main::RewardTypeState& RewardNoticeMessage::update(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardNoticeMessage.update)
  return update_.Get(index);
}
inline ::main::RewardTypeState* RewardNoticeMessage::mutable_update(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardNoticeMessage.update)
  return update_.Mutable(index);
}
inline ::main::RewardTypeState* RewardNoticeMessage::add_update() {
  // @@protoc_insertion_point(field_add:main.RewardNoticeMessage.update)
  return update_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::RewardTypeState >&
RewardNoticeMessage::update() const {
  // @@protoc_insertion_point(field_list:main.RewardNoticeMessage.update)
  return update_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::RewardTypeState >*
RewardNoticeMessage::mutable_update() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardNoticeMessage.update)
  return &update_;
}

// -------------------------------------------------------------------

// RewardTypeState

// required int32 type = 1;
inline bool RewardTypeState::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardTypeState::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardTypeState::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardTypeState::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RewardTypeState::type() const {
  // @@protoc_insertion_point(field_get:main.RewardTypeState.type)
  return type_;
}
inline void RewardTypeState::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.RewardTypeState.type)
}

// required int32 state = 2;
inline bool RewardTypeState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardTypeState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardTypeState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardTypeState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RewardTypeState::state() const {
  // @@protoc_insertion_point(field_get:main.RewardTypeState.state)
  return state_;
}
inline void RewardTypeState::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RewardTypeState.state)
}

// -------------------------------------------------------------------

// RewardLianDanTimeRequest

// optional int32 index = 1;
inline bool RewardLianDanTimeRequest::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLianDanTimeRequest::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLianDanTimeRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLianDanTimeRequest::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 RewardLianDanTimeRequest::index() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanTimeRequest.index)
  return index_;
}
inline void RewardLianDanTimeRequest::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanTimeRequest.index)
}

// -------------------------------------------------------------------

// RewardLianDanTimeResponse

// optional int32 time = 1;
inline bool RewardLianDanTimeResponse::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLianDanTimeResponse::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLianDanTimeResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLianDanTimeResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 RewardLianDanTimeResponse::time() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanTimeResponse.time)
  return time_;
}
inline void RewardLianDanTimeResponse::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanTimeResponse.time)
}

// -------------------------------------------------------------------

// RewardLianDanRequest

// optional int32 index = 1;
inline bool RewardLianDanRequest::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLianDanRequest::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLianDanRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLianDanRequest::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 RewardLianDanRequest::index() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanRequest.index)
  return index_;
}
inline void RewardLianDanRequest::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanRequest.index)
}

// optional int32 isHigh = 2;
inline bool RewardLianDanRequest::has_ishigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardLianDanRequest::set_has_ishigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardLianDanRequest::clear_has_ishigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardLianDanRequest::clear_ishigh() {
  ishigh_ = 0;
  clear_has_ishigh();
}
inline ::google::protobuf::int32 RewardLianDanRequest::ishigh() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanRequest.isHigh)
  return ishigh_;
}
inline void RewardLianDanRequest::set_ishigh(::google::protobuf::int32 value) {
  set_has_ishigh();
  ishigh_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanRequest.isHigh)
}

// -------------------------------------------------------------------

// RewardLianDanResponse

// optional int32 state = 1;
inline bool RewardLianDanResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardLianDanResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardLianDanResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardLianDanResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RewardLianDanResponse::state() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanResponse.state)
  return state_;
}
inline void RewardLianDanResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanResponse.state)
}

// optional int32 itemId = 2;
inline bool RewardLianDanResponse::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardLianDanResponse::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardLianDanResponse::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardLianDanResponse::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 RewardLianDanResponse::itemid() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanResponse.itemId)
  return itemid_;
}
inline void RewardLianDanResponse::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanResponse.itemId)
}

// optional .main.PropsCardItemProto propsCardItem = 3;
inline bool RewardLianDanResponse::has_propscarditem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardLianDanResponse::set_has_propscarditem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardLianDanResponse::clear_has_propscarditem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardLianDanResponse::clear_propscarditem() {
  if (propscarditem_ != NULL) propscarditem_->::main::PropsCardItemProto::Clear();
  clear_has_propscarditem();
}
inline const ::main::PropsCardItemProto& RewardLianDanResponse::propscarditem() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanResponse.propsCardItem)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return propscarditem_ != NULL ? *propscarditem_ : *default_instance().propscarditem_;
#else
  return propscarditem_ != NULL ? *propscarditem_ : *default_instance_->propscarditem_;
#endif
}
inline ::main::PropsCardItemProto* RewardLianDanResponse::mutable_propscarditem() {
  set_has_propscarditem();
  if (propscarditem_ == NULL) propscarditem_ = new ::main::PropsCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.RewardLianDanResponse.propsCardItem)
  return propscarditem_;
}
inline ::main::PropsCardItemProto* RewardLianDanResponse::release_propscarditem() {
  clear_has_propscarditem();
  ::main::PropsCardItemProto* temp = propscarditem_;
  propscarditem_ = NULL;
  return temp;
}
inline void RewardLianDanResponse::set_allocated_propscarditem(::main::PropsCardItemProto* propscarditem) {
  delete propscarditem_;
  propscarditem_ = propscarditem;
  if (propscarditem) {
    set_has_propscarditem();
  } else {
    clear_has_propscarditem();
  }
  // @@protoc_insertion_point(field_set_allocated:main.RewardLianDanResponse.propsCardItem)
}

// optional int32 lianDan = 4;
inline bool RewardLianDanResponse::has_liandan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewardLianDanResponse::set_has_liandan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewardLianDanResponse::clear_has_liandan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewardLianDanResponse::clear_liandan() {
  liandan_ = 0;
  clear_has_liandan();
}
inline ::google::protobuf::int32 RewardLianDanResponse::liandan() const {
  // @@protoc_insertion_point(field_get:main.RewardLianDanResponse.lianDan)
  return liandan_;
}
inline void RewardLianDanResponse::set_liandan(::google::protobuf::int32 value) {
  set_has_liandan();
  liandan_ = value;
  // @@protoc_insertion_point(field_set:main.RewardLianDanResponse.lianDan)
}

// -------------------------------------------------------------------

// RewardRegLotteryPush

// optional string name = 1;
inline bool RewardRegLotteryPush::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardRegLotteryPush::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardRegLotteryPush::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardRegLotteryPush::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RewardRegLotteryPush::name() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryPush.name)
  return *name_;
}
inline void RewardRegLotteryPush::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryPush.name)
}
inline void RewardRegLotteryPush::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.RewardRegLotteryPush.name)
}
inline void RewardRegLotteryPush::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.RewardRegLotteryPush.name)
}
inline ::std::string* RewardRegLotteryPush::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.RewardRegLotteryPush.name)
  return name_;
}
inline ::std::string* RewardRegLotteryPush::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RewardRegLotteryPush::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.RewardRegLotteryPush.name)
}

// optional int32 gold = 2;
inline bool RewardRegLotteryPush::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardRegLotteryPush::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardRegLotteryPush::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardRegLotteryPush::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 RewardRegLotteryPush::gold() const {
  // @@protoc_insertion_point(field_get:main.RewardRegLotteryPush.gold)
  return gold_;
}
inline void RewardRegLotteryPush::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:main.RewardRegLotteryPush.gold)
}

// -------------------------------------------------------------------

// RewardBindAccountRequest

// -------------------------------------------------------------------

// RewardBindAccountResponse

// optional int32 state = 1;
inline bool RewardBindAccountResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardBindAccountResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardBindAccountResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardBindAccountResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RewardBindAccountResponse::state() const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountResponse.state)
  return state_;
}
inline void RewardBindAccountResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RewardBindAccountResponse.state)
}

// optional .main.RewardItemListProto itemList = 2;
inline bool RewardBindAccountResponse::has_itemlist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardBindAccountResponse::set_has_itemlist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardBindAccountResponse::clear_has_itemlist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardBindAccountResponse::clear_itemlist() {
  if (itemlist_ != NULL) itemlist_->::main::RewardItemListProto::Clear();
  clear_has_itemlist();
}
inline const ::main::RewardItemListProto& RewardBindAccountResponse::itemlist() const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountResponse.itemList)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemlist_ != NULL ? *itemlist_ : *default_instance().itemlist_;
#else
  return itemlist_ != NULL ? *itemlist_ : *default_instance_->itemlist_;
#endif
}
inline ::main::RewardItemListProto* RewardBindAccountResponse::mutable_itemlist() {
  set_has_itemlist();
  if (itemlist_ == NULL) itemlist_ = new ::main::RewardItemListProto;
  // @@protoc_insertion_point(field_mutable:main.RewardBindAccountResponse.itemList)
  return itemlist_;
}
inline ::main::RewardItemListProto* RewardBindAccountResponse::release_itemlist() {
  clear_has_itemlist();
  ::main::RewardItemListProto* temp = itemlist_;
  itemlist_ = NULL;
  return temp;
}
inline void RewardBindAccountResponse::set_allocated_itemlist(::main::RewardItemListProto* itemlist) {
  delete itemlist_;
  itemlist_ = itemlist;
  if (itemlist) {
    set_has_itemlist();
  } else {
    clear_has_itemlist();
  }
  // @@protoc_insertion_point(field_set_allocated:main.RewardBindAccountResponse.itemList)
}

// -------------------------------------------------------------------

// RewardItemListProto

// optional int32 gold = 1;
inline bool RewardItemListProto::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardItemListProto::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardItemListProto::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardItemListProto::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 RewardItemListProto::gold() const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.gold)
  return gold_;
}
inline void RewardItemListProto::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:main.RewardItemListProto.gold)
}

// optional int32 coin = 2;
inline bool RewardItemListProto::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardItemListProto::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardItemListProto::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardItemListProto::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 RewardItemListProto::coin() const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.coin)
  return coin_;
}
inline void RewardItemListProto::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
  // @@protoc_insertion_point(field_set:main.RewardItemListProto.coin)
}

// optional int32 pvpScore = 3;
inline bool RewardItemListProto::has_pvpscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardItemListProto::set_has_pvpscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardItemListProto::clear_has_pvpscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardItemListProto::clear_pvpscore() {
  pvpscore_ = 0;
  clear_has_pvpscore();
}
inline ::google::protobuf::int32 RewardItemListProto::pvpscore() const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.pvpScore)
  return pvpscore_;
}
inline void RewardItemListProto::set_pvpscore(::google::protobuf::int32 value) {
  set_has_pvpscore();
  pvpscore_ = value;
  // @@protoc_insertion_point(field_set:main.RewardItemListProto.pvpScore)
}

// optional int32 lianDan = 4;
inline bool RewardItemListProto::has_liandan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewardItemListProto::set_has_liandan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewardItemListProto::clear_has_liandan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewardItemListProto::clear_liandan() {
  liandan_ = 0;
  clear_has_liandan();
}
inline ::google::protobuf::int32 RewardItemListProto::liandan() const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.lianDan)
  return liandan_;
}
inline void RewardItemListProto::set_liandan(::google::protobuf::int32 value) {
  set_has_liandan();
  liandan_ = value;
  // @@protoc_insertion_point(field_set:main.RewardItemListProto.lianDan)
}

// repeated .main.PropsCardItemProto propsCardItem = 5;
inline int RewardItemListProto::propscarditem_size() const {
  return propscarditem_.size();
}
inline void RewardItemListProto::clear_propscarditem() {
  propscarditem_.Clear();
}
inline const ::main::PropsCardItemProto& RewardItemListProto::propscarditem(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.propsCardItem)
  return propscarditem_.Get(index);
}
inline ::main::PropsCardItemProto* RewardItemListProto::mutable_propscarditem(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardItemListProto.propsCardItem)
  return propscarditem_.Mutable(index);
}
inline ::main::PropsCardItemProto* RewardItemListProto::add_propscarditem() {
  // @@protoc_insertion_point(field_add:main.RewardItemListProto.propsCardItem)
  return propscarditem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::PropsCardItemProto >&
RewardItemListProto::propscarditem() const {
  // @@protoc_insertion_point(field_list:main.RewardItemListProto.propsCardItem)
  return propscarditem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::PropsCardItemProto >*
RewardItemListProto::mutable_propscarditem() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardItemListProto.propsCardItem)
  return &propscarditem_;
}

// repeated .main.OfficerCardItemProto officerCardItem = 6;
inline int RewardItemListProto::officercarditem_size() const {
  return officercarditem_.size();
}
inline void RewardItemListProto::clear_officercarditem() {
  officercarditem_.Clear();
}
inline const ::main::OfficerCardItemProto& RewardItemListProto::officercarditem(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.officerCardItem)
  return officercarditem_.Get(index);
}
inline ::main::OfficerCardItemProto* RewardItemListProto::mutable_officercarditem(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardItemListProto.officerCardItem)
  return officercarditem_.Mutable(index);
}
inline ::main::OfficerCardItemProto* RewardItemListProto::add_officercarditem() {
  // @@protoc_insertion_point(field_add:main.RewardItemListProto.officerCardItem)
  return officercarditem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::OfficerCardItemProto >&
RewardItemListProto::officercarditem() const {
  // @@protoc_insertion_point(field_list:main.RewardItemListProto.officerCardItem)
  return officercarditem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::OfficerCardItemProto >*
RewardItemListProto::mutable_officercarditem() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardItemListProto.officerCardItem)
  return &officercarditem_;
}

// repeated .main.EquipmentCardItemProto equipmentCardItem = 7;
inline int RewardItemListProto::equipmentcarditem_size() const {
  return equipmentcarditem_.size();
}
inline void RewardItemListProto::clear_equipmentcarditem() {
  equipmentcarditem_.Clear();
}
inline const ::main::EquipmentCardItemProto& RewardItemListProto::equipmentcarditem(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.equipmentCardItem)
  return equipmentcarditem_.Get(index);
}
inline ::main::EquipmentCardItemProto* RewardItemListProto::mutable_equipmentcarditem(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardItemListProto.equipmentCardItem)
  return equipmentcarditem_.Mutable(index);
}
inline ::main::EquipmentCardItemProto* RewardItemListProto::add_equipmentcarditem() {
  // @@protoc_insertion_point(field_add:main.RewardItemListProto.equipmentCardItem)
  return equipmentcarditem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::EquipmentCardItemProto >&
RewardItemListProto::equipmentcarditem() const {
  // @@protoc_insertion_point(field_list:main.RewardItemListProto.equipmentCardItem)
  return equipmentcarditem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::EquipmentCardItemProto >*
RewardItemListProto::mutable_equipmentcarditem() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardItemListProto.equipmentCardItem)
  return &equipmentcarditem_;
}

// repeated .main.SoldierCardItemProto SoldierCardItem = 8;
inline int RewardItemListProto::soldiercarditem_size() const {
  return soldiercarditem_.size();
}
inline void RewardItemListProto::clear_soldiercarditem() {
  soldiercarditem_.Clear();
}
inline const ::main::SoldierCardItemProto& RewardItemListProto::soldiercarditem(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.SoldierCardItem)
  return soldiercarditem_.Get(index);
}
inline ::main::SoldierCardItemProto* RewardItemListProto::mutable_soldiercarditem(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardItemListProto.SoldierCardItem)
  return soldiercarditem_.Mutable(index);
}
inline ::main::SoldierCardItemProto* RewardItemListProto::add_soldiercarditem() {
  // @@protoc_insertion_point(field_add:main.RewardItemListProto.SoldierCardItem)
  return soldiercarditem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::SoldierCardItemProto >&
RewardItemListProto::soldiercarditem() const {
  // @@protoc_insertion_point(field_list:main.RewardItemListProto.SoldierCardItem)
  return soldiercarditem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::SoldierCardItemProto >*
RewardItemListProto::mutable_soldiercarditem() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardItemListProto.SoldierCardItem)
  return &soldiercarditem_;
}

// repeated .main.OfficerFragmentCardItemProto officerFragmentCardItem = 9;
inline int RewardItemListProto::officerfragmentcarditem_size() const {
  return officerfragmentcarditem_.size();
}
inline void RewardItemListProto::clear_officerfragmentcarditem() {
  officerfragmentcarditem_.Clear();
}
inline const ::main::OfficerFragmentCardItemProto& RewardItemListProto::officerfragmentcarditem(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardItemListProto.officerFragmentCardItem)
  return officerfragmentcarditem_.Get(index);
}
inline ::main::OfficerFragmentCardItemProto* RewardItemListProto::mutable_officerfragmentcarditem(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardItemListProto.officerFragmentCardItem)
  return officerfragmentcarditem_.Mutable(index);
}
inline ::main::OfficerFragmentCardItemProto* RewardItemListProto::add_officerfragmentcarditem() {
  // @@protoc_insertion_point(field_add:main.RewardItemListProto.officerFragmentCardItem)
  return officerfragmentcarditem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::OfficerFragmentCardItemProto >&
RewardItemListProto::officerfragmentcarditem() const {
  // @@protoc_insertion_point(field_list:main.RewardItemListProto.officerFragmentCardItem)
  return officerfragmentcarditem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::OfficerFragmentCardItemProto >*
RewardItemListProto::mutable_officerfragmentcarditem() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardItemListProto.officerFragmentCardItem)
  return &officerfragmentcarditem_;
}

// -------------------------------------------------------------------

// RewardBindAccountInfoRequest

// -------------------------------------------------------------------

// RewardBindAccountInfoResponse

// optional int32 state = 1;
inline bool RewardBindAccountInfoResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardBindAccountInfoResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardBindAccountInfoResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardBindAccountInfoResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RewardBindAccountInfoResponse::state() const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountInfoResponse.state)
  return state_;
}
inline void RewardBindAccountInfoResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RewardBindAccountInfoResponse.state)
}

// repeated .main.RewardInfoProto rewardInfo = 2;
inline int RewardBindAccountInfoResponse::rewardinfo_size() const {
  return rewardinfo_.size();
}
inline void RewardBindAccountInfoResponse::clear_rewardinfo() {
  rewardinfo_.Clear();
}
inline const ::main::RewardInfoProto& RewardBindAccountInfoResponse::rewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountInfoResponse.rewardInfo)
  return rewardinfo_.Get(index);
}
inline ::main::RewardInfoProto* RewardBindAccountInfoResponse::mutable_rewardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardBindAccountInfoResponse.rewardInfo)
  return rewardinfo_.Mutable(index);
}
inline ::main::RewardInfoProto* RewardBindAccountInfoResponse::add_rewardinfo() {
  // @@protoc_insertion_point(field_add:main.RewardBindAccountInfoResponse.rewardInfo)
  return rewardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
RewardBindAccountInfoResponse::rewardinfo() const {
  // @@protoc_insertion_point(field_list:main.RewardBindAccountInfoResponse.rewardInfo)
  return rewardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
RewardBindAccountInfoResponse::mutable_rewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardBindAccountInfoResponse.rewardInfo)
  return &rewardinfo_;
}

// optional int32 mailState = 3;
inline bool RewardBindAccountInfoResponse::has_mailstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardBindAccountInfoResponse::set_has_mailstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardBindAccountInfoResponse::clear_has_mailstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardBindAccountInfoResponse::clear_mailstate() {
  mailstate_ = 0;
  clear_has_mailstate();
}
inline ::google::protobuf::int32 RewardBindAccountInfoResponse::mailstate() const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountInfoResponse.mailState)
  return mailstate_;
}
inline void RewardBindAccountInfoResponse::set_mailstate(::google::protobuf::int32 value) {
  set_has_mailstate();
  mailstate_ = value;
  // @@protoc_insertion_point(field_set:main.RewardBindAccountInfoResponse.mailState)
}

// optional string mail = 4;
inline bool RewardBindAccountInfoResponse::has_mail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewardBindAccountInfoResponse::set_has_mail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewardBindAccountInfoResponse::clear_has_mail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewardBindAccountInfoResponse::clear_mail() {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_->clear();
  }
  clear_has_mail();
}
inline const ::std::string& RewardBindAccountInfoResponse::mail() const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountInfoResponse.mail)
  return *mail_;
}
inline void RewardBindAccountInfoResponse::set_mail(const ::std::string& value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
  // @@protoc_insertion_point(field_set:main.RewardBindAccountInfoResponse.mail)
}
inline void RewardBindAccountInfoResponse::set_mail(const char* value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.RewardBindAccountInfoResponse.mail)
}
inline void RewardBindAccountInfoResponse::set_mail(const char* value, size_t size) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.RewardBindAccountInfoResponse.mail)
}
inline ::std::string* RewardBindAccountInfoResponse::mutable_mail() {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.RewardBindAccountInfoResponse.mail)
  return mail_;
}
inline ::std::string* RewardBindAccountInfoResponse::release_mail() {
  clear_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mail_;
    mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RewardBindAccountInfoResponse::set_allocated_mail(::std::string* mail) {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_;
  }
  if (mail) {
    set_has_mail();
    mail_ = mail;
  } else {
    clear_has_mail();
    mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.RewardBindAccountInfoResponse.mail)
}

// repeated .main.RewardInfoProto mailRewardInfo = 5;
inline int RewardBindAccountInfoResponse::mailrewardinfo_size() const {
  return mailrewardinfo_.size();
}
inline void RewardBindAccountInfoResponse::clear_mailrewardinfo() {
  mailrewardinfo_.Clear();
}
inline const ::main::RewardInfoProto& RewardBindAccountInfoResponse::mailrewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.RewardBindAccountInfoResponse.mailRewardInfo)
  return mailrewardinfo_.Get(index);
}
inline ::main::RewardInfoProto* RewardBindAccountInfoResponse::mutable_mailrewardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.RewardBindAccountInfoResponse.mailRewardInfo)
  return mailrewardinfo_.Mutable(index);
}
inline ::main::RewardInfoProto* RewardBindAccountInfoResponse::add_mailrewardinfo() {
  // @@protoc_insertion_point(field_add:main.RewardBindAccountInfoResponse.mailRewardInfo)
  return mailrewardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
RewardBindAccountInfoResponse::mailrewardinfo() const {
  // @@protoc_insertion_point(field_list:main.RewardBindAccountInfoResponse.mailRewardInfo)
  return mailrewardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
RewardBindAccountInfoResponse::mutable_mailrewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.RewardBindAccountInfoResponse.mailRewardInfo)
  return &mailrewardinfo_;
}

// -------------------------------------------------------------------

// BindMailRequest

// optional int32 state = 1;
inline bool BindMailRequest::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindMailRequest::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindMailRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindMailRequest::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 BindMailRequest::state() const {
  // @@protoc_insertion_point(field_get:main.BindMailRequest.state)
  return state_;
}
inline void BindMailRequest::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.BindMailRequest.state)
}

// optional string mail = 2;
inline bool BindMailRequest::has_mail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindMailRequest::set_has_mail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindMailRequest::clear_has_mail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindMailRequest::clear_mail() {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_->clear();
  }
  clear_has_mail();
}
inline const ::std::string& BindMailRequest::mail() const {
  // @@protoc_insertion_point(field_get:main.BindMailRequest.mail)
  return *mail_;
}
inline void BindMailRequest::set_mail(const ::std::string& value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
  // @@protoc_insertion_point(field_set:main.BindMailRequest.mail)
}
inline void BindMailRequest::set_mail(const char* value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BindMailRequest.mail)
}
inline void BindMailRequest::set_mail(const char* value, size_t size) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  mail_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BindMailRequest.mail)
}
inline ::std::string* BindMailRequest::mutable_mail() {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BindMailRequest.mail)
  return mail_;
}
inline ::std::string* BindMailRequest::release_mail() {
  clear_has_mail();
  if (mail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mail_;
    mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindMailRequest::set_allocated_mail(::std::string* mail) {
  if (mail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_;
  }
  if (mail) {
    set_has_mail();
    mail_ = mail;
  } else {
    clear_has_mail();
    mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BindMailRequest.mail)
}

// -------------------------------------------------------------------

// BindMailResponse

// optional int32 state = 1;
inline bool BindMailResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindMailResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindMailResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindMailResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 BindMailResponse::state() const {
  // @@protoc_insertion_point(field_get:main.BindMailResponse.state)
  return state_;
}
inline void BindMailResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.BindMailResponse.state)
}

// -------------------------------------------------------------------

// RewardBindMailRequest

// -------------------------------------------------------------------

// RewardBindMailResponse

// optional int32 state = 1;
inline bool RewardBindMailResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardBindMailResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardBindMailResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardBindMailResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RewardBindMailResponse::state() const {
  // @@protoc_insertion_point(field_get:main.RewardBindMailResponse.state)
  return state_;
}
inline void RewardBindMailResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RewardBindMailResponse.state)
}

// optional .main.RewardItemListProto itemList = 2;
inline bool RewardBindMailResponse::has_itemlist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardBindMailResponse::set_has_itemlist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardBindMailResponse::clear_has_itemlist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardBindMailResponse::clear_itemlist() {
  if (itemlist_ != NULL) itemlist_->::main::RewardItemListProto::Clear();
  clear_has_itemlist();
}
inline const ::main::RewardItemListProto& RewardBindMailResponse::itemlist() const {
  // @@protoc_insertion_point(field_get:main.RewardBindMailResponse.itemList)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemlist_ != NULL ? *itemlist_ : *default_instance().itemlist_;
#else
  return itemlist_ != NULL ? *itemlist_ : *default_instance_->itemlist_;
#endif
}
inline ::main::RewardItemListProto* RewardBindMailResponse::mutable_itemlist() {
  set_has_itemlist();
  if (itemlist_ == NULL) itemlist_ = new ::main::RewardItemListProto;
  // @@protoc_insertion_point(field_mutable:main.RewardBindMailResponse.itemList)
  return itemlist_;
}
inline ::main::RewardItemListProto* RewardBindMailResponse::release_itemlist() {
  clear_has_itemlist();
  ::main::RewardItemListProto* temp = itemlist_;
  itemlist_ = NULL;
  return temp;
}
inline void RewardBindMailResponse::set_allocated_itemlist(::main::RewardItemListProto* itemlist) {
  delete itemlist_;
  itemlist_ = itemlist;
  if (itemlist) {
    set_has_itemlist();
  } else {
    clear_has_itemlist();
  }
  // @@protoc_insertion_point(field_set_allocated:main.RewardBindMailResponse.itemList)
}

// -------------------------------------------------------------------

// ExchangeCodeEntryRequest

// -------------------------------------------------------------------

// ExchangeCodeEntryResponse

// repeated string info = 1;
inline int ExchangeCodeEntryResponse::info_size() const {
  return info_.size();
}
inline void ExchangeCodeEntryResponse::clear_info() {
  info_.Clear();
}
inline const ::std::string& ExchangeCodeEntryResponse::info(int index) const {
  // @@protoc_insertion_point(field_get:main.ExchangeCodeEntryResponse.info)
  return info_.Get(index);
}
inline ::std::string* ExchangeCodeEntryResponse::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:main.ExchangeCodeEntryResponse.info)
  return info_.Mutable(index);
}
inline void ExchangeCodeEntryResponse::set_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:main.ExchangeCodeEntryResponse.info)
  info_.Mutable(index)->assign(value);
}
inline void ExchangeCodeEntryResponse::set_info(int index, const char* value) {
  info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ExchangeCodeEntryResponse.info)
}
inline void ExchangeCodeEntryResponse::set_info(int index, const char* value, size_t size) {
  info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ExchangeCodeEntryResponse.info)
}
inline ::std::string* ExchangeCodeEntryResponse::add_info() {
  return info_.Add();
}
inline void ExchangeCodeEntryResponse::add_info(const ::std::string& value) {
  info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:main.ExchangeCodeEntryResponse.info)
}
inline void ExchangeCodeEntryResponse::add_info(const char* value) {
  info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:main.ExchangeCodeEntryResponse.info)
}
inline void ExchangeCodeEntryResponse::add_info(const char* value, size_t size) {
  info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:main.ExchangeCodeEntryResponse.info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExchangeCodeEntryResponse::info() const {
  // @@protoc_insertion_point(field_list:main.ExchangeCodeEntryResponse.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExchangeCodeEntryResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:main.ExchangeCodeEntryResponse.info)
  return &info_;
}

// -------------------------------------------------------------------

// ExchangeCodeInfoRequest

// optional string code = 1;
inline bool ExchangeCodeInfoRequest::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeCodeInfoRequest::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeCodeInfoRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeCodeInfoRequest::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& ExchangeCodeInfoRequest::code() const {
  // @@protoc_insertion_point(field_get:main.ExchangeCodeInfoRequest.code)
  return *code_;
}
inline void ExchangeCodeInfoRequest::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:main.ExchangeCodeInfoRequest.code)
}
inline void ExchangeCodeInfoRequest::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ExchangeCodeInfoRequest.code)
}
inline void ExchangeCodeInfoRequest::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ExchangeCodeInfoRequest.code)
}
inline ::std::string* ExchangeCodeInfoRequest::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ExchangeCodeInfoRequest.code)
  return code_;
}
inline ::std::string* ExchangeCodeInfoRequest::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExchangeCodeInfoRequest::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ExchangeCodeInfoRequest.code)
}

// -------------------------------------------------------------------

// ExchangeCodeInfoResponse

// required int32 state = 1;
inline bool ExchangeCodeInfoResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeCodeInfoResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeCodeInfoResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeCodeInfoResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ExchangeCodeInfoResponse::state() const {
  // @@protoc_insertion_point(field_get:main.ExchangeCodeInfoResponse.state)
  return state_;
}
inline void ExchangeCodeInfoResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.ExchangeCodeInfoResponse.state)
}

// optional int32 rewardId = 2;
inline bool ExchangeCodeInfoResponse::has_rewardid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeCodeInfoResponse::set_has_rewardid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeCodeInfoResponse::clear_has_rewardid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeCodeInfoResponse::clear_rewardid() {
  rewardid_ = 0;
  clear_has_rewardid();
}
inline ::google::protobuf::int32 ExchangeCodeInfoResponse::rewardid() const {
  // @@protoc_insertion_point(field_get:main.ExchangeCodeInfoResponse.rewardId)
  return rewardid_;
}
inline void ExchangeCodeInfoResponse::set_rewardid(::google::protobuf::int32 value) {
  set_has_rewardid();
  rewardid_ = value;
  // @@protoc_insertion_point(field_set:main.ExchangeCodeInfoResponse.rewardId)
}

// repeated .main.RewardInfoProto rewardInfo = 3;
inline int ExchangeCodeInfoResponse::rewardinfo_size() const {
  return rewardinfo_.size();
}
inline void ExchangeCodeInfoResponse::clear_rewardinfo() {
  rewardinfo_.Clear();
}
inline const ::main::RewardInfoProto& ExchangeCodeInfoResponse::rewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.ExchangeCodeInfoResponse.rewardInfo)
  return rewardinfo_.Get(index);
}
inline ::main::RewardInfoProto* ExchangeCodeInfoResponse::mutable_rewardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.ExchangeCodeInfoResponse.rewardInfo)
  return rewardinfo_.Mutable(index);
}
inline ::main::RewardInfoProto* ExchangeCodeInfoResponse::add_rewardinfo() {
  // @@protoc_insertion_point(field_add:main.ExchangeCodeInfoResponse.rewardInfo)
  return rewardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >&
ExchangeCodeInfoResponse::rewardinfo() const {
  // @@protoc_insertion_point(field_list:main.ExchangeCodeInfoResponse.rewardInfo)
  return rewardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::RewardInfoProto >*
ExchangeCodeInfoResponse::mutable_rewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.ExchangeCodeInfoResponse.rewardInfo)
  return &rewardinfo_;
}

// -------------------------------------------------------------------

// RewardInfoProto

// optional int32 type = 1;
inline bool RewardInfoProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardInfoProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardInfoProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardInfoProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RewardInfoProto::type() const {
  // @@protoc_insertion_point(field_get:main.RewardInfoProto.type)
  return type_;
}
inline void RewardInfoProto::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.RewardInfoProto.type)
}

// optional int32 value = 2;
inline bool RewardInfoProto::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardInfoProto::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardInfoProto::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardInfoProto::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 RewardInfoProto::value() const {
  // @@protoc_insertion_point(field_get:main.RewardInfoProto.value)
  return value_;
}
inline void RewardInfoProto::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:main.RewardInfoProto.value)
}

// optional int32 number = 3;
inline bool RewardInfoProto::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardInfoProto::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardInfoProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardInfoProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 RewardInfoProto::number() const {
  // @@protoc_insertion_point(field_get:main.RewardInfoProto.number)
  return number_;
}
inline void RewardInfoProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:main.RewardInfoProto.number)
}

// -------------------------------------------------------------------

// FirstPayRewardResponse

// repeated .main.FirstPayRewardItemProto firstPayRewardItemProto = 1;
inline int FirstPayRewardResponse::firstpayrewarditemproto_size() const {
  return firstpayrewarditemproto_.size();
}
inline void FirstPayRewardResponse::clear_firstpayrewarditemproto() {
  firstpayrewarditemproto_.Clear();
}
inline const ::main::FirstPayRewardItemProto& FirstPayRewardResponse::firstpayrewarditemproto(int index) const {
  // @@protoc_insertion_point(field_get:main.FirstPayRewardResponse.firstPayRewardItemProto)
  return firstpayrewarditemproto_.Get(index);
}
inline ::main::FirstPayRewardItemProto* FirstPayRewardResponse::mutable_firstpayrewarditemproto(int index) {
  // @@protoc_insertion_point(field_mutable:main.FirstPayRewardResponse.firstPayRewardItemProto)
  return firstpayrewarditemproto_.Mutable(index);
}
inline ::main::FirstPayRewardItemProto* FirstPayRewardResponse::add_firstpayrewarditemproto() {
  // @@protoc_insertion_point(field_add:main.FirstPayRewardResponse.firstPayRewardItemProto)
  return firstpayrewarditemproto_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FirstPayRewardItemProto >&
FirstPayRewardResponse::firstpayrewarditemproto() const {
  // @@protoc_insertion_point(field_list:main.FirstPayRewardResponse.firstPayRewardItemProto)
  return firstpayrewarditemproto_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FirstPayRewardItemProto >*
FirstPayRewardResponse::mutable_firstpayrewarditemproto() {
  // @@protoc_insertion_point(field_mutable_list:main.FirstPayRewardResponse.firstPayRewardItemProto)
  return &firstpayrewarditemproto_;
}

// -------------------------------------------------------------------

// FirstPayRewardItemProto

// optional int32 itemType = 1;
inline bool FirstPayRewardItemProto::has_itemtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirstPayRewardItemProto::set_has_itemtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirstPayRewardItemProto::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirstPayRewardItemProto::clear_itemtype() {
  itemtype_ = 0;
  clear_has_itemtype();
}
inline ::google::protobuf::int32 FirstPayRewardItemProto::itemtype() const {
  // @@protoc_insertion_point(field_get:main.FirstPayRewardItemProto.itemType)
  return itemtype_;
}
inline void FirstPayRewardItemProto::set_itemtype(::google::protobuf::int32 value) {
  set_has_itemtype();
  itemtype_ = value;
  // @@protoc_insertion_point(field_set:main.FirstPayRewardItemProto.itemType)
}

// optional int32 itemId = 2;
inline bool FirstPayRewardItemProto::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FirstPayRewardItemProto::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FirstPayRewardItemProto::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FirstPayRewardItemProto::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 FirstPayRewardItemProto::itemid() const {
  // @@protoc_insertion_point(field_get:main.FirstPayRewardItemProto.itemId)
  return itemid_;
}
inline void FirstPayRewardItemProto::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:main.FirstPayRewardItemProto.itemId)
}

// optional int32 itemCount = 3;
inline bool FirstPayRewardItemProto::has_itemcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FirstPayRewardItemProto::set_has_itemcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FirstPayRewardItemProto::clear_has_itemcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FirstPayRewardItemProto::clear_itemcount() {
  itemcount_ = 0;
  clear_has_itemcount();
}
inline ::google::protobuf::int32 FirstPayRewardItemProto::itemcount() const {
  // @@protoc_insertion_point(field_get:main.FirstPayRewardItemProto.itemCount)
  return itemcount_;
}
inline void FirstPayRewardItemProto::set_itemcount(::google::protobuf::int32 value) {
  set_has_itemcount();
  itemcount_ = value;
  // @@protoc_insertion_point(field_set:main.FirstPayRewardItemProto.itemCount)
}

// optional int32 itemLevel = 4;
inline bool FirstPayRewardItemProto::has_itemlevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FirstPayRewardItemProto::set_has_itemlevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FirstPayRewardItemProto::clear_has_itemlevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FirstPayRewardItemProto::clear_itemlevel() {
  itemlevel_ = 0;
  clear_has_itemlevel();
}
inline ::google::protobuf::int32 FirstPayRewardItemProto::itemlevel() const {
  // @@protoc_insertion_point(field_get:main.FirstPayRewardItemProto.itemLevel)
  return itemlevel_;
}
inline void FirstPayRewardItemProto::set_itemlevel(::google::protobuf::int32 value) {
  set_has_itemlevel();
  itemlevel_ = value;
  // @@protoc_insertion_point(field_set:main.FirstPayRewardItemProto.itemLevel)
}

// -------------------------------------------------------------------

// SigninDetailRequest

// -------------------------------------------------------------------

// SigninDetailResponse

// repeated .main.SigninCell cells = 1;
inline int SigninDetailResponse::cells_size() const {
  return cells_.size();
}
inline void SigninDetailResponse::clear_cells() {
  cells_.Clear();
}
inline const ::main::SigninCell& SigninDetailResponse::cells(int index) const {
  // @@protoc_insertion_point(field_get:main.SigninDetailResponse.cells)
  return cells_.Get(index);
}
inline ::main::SigninCell* SigninDetailResponse::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:main.SigninDetailResponse.cells)
  return cells_.Mutable(index);
}
inline ::main::SigninCell* SigninDetailResponse::add_cells() {
  // @@protoc_insertion_point(field_add:main.SigninDetailResponse.cells)
  return cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::SigninCell >&
SigninDetailResponse::cells() const {
  // @@protoc_insertion_point(field_list:main.SigninDetailResponse.cells)
  return cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::SigninCell >*
SigninDetailResponse::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:main.SigninDetailResponse.cells)
  return &cells_;
}

// required int32 month = 2;
inline bool SigninDetailResponse::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninDetailResponse::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninDetailResponse::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninDetailResponse::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 SigninDetailResponse::month() const {
  // @@protoc_insertion_point(field_get:main.SigninDetailResponse.month)
  return month_;
}
inline void SigninDetailResponse::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:main.SigninDetailResponse.month)
}

// required int32 day = 3;
inline bool SigninDetailResponse::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SigninDetailResponse::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SigninDetailResponse::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SigninDetailResponse::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SigninDetailResponse::day() const {
  // @@protoc_insertion_point(field_get:main.SigninDetailResponse.day)
  return day_;
}
inline void SigninDetailResponse::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:main.SigninDetailResponse.day)
}

// -------------------------------------------------------------------

// SigninCell

// required .main.ItemDataProto itemData = 1;
inline bool SigninCell::has_itemdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninCell::set_has_itemdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninCell::clear_has_itemdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninCell::clear_itemdata() {
  if (itemdata_ != NULL) itemdata_->::main::ItemDataProto::Clear();
  clear_has_itemdata();
}
inline const ::main::ItemDataProto& SigninCell::itemdata() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.itemData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemdata_ != NULL ? *itemdata_ : *default_instance().itemdata_;
#else
  return itemdata_ != NULL ? *itemdata_ : *default_instance_->itemdata_;
#endif
}
inline ::main::ItemDataProto* SigninCell::mutable_itemdata() {
  set_has_itemdata();
  if (itemdata_ == NULL) itemdata_ = new ::main::ItemDataProto;
  // @@protoc_insertion_point(field_mutable:main.SigninCell.itemData)
  return itemdata_;
}
inline ::main::ItemDataProto* SigninCell::release_itemdata() {
  clear_has_itemdata();
  ::main::ItemDataProto* temp = itemdata_;
  itemdata_ = NULL;
  return temp;
}
inline void SigninCell::set_allocated_itemdata(::main::ItemDataProto* itemdata) {
  delete itemdata_;
  itemdata_ = itemdata;
  if (itemdata) {
    set_has_itemdata();
  } else {
    clear_has_itemdata();
  }
  // @@protoc_insertion_point(field_set_allocated:main.SigninCell.itemData)
}

// required .main.SignState state = 2;
inline bool SigninCell::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninCell::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninCell::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninCell::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::main::SignState SigninCell::state() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.state)
  return static_cast< ::main::SignState >(state_);
}
inline void SigninCell::set_state(::main::SignState value) {
  assert(::main::SignState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.SigninCell.state)
}

// required string showString = 3;
inline bool SigninCell::has_showstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SigninCell::set_has_showstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SigninCell::clear_has_showstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SigninCell::clear_showstring() {
  if (showstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    showstring_->clear();
  }
  clear_has_showstring();
}
inline const ::std::string& SigninCell::showstring() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.showString)
  return *showstring_;
}
inline void SigninCell::set_showstring(const ::std::string& value) {
  set_has_showstring();
  if (showstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    showstring_ = new ::std::string;
  }
  showstring_->assign(value);
  // @@protoc_insertion_point(field_set:main.SigninCell.showString)
}
inline void SigninCell::set_showstring(const char* value) {
  set_has_showstring();
  if (showstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    showstring_ = new ::std::string;
  }
  showstring_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SigninCell.showString)
}
inline void SigninCell::set_showstring(const char* value, size_t size) {
  set_has_showstring();
  if (showstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    showstring_ = new ::std::string;
  }
  showstring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SigninCell.showString)
}
inline ::std::string* SigninCell::mutable_showstring() {
  set_has_showstring();
  if (showstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    showstring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SigninCell.showString)
  return showstring_;
}
inline ::std::string* SigninCell::release_showstring() {
  clear_has_showstring();
  if (showstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = showstring_;
    showstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SigninCell::set_allocated_showstring(::std::string* showstring) {
  if (showstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete showstring_;
  }
  if (showstring) {
    set_has_showstring();
    showstring_ = showstring;
  } else {
    clear_has_showstring();
    showstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SigninCell.showString)
}

// required int32 niubility = 4;
inline bool SigninCell::has_niubility() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SigninCell::set_has_niubility() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SigninCell::clear_has_niubility() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SigninCell::clear_niubility() {
  niubility_ = 0;
  clear_has_niubility();
}
inline ::google::protobuf::int32 SigninCell::niubility() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.niubility)
  return niubility_;
}
inline void SigninCell::set_niubility(::google::protobuf::int32 value) {
  set_has_niubility();
  niubility_ = value;
  // @@protoc_insertion_point(field_set:main.SigninCell.niubility)
}

// required string itemDesc = 5;
inline bool SigninCell::has_itemdesc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SigninCell::set_has_itemdesc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SigninCell::clear_has_itemdesc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SigninCell::clear_itemdesc() {
  if (itemdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemdesc_->clear();
  }
  clear_has_itemdesc();
}
inline const ::std::string& SigninCell::itemdesc() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.itemDesc)
  return *itemdesc_;
}
inline void SigninCell::set_itemdesc(const ::std::string& value) {
  set_has_itemdesc();
  if (itemdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemdesc_ = new ::std::string;
  }
  itemdesc_->assign(value);
  // @@protoc_insertion_point(field_set:main.SigninCell.itemDesc)
}
inline void SigninCell::set_itemdesc(const char* value) {
  set_has_itemdesc();
  if (itemdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemdesc_ = new ::std::string;
  }
  itemdesc_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SigninCell.itemDesc)
}
inline void SigninCell::set_itemdesc(const char* value, size_t size) {
  set_has_itemdesc();
  if (itemdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemdesc_ = new ::std::string;
  }
  itemdesc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SigninCell.itemDesc)
}
inline ::std::string* SigninCell::mutable_itemdesc() {
  set_has_itemdesc();
  if (itemdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemdesc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SigninCell.itemDesc)
  return itemdesc_;
}
inline ::std::string* SigninCell::release_itemdesc() {
  clear_has_itemdesc();
  if (itemdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemdesc_;
    itemdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SigninCell::set_allocated_itemdesc(::std::string* itemdesc) {
  if (itemdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemdesc_;
  }
  if (itemdesc) {
    set_has_itemdesc();
    itemdesc_ = itemdesc;
  } else {
    clear_has_itemdesc();
    itemdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SigninCell.itemDesc)
}

// required string vipDesc = 6;
inline bool SigninCell::has_vipdesc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SigninCell::set_has_vipdesc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SigninCell::clear_has_vipdesc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SigninCell::clear_vipdesc() {
  if (vipdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vipdesc_->clear();
  }
  clear_has_vipdesc();
}
inline const ::std::string& SigninCell::vipdesc() const {
  // @@protoc_insertion_point(field_get:main.SigninCell.vipDesc)
  return *vipdesc_;
}
inline void SigninCell::set_vipdesc(const ::std::string& value) {
  set_has_vipdesc();
  if (vipdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vipdesc_ = new ::std::string;
  }
  vipdesc_->assign(value);
  // @@protoc_insertion_point(field_set:main.SigninCell.vipDesc)
}
inline void SigninCell::set_vipdesc(const char* value) {
  set_has_vipdesc();
  if (vipdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vipdesc_ = new ::std::string;
  }
  vipdesc_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SigninCell.vipDesc)
}
inline void SigninCell::set_vipdesc(const char* value, size_t size) {
  set_has_vipdesc();
  if (vipdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vipdesc_ = new ::std::string;
  }
  vipdesc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SigninCell.vipDesc)
}
inline ::std::string* SigninCell::mutable_vipdesc() {
  set_has_vipdesc();
  if (vipdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vipdesc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SigninCell.vipDesc)
  return vipdesc_;
}
inline ::std::string* SigninCell::release_vipdesc() {
  clear_has_vipdesc();
  if (vipdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vipdesc_;
    vipdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SigninCell::set_allocated_vipdesc(::std::string* vipdesc) {
  if (vipdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vipdesc_;
  }
  if (vipdesc) {
    set_has_vipdesc();
    vipdesc_ = vipdesc;
  } else {
    clear_has_vipdesc();
    vipdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SigninCell.vipDesc)
}

// -------------------------------------------------------------------

// SigninRewardRequest

// -------------------------------------------------------------------

// SigninRewardResponse

// required int32 rewardState = 1;
inline bool SigninRewardResponse::has_rewardstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninRewardResponse::set_has_rewardstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninRewardResponse::clear_has_rewardstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninRewardResponse::clear_rewardstate() {
  rewardstate_ = 0;
  clear_has_rewardstate();
}
inline ::google::protobuf::int32 SigninRewardResponse::rewardstate() const {
  // @@protoc_insertion_point(field_get:main.SigninRewardResponse.rewardState)
  return rewardstate_;
}
inline void SigninRewardResponse::set_rewardstate(::google::protobuf::int32 value) {
  set_has_rewardstate();
  rewardstate_ = value;
  // @@protoc_insertion_point(field_set:main.SigninRewardResponse.rewardState)
}

// required .main.ItemDataProto itemData = 2;
inline bool SigninRewardResponse::has_itemdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninRewardResponse::set_has_itemdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninRewardResponse::clear_has_itemdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninRewardResponse::clear_itemdata() {
  if (itemdata_ != NULL) itemdata_->::main::ItemDataProto::Clear();
  clear_has_itemdata();
}
inline const ::main::ItemDataProto& SigninRewardResponse::itemdata() const {
  // @@protoc_insertion_point(field_get:main.SigninRewardResponse.itemData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemdata_ != NULL ? *itemdata_ : *default_instance().itemdata_;
#else
  return itemdata_ != NULL ? *itemdata_ : *default_instance_->itemdata_;
#endif
}
inline ::main::ItemDataProto* SigninRewardResponse::mutable_itemdata() {
  set_has_itemdata();
  if (itemdata_ == NULL) itemdata_ = new ::main::ItemDataProto;
  // @@protoc_insertion_point(field_mutable:main.SigninRewardResponse.itemData)
  return itemdata_;
}
inline ::main::ItemDataProto* SigninRewardResponse::release_itemdata() {
  clear_has_itemdata();
  ::main::ItemDataProto* temp = itemdata_;
  itemdata_ = NULL;
  return temp;
}
inline void SigninRewardResponse::set_allocated_itemdata(::main::ItemDataProto* itemdata) {
  delete itemdata_;
  itemdata_ = itemdata;
  if (itemdata) {
    set_has_itemdata();
  } else {
    clear_has_itemdata();
  }
  // @@protoc_insertion_point(field_set_allocated:main.SigninRewardResponse.itemData)
}

// required int32 day = 3;
inline bool SigninRewardResponse::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SigninRewardResponse::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SigninRewardResponse::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SigninRewardResponse::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SigninRewardResponse::day() const {
  // @@protoc_insertion_point(field_get:main.SigninRewardResponse.day)
  return day_;
}
inline void SigninRewardResponse::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:main.SigninRewardResponse.day)
}

// required .main.SignState cellState = 4;
inline bool SigninRewardResponse::has_cellstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SigninRewardResponse::set_has_cellstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SigninRewardResponse::clear_has_cellstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SigninRewardResponse::clear_cellstate() {
  cellstate_ = 0;
  clear_has_cellstate();
}
inline ::main::SignState SigninRewardResponse::cellstate() const {
  // @@protoc_insertion_point(field_get:main.SigninRewardResponse.cellState)
  return static_cast< ::main::SignState >(cellstate_);
}
inline void SigninRewardResponse::set_cellstate(::main::SignState value) {
  assert(::main::SignState_IsValid(value));
  set_has_cellstate();
  cellstate_ = value;
  // @@protoc_insertion_point(field_set:main.SigninRewardResponse.cellState)
}

// required int32 niubility = 5;
inline bool SigninRewardResponse::has_niubility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SigninRewardResponse::set_has_niubility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SigninRewardResponse::clear_has_niubility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SigninRewardResponse::clear_niubility() {
  niubility_ = 0;
  clear_has_niubility();
}
inline ::google::protobuf::int32 SigninRewardResponse::niubility() const {
  // @@protoc_insertion_point(field_get:main.SigninRewardResponse.niubility)
  return niubility_;
}
inline void SigninRewardResponse::set_niubility(::google::protobuf::int32 value) {
  set_has_niubility();
  niubility_ = value;
  // @@protoc_insertion_point(field_set:main.SigninRewardResponse.niubility)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RewardModule_2eproto__INCLUDED

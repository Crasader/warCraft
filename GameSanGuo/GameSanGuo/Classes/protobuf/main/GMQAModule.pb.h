// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GMQAModule.proto

#ifndef PROTOBUF_GMQAModule_2eproto__INCLUDED
#define PROTOBUF_GMQAModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GMQAModule_2eproto();
void protobuf_AssignDesc_GMQAModule_2eproto();
void protobuf_ShutdownFile_GMQAModule_2eproto();

class QAProto;
class UpdateQAResponse;
class CheckQARequest;
class CheckQAResponse;
class AnswerProto;
class SubQARequest;
class SubQAResponse;
class DelQARequest;
class DelQAResponse;
class AppendQuestionRequest;
class AppendQuestionResponse;

// ===================================================================

class QAProto : public ::google::protobuf::MessageLite {
 public:
  QAProto();
  virtual ~QAProto();

  QAProto(const QAProto& from);

  inline QAProto& operator=(const QAProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QAProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QAProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QAProto* other);

  // implements Message ----------------------------------------------

  QAProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QAProto& from);
  void MergeFrom(const QAProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string createDate = 4;
  inline bool has_createdate() const;
  inline void clear_createdate();
  static const int kCreateDateFieldNumber = 4;
  inline const ::std::string& createdate() const;
  inline void set_createdate(const ::std::string& value);
  inline void set_createdate(const char* value);
  inline void set_createdate(const char* value, size_t size);
  inline ::std::string* mutable_createdate();
  inline ::std::string* release_createdate();
  inline void set_allocated_createdate(::std::string* createdate);

  // optional int32 state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.QAProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_createdate();
  inline void clear_has_createdate();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::std::string* createdate_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static QAProto* default_instance_;
};
// -------------------------------------------------------------------

class UpdateQAResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateQAResponse();
  virtual ~UpdateQAResponse();

  UpdateQAResponse(const UpdateQAResponse& from);

  inline UpdateQAResponse& operator=(const UpdateQAResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateQAResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateQAResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateQAResponse* other);

  // implements Message ----------------------------------------------

  UpdateQAResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateQAResponse& from);
  void MergeFrom(const UpdateQAResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.UpdateQAResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static UpdateQAResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckQARequest : public ::google::protobuf::MessageLite {
 public:
  CheckQARequest();
  virtual ~CheckQARequest();

  CheckQARequest(const CheckQARequest& from);

  inline CheckQARequest& operator=(const CheckQARequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CheckQARequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckQARequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckQARequest* other);

  // implements Message ----------------------------------------------

  CheckQARequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckQARequest& from);
  void MergeFrom(const CheckQARequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.CheckQARequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static CheckQARequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckQAResponse : public ::google::protobuf::MessageLite {
 public:
  CheckQAResponse();
  virtual ~CheckQAResponse();

  CheckQAResponse(const CheckQAResponse& from);

  inline CheckQAResponse& operator=(const CheckQAResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CheckQAResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckQAResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckQAResponse* other);

  // implements Message ----------------------------------------------

  CheckQAResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckQAResponse& from);
  void MergeFrom(const CheckQAResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.AnswerProto answer = 1;
  inline int answer_size() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::main::AnswerProto& answer(int index) const;
  inline ::main::AnswerProto* mutable_answer(int index);
  inline ::main::AnswerProto* add_answer();
  inline const ::google::protobuf::RepeatedPtrField< ::main::AnswerProto >&
      answer() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::AnswerProto >*
      mutable_answer();

  // @@protoc_insertion_point(class_scope:main.CheckQAResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::AnswerProto > answer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static CheckQAResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnswerProto : public ::google::protobuf::MessageLite {
 public:
  AnswerProto();
  virtual ~AnswerProto();

  AnswerProto(const AnswerProto& from);

  inline AnswerProto& operator=(const AnswerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnswerProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnswerProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnswerProto* other);

  // implements Message ----------------------------------------------

  AnswerProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnswerProto& from);
  void MergeFrom(const AnswerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gmId = 1;
  inline bool has_gmid() const;
  inline void clear_gmid();
  static const int kGmIdFieldNumber = 1;
  inline ::google::protobuf::int32 gmid() const;
  inline void set_gmid(::google::protobuf::int32 value);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:main.AnswerProto)
 private:
  inline void set_has_gmid();
  inline void clear_has_gmid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_;
  ::std::string* content_;
  ::google::protobuf::int32 gmid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static AnswerProto* default_instance_;
};
// -------------------------------------------------------------------

class SubQARequest : public ::google::protobuf::MessageLite {
 public:
  SubQARequest();
  virtual ~SubQARequest();

  SubQARequest(const SubQARequest& from);

  inline SubQARequest& operator=(const SubQARequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SubQARequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SubQARequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SubQARequest* other);

  // implements Message ----------------------------------------------

  SubQARequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubQARequest& from);
  void MergeFrom(const SubQARequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string question = 3;
  inline bool has_question() const;
  inline void clear_question();
  static const int kQuestionFieldNumber = 3;
  inline const ::std::string& question() const;
  inline void set_question(const ::std::string& value);
  inline void set_question(const char* value);
  inline void set_question(const char* value, size_t size);
  inline ::std::string* mutable_question();
  inline ::std::string* release_question();
  inline void set_allocated_question(::std::string* question);

  // @@protoc_insertion_point(class_scope:main.SubQARequest)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_question();
  inline void clear_has_question();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* question_;
  ::google::protobuf::int32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static SubQARequest* default_instance_;
};
// -------------------------------------------------------------------

class SubQAResponse : public ::google::protobuf::MessageLite {
 public:
  SubQAResponse();
  virtual ~SubQAResponse();

  SubQAResponse(const SubQAResponse& from);

  inline SubQAResponse& operator=(const SubQAResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SubQAResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SubQAResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SubQAResponse* other);

  // implements Message ----------------------------------------------

  SubQAResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubQAResponse& from);
  void MergeFrom(const SubQAResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string createDate = 5;
  inline bool has_createdate() const;
  inline void clear_createdate();
  static const int kCreateDateFieldNumber = 5;
  inline const ::std::string& createdate() const;
  inline void set_createdate(const ::std::string& value);
  inline void set_createdate(const char* value);
  inline void set_createdate(const char* value, size_t size);
  inline ::std::string* mutable_createdate();
  inline ::std::string* release_createdate();
  inline void set_allocated_createdate(::std::string* createdate);

  // optional int32 questionstate = 6;
  inline bool has_questionstate() const;
  inline void clear_questionstate();
  static const int kQuestionstateFieldNumber = 6;
  inline ::google::protobuf::int32 questionstate() const;
  inline void set_questionstate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.SubQAResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_createdate();
  inline void clear_has_createdate();
  inline void set_has_questionstate();
  inline void clear_has_questionstate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 id_;
  ::std::string* title_;
  ::std::string* createdate_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 questionstate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static SubQAResponse* default_instance_;
};
// -------------------------------------------------------------------

class DelQARequest : public ::google::protobuf::MessageLite {
 public:
  DelQARequest();
  virtual ~DelQARequest();

  DelQARequest(const DelQARequest& from);

  inline DelQARequest& operator=(const DelQARequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DelQARequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DelQARequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DelQARequest* other);

  // implements Message ----------------------------------------------

  DelQARequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DelQARequest& from);
  void MergeFrom(const DelQARequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.DelQARequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static DelQARequest* default_instance_;
};
// -------------------------------------------------------------------

class DelQAResponse : public ::google::protobuf::MessageLite {
 public:
  DelQAResponse();
  virtual ~DelQAResponse();

  DelQAResponse(const DelQAResponse& from);

  inline DelQAResponse& operator=(const DelQAResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DelQAResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DelQAResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DelQAResponse* other);

  // implements Message ----------------------------------------------

  DelQAResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DelQAResponse& from);
  void MergeFrom(const DelQAResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.DelQAResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static DelQAResponse* default_instance_;
};
// -------------------------------------------------------------------

class AppendQuestionRequest : public ::google::protobuf::MessageLite {
 public:
  AppendQuestionRequest();
  virtual ~AppendQuestionRequest();

  AppendQuestionRequest(const AppendQuestionRequest& from);

  inline AppendQuestionRequest& operator=(const AppendQuestionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AppendQuestionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AppendQuestionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AppendQuestionRequest* other);

  // implements Message ----------------------------------------------

  AppendQuestionRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AppendQuestionRequest& from);
  void MergeFrom(const AppendQuestionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:main.AppendQuestionRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static AppendQuestionRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppendQuestionResponse : public ::google::protobuf::MessageLite {
 public:
  AppendQuestionResponse();
  virtual ~AppendQuestionResponse();

  AppendQuestionResponse(const AppendQuestionResponse& from);

  inline AppendQuestionResponse& operator=(const AppendQuestionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AppendQuestionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AppendQuestionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AppendQuestionResponse* other);

  // implements Message ----------------------------------------------

  AppendQuestionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AppendQuestionResponse& from);
  void MergeFrom(const AppendQuestionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.AppendQuestionResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GMQAModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GMQAModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_GMQAModule_2eproto();
  friend void protobuf_ShutdownFile_GMQAModule_2eproto();

  void InitAsDefaultInstance();
  static AppendQuestionResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// QAProto

// optional int32 id = 1;
inline bool QAProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QAProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QAProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QAProto::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 QAProto::id() const {
  // @@protoc_insertion_point(field_get:main.QAProto.id)
  return id_;
}
inline void QAProto::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.QAProto.id)
}

// optional string title = 2;
inline bool QAProto::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QAProto::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QAProto::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QAProto::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& QAProto::title() const {
  // @@protoc_insertion_point(field_get:main.QAProto.title)
  return *title_;
}
inline void QAProto::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:main.QAProto.title)
}
inline void QAProto::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.QAProto.title)
}
inline void QAProto::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.QAProto.title)
}
inline ::std::string* QAProto::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.QAProto.title)
  return title_;
}
inline ::std::string* QAProto::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QAProto::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.QAProto.title)
}

// optional int32 type = 3;
inline bool QAProto::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QAProto::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QAProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QAProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 QAProto::type() const {
  // @@protoc_insertion_point(field_get:main.QAProto.type)
  return type_;
}
inline void QAProto::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.QAProto.type)
}

// optional string createDate = 4;
inline bool QAProto::has_createdate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QAProto::set_has_createdate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QAProto::clear_has_createdate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QAProto::clear_createdate() {
  if (createdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_->clear();
  }
  clear_has_createdate();
}
inline const ::std::string& QAProto::createdate() const {
  // @@protoc_insertion_point(field_get:main.QAProto.createDate)
  return *createdate_;
}
inline void QAProto::set_createdate(const ::std::string& value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
  // @@protoc_insertion_point(field_set:main.QAProto.createDate)
}
inline void QAProto::set_createdate(const char* value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.QAProto.createDate)
}
inline void QAProto::set_createdate(const char* value, size_t size) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.QAProto.createDate)
}
inline ::std::string* QAProto::mutable_createdate() {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.QAProto.createDate)
  return createdate_;
}
inline ::std::string* QAProto::release_createdate() {
  clear_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = createdate_;
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QAProto::set_allocated_createdate(::std::string* createdate) {
  if (createdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete createdate_;
  }
  if (createdate) {
    set_has_createdate();
    createdate_ = createdate;
  } else {
    clear_has_createdate();
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.QAProto.createDate)
}

// optional int32 state = 5;
inline bool QAProto::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QAProto::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QAProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QAProto::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 QAProto::state() const {
  // @@protoc_insertion_point(field_get:main.QAProto.state)
  return state_;
}
inline void QAProto::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.QAProto.state)
}

// -------------------------------------------------------------------

// UpdateQAResponse

// optional int32 id = 1;
inline bool UpdateQAResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateQAResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateQAResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateQAResponse::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UpdateQAResponse::id() const {
  // @@protoc_insertion_point(field_get:main.UpdateQAResponse.id)
  return id_;
}
inline void UpdateQAResponse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.UpdateQAResponse.id)
}

// -------------------------------------------------------------------

// CheckQARequest

// optional int32 id = 1;
inline bool CheckQARequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckQARequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckQARequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckQARequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CheckQARequest::id() const {
  // @@protoc_insertion_point(field_get:main.CheckQARequest.id)
  return id_;
}
inline void CheckQARequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.CheckQARequest.id)
}

// -------------------------------------------------------------------

// CheckQAResponse

// repeated .main.AnswerProto answer = 1;
inline int CheckQAResponse::answer_size() const {
  return answer_.size();
}
inline void CheckQAResponse::clear_answer() {
  answer_.Clear();
}
inline const ::main::AnswerProto& CheckQAResponse::answer(int index) const {
  // @@protoc_insertion_point(field_get:main.CheckQAResponse.answer)
  return answer_.Get(index);
}
inline ::main::AnswerProto* CheckQAResponse::mutable_answer(int index) {
  // @@protoc_insertion_point(field_mutable:main.CheckQAResponse.answer)
  return answer_.Mutable(index);
}
inline ::main::AnswerProto* CheckQAResponse::add_answer() {
  // @@protoc_insertion_point(field_add:main.CheckQAResponse.answer)
  return answer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::AnswerProto >&
CheckQAResponse::answer() const {
  // @@protoc_insertion_point(field_list:main.CheckQAResponse.answer)
  return answer_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::AnswerProto >*
CheckQAResponse::mutable_answer() {
  // @@protoc_insertion_point(field_mutable_list:main.CheckQAResponse.answer)
  return &answer_;
}

// -------------------------------------------------------------------

// AnswerProto

// optional int32 gmId = 1;
inline bool AnswerProto::has_gmid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnswerProto::set_has_gmid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnswerProto::clear_has_gmid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnswerProto::clear_gmid() {
  gmid_ = 0;
  clear_has_gmid();
}
inline ::google::protobuf::int32 AnswerProto::gmid() const {
  // @@protoc_insertion_point(field_get:main.AnswerProto.gmId)
  return gmid_;
}
inline void AnswerProto::set_gmid(::google::protobuf::int32 value) {
  set_has_gmid();
  gmid_ = value;
  // @@protoc_insertion_point(field_set:main.AnswerProto.gmId)
}

// optional string time = 2;
inline bool AnswerProto::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnswerProto::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnswerProto::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnswerProto::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& AnswerProto::time() const {
  // @@protoc_insertion_point(field_get:main.AnswerProto.time)
  return *time_;
}
inline void AnswerProto::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:main.AnswerProto.time)
}
inline void AnswerProto::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AnswerProto.time)
}
inline void AnswerProto::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AnswerProto.time)
}
inline ::std::string* AnswerProto::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AnswerProto.time)
  return time_;
}
inline ::std::string* AnswerProto::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnswerProto::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AnswerProto.time)
}

// optional string content = 3;
inline bool AnswerProto::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnswerProto::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnswerProto::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnswerProto::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AnswerProto::content() const {
  // @@protoc_insertion_point(field_get:main.AnswerProto.content)
  return *content_;
}
inline void AnswerProto::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:main.AnswerProto.content)
}
inline void AnswerProto::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AnswerProto.content)
}
inline void AnswerProto::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AnswerProto.content)
}
inline ::std::string* AnswerProto::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AnswerProto.content)
  return content_;
}
inline ::std::string* AnswerProto::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnswerProto::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AnswerProto.content)
}

// -------------------------------------------------------------------

// SubQARequest

// optional string title = 1;
inline bool SubQARequest::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubQARequest::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubQARequest::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubQARequest::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SubQARequest::title() const {
  // @@protoc_insertion_point(field_get:main.SubQARequest.title)
  return *title_;
}
inline void SubQARequest::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:main.SubQARequest.title)
}
inline void SubQARequest::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SubQARequest.title)
}
inline void SubQARequest::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SubQARequest.title)
}
inline ::std::string* SubQARequest::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SubQARequest.title)
  return title_;
}
inline ::std::string* SubQARequest::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubQARequest::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SubQARequest.title)
}

// optional int32 type = 2;
inline bool SubQARequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubQARequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubQARequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubQARequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SubQARequest::type() const {
  // @@protoc_insertion_point(field_get:main.SubQARequest.type)
  return type_;
}
inline void SubQARequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.SubQARequest.type)
}

// optional string question = 3;
inline bool SubQARequest::has_question() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubQARequest::set_has_question() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubQARequest::clear_has_question() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubQARequest::clear_question() {
  if (question_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    question_->clear();
  }
  clear_has_question();
}
inline const ::std::string& SubQARequest::question() const {
  // @@protoc_insertion_point(field_get:main.SubQARequest.question)
  return *question_;
}
inline void SubQARequest::set_question(const ::std::string& value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    question_ = new ::std::string;
  }
  question_->assign(value);
  // @@protoc_insertion_point(field_set:main.SubQARequest.question)
}
inline void SubQARequest::set_question(const char* value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    question_ = new ::std::string;
  }
  question_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SubQARequest.question)
}
inline void SubQARequest::set_question(const char* value, size_t size) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    question_ = new ::std::string;
  }
  question_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SubQARequest.question)
}
inline ::std::string* SubQARequest::mutable_question() {
  set_has_question();
  if (question_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    question_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SubQARequest.question)
  return question_;
}
inline ::std::string* SubQARequest::release_question() {
  clear_has_question();
  if (question_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = question_;
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubQARequest::set_allocated_question(::std::string* question) {
  if (question_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete question_;
  }
  if (question) {
    set_has_question();
    question_ = question;
  } else {
    clear_has_question();
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SubQARequest.question)
}

// -------------------------------------------------------------------

// SubQAResponse

// optional int32 state = 1;
inline bool SubQAResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubQAResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubQAResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubQAResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 SubQAResponse::state() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.state)
  return state_;
}
inline void SubQAResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.SubQAResponse.state)
}

// optional int32 id = 2;
inline bool SubQAResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubQAResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubQAResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubQAResponse::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SubQAResponse::id() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.id)
  return id_;
}
inline void SubQAResponse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.SubQAResponse.id)
}

// optional string title = 3;
inline bool SubQAResponse::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubQAResponse::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubQAResponse::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubQAResponse::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SubQAResponse::title() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.title)
  return *title_;
}
inline void SubQAResponse::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:main.SubQAResponse.title)
}
inline void SubQAResponse::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SubQAResponse.title)
}
inline void SubQAResponse::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SubQAResponse.title)
}
inline ::std::string* SubQAResponse::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SubQAResponse.title)
  return title_;
}
inline ::std::string* SubQAResponse::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubQAResponse::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SubQAResponse.title)
}

// optional int32 type = 4;
inline bool SubQAResponse::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubQAResponse::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubQAResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubQAResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SubQAResponse::type() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.type)
  return type_;
}
inline void SubQAResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.SubQAResponse.type)
}

// optional string createDate = 5;
inline bool SubQAResponse::has_createdate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubQAResponse::set_has_createdate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubQAResponse::clear_has_createdate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubQAResponse::clear_createdate() {
  if (createdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_->clear();
  }
  clear_has_createdate();
}
inline const ::std::string& SubQAResponse::createdate() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.createDate)
  return *createdate_;
}
inline void SubQAResponse::set_createdate(const ::std::string& value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
  // @@protoc_insertion_point(field_set:main.SubQAResponse.createDate)
}
inline void SubQAResponse::set_createdate(const char* value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.SubQAResponse.createDate)
}
inline void SubQAResponse::set_createdate(const char* value, size_t size) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.SubQAResponse.createDate)
}
inline ::std::string* SubQAResponse::mutable_createdate() {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.SubQAResponse.createDate)
  return createdate_;
}
inline ::std::string* SubQAResponse::release_createdate() {
  clear_has_createdate();
  if (createdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = createdate_;
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubQAResponse::set_allocated_createdate(::std::string* createdate) {
  if (createdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete createdate_;
  }
  if (createdate) {
    set_has_createdate();
    createdate_ = createdate;
  } else {
    clear_has_createdate();
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.SubQAResponse.createDate)
}

// optional int32 questionstate = 6;
inline bool SubQAResponse::has_questionstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubQAResponse::set_has_questionstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubQAResponse::clear_has_questionstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubQAResponse::clear_questionstate() {
  questionstate_ = 0;
  clear_has_questionstate();
}
inline ::google::protobuf::int32 SubQAResponse::questionstate() const {
  // @@protoc_insertion_point(field_get:main.SubQAResponse.questionstate)
  return questionstate_;
}
inline void SubQAResponse::set_questionstate(::google::protobuf::int32 value) {
  set_has_questionstate();
  questionstate_ = value;
  // @@protoc_insertion_point(field_set:main.SubQAResponse.questionstate)
}

// -------------------------------------------------------------------

// DelQARequest

// optional int32 id = 1;
inline bool DelQARequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelQARequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelQARequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelQARequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DelQARequest::id() const {
  // @@protoc_insertion_point(field_get:main.DelQARequest.id)
  return id_;
}
inline void DelQARequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.DelQARequest.id)
}

// -------------------------------------------------------------------

// DelQAResponse

// optional int32 state = 1;
inline bool DelQAResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelQAResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelQAResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelQAResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 DelQAResponse::state() const {
  // @@protoc_insertion_point(field_get:main.DelQAResponse.state)
  return state_;
}
inline void DelQAResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.DelQAResponse.state)
}

// -------------------------------------------------------------------

// AppendQuestionRequest

// optional int32 id = 1;
inline bool AppendQuestionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendQuestionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendQuestionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendQuestionRequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AppendQuestionRequest::id() const {
  // @@protoc_insertion_point(field_get:main.AppendQuestionRequest.id)
  return id_;
}
inline void AppendQuestionRequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.AppendQuestionRequest.id)
}

// optional string content = 2;
inline bool AppendQuestionRequest::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendQuestionRequest::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendQuestionRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendQuestionRequest::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AppendQuestionRequest::content() const {
  // @@protoc_insertion_point(field_get:main.AppendQuestionRequest.content)
  return *content_;
}
inline void AppendQuestionRequest::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:main.AppendQuestionRequest.content)
}
inline void AppendQuestionRequest::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AppendQuestionRequest.content)
}
inline void AppendQuestionRequest::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AppendQuestionRequest.content)
}
inline ::std::string* AppendQuestionRequest::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AppendQuestionRequest.content)
  return content_;
}
inline ::std::string* AppendQuestionRequest::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AppendQuestionRequest::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AppendQuestionRequest.content)
}

// -------------------------------------------------------------------

// AppendQuestionResponse

// optional int32 state = 1;
inline bool AppendQuestionResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendQuestionResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendQuestionResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendQuestionResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 AppendQuestionResponse::state() const {
  // @@protoc_insertion_point(field_get:main.AppendQuestionResponse.state)
  return state_;
}
inline void AppendQuestionResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.AppendQuestionResponse.state)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GMQAModule_2eproto__INCLUDED

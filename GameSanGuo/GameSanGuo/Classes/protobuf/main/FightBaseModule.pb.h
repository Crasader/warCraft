// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FightBaseModule.proto

#ifndef PROTOBUF_FightBaseModule_2eproto__INCLUDED
#define PROTOBUF_FightBaseModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ItemModule.pb.h"
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FightBaseModule_2eproto();
void protobuf_AssignDesc_FightBaseModule_2eproto();
void protobuf_ShutdownFile_FightBaseModule_2eproto();

class FightMatrixRequest;
class FightMatrixResponse;
class StartStatePVPResponse;
class StartStatePVERequest;
class StartStatePVEResponse;
class StartStateItemModel;
class StartRequest;
class StartResponse;
class PveContinuePlayRequest;
class PveStarRequest;
class PveStarResponse;
class FillUnitRequest;
class FillUnitResponse;
class FillUnitReviveRequest;
class FillUnitReviveResponse;
class QiangZhiFillUnitRequest;
class QiangZhiFillUnitResponse;
class MoveRequest;
class MoveResponse;
class GiveUpRequest;
class GiveUpResponse;
class RemoveRequest;
class RemoveResponse;
class ActionCountResponse;
class FightSpirit;
class VerifyRequest;
class VerifyResponse;
class MajorSkillRequest;
class MajorSkillResponse;
class MajorSkillProto;
class CoordinateProto;
class CoordinateEffectProto;
class FightThtoughRewardRequest;
class FightRewardRequest;
class FightRewardResponse;
class FightRewardDropItems;
class FightRunAwayRequest;
class FightRunAwayResponse;
class EnemyExitResponse;
class EnemyResumeResponse;
class FightLogRequest;
class FightReviveRequest;
class FightReviveResponse;
class FightFixMapRequest;
class FightFixMapResponse;
class FightFixAttackUnit;
class FightFixBuff;
class EnterBossRequest;
class EnterBossResponse;
class BossBuffModel;
class BossRankModel;
class AtkBossRequest;
class AtkBossResponse;
class BossCurrStateRequest;
class BossCurrStateResponse;
class MainBossRequest;
class MainBossResponse;
class BossDamageRankRequest;
class BossDamageRankResponse;
class BossRankInfo;
class GetBossBuffRequest;
class GetBossBuffResponse;
class BossEndRewardResponse;
class FightPvpRewardRequest;
class FightPvpRewardResponse;

// ===================================================================

class FightMatrixRequest : public ::google::protobuf::MessageLite {
 public:
  FightMatrixRequest();
  virtual ~FightMatrixRequest();

  FightMatrixRequest(const FightMatrixRequest& from);

  inline FightMatrixRequest& operator=(const FightMatrixRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightMatrixRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightMatrixRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightMatrixRequest* other);

  // implements Message ----------------------------------------------

  FightMatrixRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightMatrixRequest& from);
  void MergeFrom(const FightMatrixRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.FightMatrixRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightMatrixRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightMatrixResponse : public ::google::protobuf::MessageLite {
 public:
  FightMatrixResponse();
  virtual ~FightMatrixResponse();

  FightMatrixResponse(const FightMatrixResponse& from);

  inline FightMatrixResponse& operator=(const FightMatrixResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightMatrixResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightMatrixResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightMatrixResponse* other);

  // implements Message ----------------------------------------------

  FightMatrixResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightMatrixResponse& from);
  void MergeFrom(const FightMatrixResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.FightSpirit spiritsYou = 1;
  inline int spiritsyou_size() const;
  inline void clear_spiritsyou();
  static const int kSpiritsYouFieldNumber = 1;
  inline const ::main::FightSpirit& spiritsyou(int index) const;
  inline ::main::FightSpirit* mutable_spiritsyou(int index);
  inline ::main::FightSpirit* add_spiritsyou();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritsyou() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritsyou();

  // repeated .main.FightSpirit spiritsHim = 2;
  inline int spiritshim_size() const;
  inline void clear_spiritshim();
  static const int kSpiritsHimFieldNumber = 2;
  inline const ::main::FightSpirit& spiritshim(int index) const;
  inline ::main::FightSpirit* mutable_spiritshim(int index);
  inline ::main::FightSpirit* add_spiritshim();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritshim() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritshim();

  // @@protoc_insertion_point(class_scope:main.FightMatrixResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritsyou_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritshim_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightMatrixResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartStatePVPResponse : public ::google::protobuf::MessageLite {
 public:
  StartStatePVPResponse();
  virtual ~StartStatePVPResponse();

  StartStatePVPResponse(const StartStatePVPResponse& from);

  inline StartStatePVPResponse& operator=(const StartStatePVPResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartStatePVPResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartStatePVPResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartStatePVPResponse* other);

  // implements Message ----------------------------------------------

  StartStatePVPResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartStatePVPResponse& from);
  void MergeFrom(const StartStatePVPResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string tname = 4;
  inline bool has_tname() const;
  inline void clear_tname();
  static const int kTnameFieldNumber = 4;
  inline const ::std::string& tname() const;
  inline void set_tname(const ::std::string& value);
  inline void set_tname(const char* value);
  inline void set_tname(const char* value, size_t size);
  inline ::std::string* mutable_tname();
  inline ::std::string* release_tname();
  inline void set_allocated_tname(::std::string* tname);

  // optional int32 image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline ::google::protobuf::int32 image() const;
  inline void set_image(::google::protobuf::int32 value);

  // optional int32 tImage = 6;
  inline bool has_timage() const;
  inline void clear_timage();
  static const int kTImageFieldNumber = 6;
  inline ::google::protobuf::int32 timage() const;
  inline void set_timage(::google::protobuf::int32 value);

  // optional int32 majorPosition = 7;
  inline bool has_majorposition() const;
  inline void clear_majorposition();
  static const int kMajorPositionFieldNumber = 7;
  inline ::google::protobuf::int32 majorposition() const;
  inline void set_majorposition(::google::protobuf::int32 value);

  // optional int32 tmajorPosition = 8;
  inline bool has_tmajorposition() const;
  inline void clear_tmajorposition();
  static const int kTmajorPositionFieldNumber = 8;
  inline ::google::protobuf::int32 tmajorposition() const;
  inline void set_tmajorposition(::google::protobuf::int32 value);

  // repeated .main.StartStateItemModel itemId = 9;
  inline int itemid_size() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 9;
  inline const ::main::StartStateItemModel& itemid(int index) const;
  inline ::main::StartStateItemModel* mutable_itemid(int index);
  inline ::main::StartStateItemModel* add_itemid();
  inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
      itemid() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
      mutable_itemid();

  // repeated .main.StartStateItemModel tItemId = 10;
  inline int titemid_size() const;
  inline void clear_titemid();
  static const int kTItemIdFieldNumber = 10;
  inline const ::main::StartStateItemModel& titemid(int index) const;
  inline ::main::StartStateItemModel* mutable_titemid(int index);
  inline ::main::StartStateItemModel* add_titemid();
  inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
      titemid() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
      mutable_titemid();

  // optional int32 nation = 11;
  inline bool has_nation() const;
  inline void clear_nation();
  static const int kNationFieldNumber = 11;
  inline ::google::protobuf::int32 nation() const;
  inline void set_nation(::google::protobuf::int32 value);

  // optional int32 tNation = 12;
  inline bool has_tnation() const;
  inline void clear_tnation();
  static const int kTNationFieldNumber = 12;
  inline ::google::protobuf::int32 tnation() const;
  inline void set_tnation(::google::protobuf::int32 value);

  // optional int32 isAI = 13;
  inline bool has_isai() const;
  inline void clear_isai();
  static const int kIsAIFieldNumber = 13;
  inline ::google::protobuf::int32 isai() const;
  inline void set_isai(::google::protobuf::int32 value);

  // optional int32 branchType = 14 [default = 201];
  inline bool has_branchtype() const;
  inline void clear_branchtype();
  static const int kBranchTypeFieldNumber = 14;
  inline ::google::protobuf::int32 branchtype() const;
  inline void set_branchtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.StartStatePVPResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tname();
  inline void clear_has_tname();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_timage();
  inline void clear_has_timage();
  inline void set_has_majorposition();
  inline void clear_has_majorposition();
  inline void set_has_tmajorposition();
  inline void clear_has_tmajorposition();
  inline void set_has_nation();
  inline void clear_has_nation();
  inline void set_has_tnation();
  inline void clear_has_tnation();
  inline void set_has_isai();
  inline void clear_has_isai();
  inline void set_has_branchtype();
  inline void clear_has_branchtype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::std::string* name_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 image_;
  ::std::string* tname_;
  ::google::protobuf::int32 timage_;
  ::google::protobuf::int32 majorposition_;
  ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel > itemid_;
  ::google::protobuf::int32 tmajorposition_;
  ::google::protobuf::int32 nation_;
  ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel > titemid_;
  ::google::protobuf::int32 tnation_;
  ::google::protobuf::int32 isai_;
  ::google::protobuf::int32 branchtype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartStatePVPResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartStatePVERequest : public ::google::protobuf::MessageLite {
 public:
  StartStatePVERequest();
  virtual ~StartStatePVERequest();

  StartStatePVERequest(const StartStatePVERequest& from);

  inline StartStatePVERequest& operator=(const StartStatePVERequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartStatePVERequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartStatePVERequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartStatePVERequest* other);

  // implements Message ----------------------------------------------

  StartStatePVERequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartStatePVERequest& from);
  void MergeFrom(const StartStatePVERequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 storyId = 1;
  inline bool has_storyid() const;
  inline void clear_storyid();
  static const int kStoryIdFieldNumber = 1;
  inline ::google::protobuf::int32 storyid() const;
  inline void set_storyid(::google::protobuf::int32 value);

  // optional int32 plotId = 2;
  inline bool has_plotid() const;
  inline void clear_plotid();
  static const int kPlotIdFieldNumber = 2;
  inline ::google::protobuf::int32 plotid() const;
  inline void set_plotid(::google::protobuf::int32 value);

  // optional int32 cooId = 3;
  inline bool has_cooid() const;
  inline void clear_cooid();
  static const int kCooIdFieldNumber = 3;
  inline ::google::protobuf::int32 cooid() const;
  inline void set_cooid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.StartStatePVERequest)
 private:
  inline void set_has_storyid();
  inline void clear_has_storyid();
  inline void set_has_plotid();
  inline void clear_has_plotid();
  inline void set_has_cooid();
  inline void clear_has_cooid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 storyid_;
  ::google::protobuf::int32 plotid_;
  ::google::protobuf::int32 cooid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartStatePVERequest* default_instance_;
};
// -------------------------------------------------------------------

class StartStatePVEResponse : public ::google::protobuf::MessageLite {
 public:
  StartStatePVEResponse();
  virtual ~StartStatePVEResponse();

  StartStatePVEResponse(const StartStatePVEResponse& from);

  inline StartStatePVEResponse& operator=(const StartStatePVEResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartStatePVEResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartStatePVEResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartStatePVEResponse* other);

  // implements Message ----------------------------------------------

  StartStatePVEResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartStatePVEResponse& from);
  void MergeFrom(const StartStatePVEResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string fightId = 2;
  inline bool has_fightid() const;
  inline void clear_fightid();
  static const int kFightIdFieldNumber = 2;
  inline const ::std::string& fightid() const;
  inline void set_fightid(const ::std::string& value);
  inline void set_fightid(const char* value);
  inline void set_fightid(const char* value, size_t size);
  inline ::std::string* mutable_fightid();
  inline ::std::string* release_fightid();
  inline void set_allocated_fightid(::std::string* fightid);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string tname = 4;
  inline bool has_tname() const;
  inline void clear_tname();
  static const int kTnameFieldNumber = 4;
  inline const ::std::string& tname() const;
  inline void set_tname(const ::std::string& value);
  inline void set_tname(const char* value);
  inline void set_tname(const char* value, size_t size);
  inline ::std::string* mutable_tname();
  inline ::std::string* release_tname();
  inline void set_allocated_tname(::std::string* tname);

  // optional int32 image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline ::google::protobuf::int32 image() const;
  inline void set_image(::google::protobuf::int32 value);

  // optional int32 tImage = 6;
  inline bool has_timage() const;
  inline void clear_timage();
  static const int kTImageFieldNumber = 6;
  inline ::google::protobuf::int32 timage() const;
  inline void set_timage(::google::protobuf::int32 value);

  // optional int32 majorPosition = 7;
  inline bool has_majorposition() const;
  inline void clear_majorposition();
  static const int kMajorPositionFieldNumber = 7;
  inline ::google::protobuf::int32 majorposition() const;
  inline void set_majorposition(::google::protobuf::int32 value);

  // optional int32 tmajorPosition = 8;
  inline bool has_tmajorposition() const;
  inline void clear_tmajorposition();
  static const int kTmajorPositionFieldNumber = 8;
  inline ::google::protobuf::int32 tmajorposition() const;
  inline void set_tmajorposition(::google::protobuf::int32 value);

  // repeated .main.StartStateItemModel item = 9;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 9;
  inline const ::main::StartStateItemModel& item(int index) const;
  inline ::main::StartStateItemModel* mutable_item(int index);
  inline ::main::StartStateItemModel* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
      mutable_item();

  // repeated .main.StartStateItemModel tItem = 10;
  inline int titem_size() const;
  inline void clear_titem();
  static const int kTItemFieldNumber = 10;
  inline const ::main::StartStateItemModel& titem(int index) const;
  inline ::main::StartStateItemModel* mutable_titem(int index);
  inline ::main::StartStateItemModel* add_titem();
  inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
      titem() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
      mutable_titem();

  // optional int32 nation = 11;
  inline bool has_nation() const;
  inline void clear_nation();
  static const int kNationFieldNumber = 11;
  inline ::google::protobuf::int32 nation() const;
  inline void set_nation(::google::protobuf::int32 value);

  // optional int32 tNation = 12;
  inline bool has_tnation() const;
  inline void clear_tnation();
  static const int kTNationFieldNumber = 12;
  inline ::google::protobuf::int32 tnation() const;
  inline void set_tnation(::google::protobuf::int32 value);

  // optional int32 branchType = 13 [default = 101];
  inline bool has_branchtype() const;
  inline void clear_branchtype();
  static const int kBranchTypeFieldNumber = 13;
  inline ::google::protobuf::int32 branchtype() const;
  inline void set_branchtype(::google::protobuf::int32 value);

  // optional int32 survivalLevel = 14 [default = -1];
  inline bool has_survivallevel() const;
  inline void clear_survivallevel();
  static const int kSurvivalLevelFieldNumber = 14;
  inline ::google::protobuf::int32 survivallevel() const;
  inline void set_survivallevel(::google::protobuf::int32 value);

  // optional bool needVerify = 15 [default = true];
  inline bool has_needverify() const;
  inline void clear_needverify();
  static const int kNeedVerifyFieldNumber = 15;
  inline bool needverify() const;
  inline void set_needverify(bool value);

  // @@protoc_insertion_point(class_scope:main.StartStatePVEResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_fightid();
  inline void clear_has_fightid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tname();
  inline void clear_has_tname();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_timage();
  inline void clear_has_timage();
  inline void set_has_majorposition();
  inline void clear_has_majorposition();
  inline void set_has_tmajorposition();
  inline void clear_has_tmajorposition();
  inline void set_has_nation();
  inline void clear_has_nation();
  inline void set_has_tnation();
  inline void clear_has_tnation();
  inline void set_has_branchtype();
  inline void clear_has_branchtype();
  inline void set_has_survivallevel();
  inline void clear_has_survivallevel();
  inline void set_has_needverify();
  inline void clear_has_needverify();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fightid_;
  ::std::string* name_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 image_;
  ::std::string* tname_;
  ::google::protobuf::int32 timage_;
  ::google::protobuf::int32 majorposition_;
  ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel > item_;
  ::google::protobuf::int32 tmajorposition_;
  ::google::protobuf::int32 nation_;
  ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel > titem_;
  ::google::protobuf::int32 tnation_;
  ::google::protobuf::int32 branchtype_;
  ::google::protobuf::int32 survivallevel_;
  bool needverify_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartStatePVEResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartStateItemModel : public ::google::protobuf::MessageLite {
 public:
  StartStateItemModel();
  virtual ~StartStateItemModel();

  StartStateItemModel(const StartStateItemModel& from);

  inline StartStateItemModel& operator=(const StartStateItemModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartStateItemModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartStateItemModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartStateItemModel* other);

  // implements Message ----------------------------------------------

  StartStateItemModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartStateItemModel& from);
  void MergeFrom(const StartStateItemModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemLevel = 2;
  inline bool has_itemlevel() const;
  inline void clear_itemlevel();
  static const int kItemLevelFieldNumber = 2;
  inline ::google::protobuf::int32 itemlevel() const;
  inline void set_itemlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.StartStateItemModel)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemlevel();
  inline void clear_has_itemlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartStateItemModel* default_instance_;
};
// -------------------------------------------------------------------

class StartRequest : public ::google::protobuf::MessageLite {
 public:
  StartRequest();
  virtual ~StartRequest();

  StartRequest(const StartRequest& from);

  inline StartRequest& operator=(const StartRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartRequest* other);

  // implements Message ----------------------------------------------

  StartRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartRequest& from);
  void MergeFrom(const StartRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 enemyRoleId = 1;
  inline bool has_enemyroleid() const;
  inline void clear_enemyroleid();
  static const int kEnemyRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 enemyroleid() const;
  inline void set_enemyroleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.StartRequest)
 private:
  inline void set_has_enemyroleid();
  inline void clear_has_enemyroleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 enemyroleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartResponse : public ::google::protobuf::MessageLite {
 public:
  StartResponse();
  virtual ~StartResponse();

  StartResponse(const StartResponse& from);

  inline StartResponse& operator=(const StartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartResponse* other);

  // implements Message ----------------------------------------------

  StartResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartResponse& from);
  void MergeFrom(const StartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // repeated .main.FightSpirit spiritsYou = 3;
  inline int spiritsyou_size() const;
  inline void clear_spiritsyou();
  static const int kSpiritsYouFieldNumber = 3;
  inline const ::main::FightSpirit& spiritsyou(int index) const;
  inline ::main::FightSpirit* mutable_spiritsyou(int index);
  inline ::main::FightSpirit* add_spiritsyou();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritsyou() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritsyou();

  // repeated .main.FightSpirit spiritsHim = 4;
  inline int spiritshim_size() const;
  inline void clear_spiritshim();
  static const int kSpiritsHimFieldNumber = 4;
  inline const ::main::FightSpirit& spiritshim(int index) const;
  inline ::main::FightSpirit* mutable_spiritshim(int index);
  inline ::main::FightSpirit* add_spiritshim();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritshim() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritshim();

  // optional bool isFirstAttack = 5;
  inline bool has_isfirstattack() const;
  inline void clear_isfirstattack();
  static const int kIsFirstAttackFieldNumber = 5;
  inline bool isfirstattack() const;
  inline void set_isfirstattack(bool value);

  // optional int32 youHp = 6;
  inline bool has_youhp() const;
  inline void clear_youhp();
  static const int kYouHpFieldNumber = 6;
  inline ::google::protobuf::int32 youhp() const;
  inline void set_youhp(::google::protobuf::int32 value);

  // optional int32 himHp = 7;
  inline bool has_himhp() const;
  inline void clear_himhp();
  static const int kHimHpFieldNumber = 7;
  inline ::google::protobuf::int32 himhp() const;
  inline void set_himhp(::google::protobuf::int32 value);

  // optional int32 youActionCount = 8;
  inline bool has_youactioncount() const;
  inline void clear_youactioncount();
  static const int kYouActionCountFieldNumber = 8;
  inline ::google::protobuf::int32 youactioncount() const;
  inline void set_youactioncount(::google::protobuf::int32 value);

  // optional int32 himActionCount = 9;
  inline bool has_himactioncount() const;
  inline void clear_himactioncount();
  static const int kHimActionCountFieldNumber = 9;
  inline ::google::protobuf::int32 himactioncount() const;
  inline void set_himactioncount(::google::protobuf::int32 value);

  // optional string fid = 10;
  inline bool has_fid() const;
  inline void clear_fid();
  static const int kFidFieldNumber = 10;
  inline const ::std::string& fid() const;
  inline void set_fid(const ::std::string& value);
  inline void set_fid(const char* value);
  inline void set_fid(const char* value, size_t size);
  inline ::std::string* mutable_fid();
  inline ::std::string* release_fid();
  inline void set_allocated_fid(::std::string* fid);

  // optional int32 lordId = 11;
  inline bool has_lordid() const;
  inline void clear_lordid();
  static const int kLordIdFieldNumber = 11;
  inline ::google::protobuf::int32 lordid() const;
  inline void set_lordid(::google::protobuf::int32 value);

  // optional string lordName = 12;
  inline bool has_lordname() const;
  inline void clear_lordname();
  static const int kLordNameFieldNumber = 12;
  inline const ::std::string& lordname() const;
  inline void set_lordname(const ::std::string& value);
  inline void set_lordname(const char* value);
  inline void set_lordname(const char* value, size_t size);
  inline ::std::string* mutable_lordname();
  inline ::std::string* release_lordname();
  inline void set_allocated_lordname(::std::string* lordname);

  // optional int32 lordSkillBelongId = 13;
  inline bool has_lordskillbelongid() const;
  inline void clear_lordskillbelongid();
  static const int kLordSkillBelongIdFieldNumber = 13;
  inline ::google::protobuf::int32 lordskillbelongid() const;
  inline void set_lordskillbelongid(::google::protobuf::int32 value);

  // optional int32 lordSkillId = 14;
  inline bool has_lordskillid() const;
  inline void clear_lordskillid();
  static const int kLordSkillIdFieldNumber = 14;
  inline ::google::protobuf::int32 lordskillid() const;
  inline void set_lordskillid(::google::protobuf::int32 value);

  // optional int32 tlordId = 15;
  inline bool has_tlordid() const;
  inline void clear_tlordid();
  static const int kTlordIdFieldNumber = 15;
  inline ::google::protobuf::int32 tlordid() const;
  inline void set_tlordid(::google::protobuf::int32 value);

  // optional string tlordName = 16;
  inline bool has_tlordname() const;
  inline void clear_tlordname();
  static const int kTlordNameFieldNumber = 16;
  inline const ::std::string& tlordname() const;
  inline void set_tlordname(const ::std::string& value);
  inline void set_tlordname(const char* value);
  inline void set_tlordname(const char* value, size_t size);
  inline ::std::string* mutable_tlordname();
  inline ::std::string* release_tlordname();
  inline void set_allocated_tlordname(::std::string* tlordname);

  // optional int32 tlordSkillBelongId = 17;
  inline bool has_tlordskillbelongid() const;
  inline void clear_tlordskillbelongid();
  static const int kTlordSkillBelongIdFieldNumber = 17;
  inline ::google::protobuf::int32 tlordskillbelongid() const;
  inline void set_tlordskillbelongid(::google::protobuf::int32 value);

  // optional int32 tlordSkillId = 18;
  inline bool has_tlordskillid() const;
  inline void clear_tlordskillid();
  static const int kTlordSkillIdFieldNumber = 18;
  inline ::google::protobuf::int32 tlordskillid() const;
  inline void set_tlordskillid(::google::protobuf::int32 value);

  // optional int32 tlordSkillLevel = 19;
  inline bool has_tlordskilllevel() const;
  inline void clear_tlordskilllevel();
  static const int kTlordSkillLevelFieldNumber = 19;
  inline ::google::protobuf::int32 tlordskilllevel() const;
  inline void set_tlordskilllevel(::google::protobuf::int32 value);

  // optional int32 lordCdRound = 20;
  inline bool has_lordcdround() const;
  inline void clear_lordcdround();
  static const int kLordCdRoundFieldNumber = 20;
  inline ::google::protobuf::int32 lordcdround() const;
  inline void set_lordcdround(::google::protobuf::int32 value);

  // optional int32 tlordCdRound = 21;
  inline bool has_tlordcdround() const;
  inline void clear_tlordcdround();
  static const int kTlordCdRoundFieldNumber = 21;
  inline ::google::protobuf::int32 tlordcdround() const;
  inline void set_tlordcdround(::google::protobuf::int32 value);

  // optional int32 clientType = 22;
  inline bool has_clienttype() const;
  inline void clear_clienttype();
  static const int kClientTypeFieldNumber = 22;
  inline ::google::protobuf::int32 clienttype() const;
  inline void set_clienttype(::google::protobuf::int32 value);

  // optional int32 nation = 23;
  inline bool has_nation() const;
  inline void clear_nation();
  static const int kNationFieldNumber = 23;
  inline ::google::protobuf::int32 nation() const;
  inline void set_nation(::google::protobuf::int32 value);

  // optional int32 tnation = 24;
  inline bool has_tnation() const;
  inline void clear_tnation();
  static const int kTnationFieldNumber = 24;
  inline ::google::protobuf::int32 tnation() const;
  inline void set_tnation(::google::protobuf::int32 value);

  // optional int32 lordAtkMode = 25;
  inline bool has_lordatkmode() const;
  inline void clear_lordatkmode();
  static const int kLordAtkModeFieldNumber = 25;
  inline ::google::protobuf::int32 lordatkmode() const;
  inline void set_lordatkmode(::google::protobuf::int32 value);

  // optional int32 TlordAtkMode = 26;
  inline bool has_tlordatkmode() const;
  inline void clear_tlordatkmode();
  static const int kTlordAtkModeFieldNumber = 26;
  inline ::google::protobuf::int32 tlordatkmode() const;
  inline void set_tlordatkmode(::google::protobuf::int32 value);

  // optional int32 speed = 27;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 27;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 tspeed = 28;
  inline bool has_tspeed() const;
  inline void clear_tspeed();
  static const int kTspeedFieldNumber = 28;
  inline ::google::protobuf::int32 tspeed() const;
  inline void set_tspeed(::google::protobuf::int32 value);

  // optional int32 youActionCountByAdd = 29;
  inline bool has_youactioncountbyadd() const;
  inline void clear_youactioncountbyadd();
  static const int kYouActionCountByAddFieldNumber = 29;
  inline ::google::protobuf::int32 youactioncountbyadd() const;
  inline void set_youactioncountbyadd(::google::protobuf::int32 value);

  // optional int32 himActionCountByAdd = 30;
  inline bool has_himactioncountbyadd() const;
  inline void clear_himactioncountbyadd();
  static const int kHimActionCountByAddFieldNumber = 30;
  inline ::google::protobuf::int32 himactioncountbyadd() const;
  inline void set_himactioncountbyadd(::google::protobuf::int32 value);

  // optional int32 mapId = 31;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 31;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 roleId = 32;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 32;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional int32 tRoleId = 33;
  inline bool has_troleid() const;
  inline void clear_troleid();
  static const int kTRoleIdFieldNumber = 33;
  inline ::google::protobuf::int32 troleid() const;
  inline void set_troleid(::google::protobuf::int32 value);

  // optional int32 maxFillUnit = 34;
  inline bool has_maxfillunit() const;
  inline void clear_maxfillunit();
  static const int kMaxFillUnitFieldNumber = 34;
  inline ::google::protobuf::int32 maxfillunit() const;
  inline void set_maxfillunit(::google::protobuf::int32 value);

  // optional int32 tMaxFillUnit = 35;
  inline bool has_tmaxfillunit() const;
  inline void clear_tmaxfillunit();
  static const int kTMaxFillUnitFieldNumber = 35;
  inline ::google::protobuf::int32 tmaxfillunit() const;
  inline void set_tmaxfillunit(::google::protobuf::int32 value);

  // optional int32 actionTIme = 36;
  inline bool has_actiontime() const;
  inline void clear_actiontime();
  static const int kActionTImeFieldNumber = 36;
  inline ::google::protobuf::int32 actiontime() const;
  inline void set_actiontime(::google::protobuf::int32 value);

  // optional int32 tActionTIme = 37;
  inline bool has_tactiontime() const;
  inline void clear_tactiontime();
  static const int kTActionTImeFieldNumber = 37;
  inline ::google::protobuf::int32 tactiontime() const;
  inline void set_tactiontime(::google::protobuf::int32 value);

  // optional int32 youBaseHp = 38;
  inline bool has_youbasehp() const;
  inline void clear_youbasehp();
  static const int kYouBaseHpFieldNumber = 38;
  inline ::google::protobuf::int32 youbasehp() const;
  inline void set_youbasehp(::google::protobuf::int32 value);

  // optional int32 himBaseHp = 39;
  inline bool has_himbasehp() const;
  inline void clear_himbasehp();
  static const int kHimBaseHpFieldNumber = 39;
  inline ::google::protobuf::int32 himbasehp() const;
  inline void set_himbasehp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.StartResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_isfirstattack();
  inline void clear_has_isfirstattack();
  inline void set_has_youhp();
  inline void clear_has_youhp();
  inline void set_has_himhp();
  inline void clear_has_himhp();
  inline void set_has_youactioncount();
  inline void clear_has_youactioncount();
  inline void set_has_himactioncount();
  inline void clear_has_himactioncount();
  inline void set_has_fid();
  inline void clear_has_fid();
  inline void set_has_lordid();
  inline void clear_has_lordid();
  inline void set_has_lordname();
  inline void clear_has_lordname();
  inline void set_has_lordskillbelongid();
  inline void clear_has_lordskillbelongid();
  inline void set_has_lordskillid();
  inline void clear_has_lordskillid();
  inline void set_has_tlordid();
  inline void clear_has_tlordid();
  inline void set_has_tlordname();
  inline void clear_has_tlordname();
  inline void set_has_tlordskillbelongid();
  inline void clear_has_tlordskillbelongid();
  inline void set_has_tlordskillid();
  inline void clear_has_tlordskillid();
  inline void set_has_tlordskilllevel();
  inline void clear_has_tlordskilllevel();
  inline void set_has_lordcdround();
  inline void clear_has_lordcdround();
  inline void set_has_tlordcdround();
  inline void clear_has_tlordcdround();
  inline void set_has_clienttype();
  inline void clear_has_clienttype();
  inline void set_has_nation();
  inline void clear_has_nation();
  inline void set_has_tnation();
  inline void clear_has_tnation();
  inline void set_has_lordatkmode();
  inline void clear_has_lordatkmode();
  inline void set_has_tlordatkmode();
  inline void clear_has_tlordatkmode();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_tspeed();
  inline void clear_has_tspeed();
  inline void set_has_youactioncountbyadd();
  inline void clear_has_youactioncountbyadd();
  inline void set_has_himactioncountbyadd();
  inline void clear_has_himactioncountbyadd();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_troleid();
  inline void clear_has_troleid();
  inline void set_has_maxfillunit();
  inline void clear_has_maxfillunit();
  inline void set_has_tmaxfillunit();
  inline void clear_has_tmaxfillunit();
  inline void set_has_actiontime();
  inline void clear_has_actiontime();
  inline void set_has_tactiontime();
  inline void clear_has_tactiontime();
  inline void set_has_youbasehp();
  inline void clear_has_youbasehp();
  inline void set_has_himbasehp();
  inline void clear_has_himbasehp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::std::string* failmsg_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritsyou_;
  ::google::protobuf::int32 state_;
  bool isfirstattack_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritshim_;
  ::google::protobuf::int32 youhp_;
  ::google::protobuf::int32 himhp_;
  ::google::protobuf::int32 youactioncount_;
  ::google::protobuf::int32 himactioncount_;
  ::std::string* fid_;
  ::std::string* lordname_;
  ::google::protobuf::int32 lordid_;
  ::google::protobuf::int32 lordskillbelongid_;
  ::google::protobuf::int32 lordskillid_;
  ::google::protobuf::int32 tlordid_;
  ::std::string* tlordname_;
  ::google::protobuf::int32 tlordskillbelongid_;
  ::google::protobuf::int32 tlordskillid_;
  ::google::protobuf::int32 tlordskilllevel_;
  ::google::protobuf::int32 lordcdround_;
  ::google::protobuf::int32 tlordcdround_;
  ::google::protobuf::int32 clienttype_;
  ::google::protobuf::int32 nation_;
  ::google::protobuf::int32 tnation_;
  ::google::protobuf::int32 lordatkmode_;
  ::google::protobuf::int32 tlordatkmode_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 tspeed_;
  ::google::protobuf::int32 youactioncountbyadd_;
  ::google::protobuf::int32 himactioncountbyadd_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 troleid_;
  ::google::protobuf::int32 maxfillunit_;
  ::google::protobuf::int32 tmaxfillunit_;
  ::google::protobuf::int32 actiontime_;
  ::google::protobuf::int32 tactiontime_;
  ::google::protobuf::int32 youbasehp_;
  ::google::protobuf::int32 himbasehp_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static StartResponse* default_instance_;
};
// -------------------------------------------------------------------

class PveContinuePlayRequest : public ::google::protobuf::MessageLite {
 public:
  PveContinuePlayRequest();
  virtual ~PveContinuePlayRequest();

  PveContinuePlayRequest(const PveContinuePlayRequest& from);

  inline PveContinuePlayRequest& operator=(const PveContinuePlayRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PveContinuePlayRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PveContinuePlayRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PveContinuePlayRequest* other);

  // implements Message ----------------------------------------------

  PveContinuePlayRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PveContinuePlayRequest& from);
  void MergeFrom(const PveContinuePlayRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline ::google::protobuf::int32 request() const;
  inline void set_request(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.PveContinuePlayRequest)
 private:
  inline void set_has_request();
  inline void clear_has_request();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 request_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static PveContinuePlayRequest* default_instance_;
};
// -------------------------------------------------------------------

class PveStarRequest : public ::google::protobuf::MessageLite {
 public:
  PveStarRequest();
  virtual ~PveStarRequest();

  PveStarRequest(const PveStarRequest& from);

  inline PveStarRequest& operator=(const PveStarRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PveStarRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PveStarRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PveStarRequest* other);

  // implements Message ----------------------------------------------

  PveStarRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PveStarRequest& from);
  void MergeFrom(const PveStarRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.PveStarRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static PveStarRequest* default_instance_;
};
// -------------------------------------------------------------------

class PveStarResponse : public ::google::protobuf::MessageLite {
 public:
  PveStarResponse();
  virtual ~PveStarResponse();

  PveStarResponse(const PveStarResponse& from);

  inline PveStarResponse& operator=(const PveStarResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PveStarResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PveStarResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PveStarResponse* other);

  // implements Message ----------------------------------------------

  PveStarResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PveStarResponse& from);
  void MergeFrom(const PveStarResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // repeated .main.FightSpirit spiritsYou = 3;
  inline int spiritsyou_size() const;
  inline void clear_spiritsyou();
  static const int kSpiritsYouFieldNumber = 3;
  inline const ::main::FightSpirit& spiritsyou(int index) const;
  inline ::main::FightSpirit* mutable_spiritsyou(int index);
  inline ::main::FightSpirit* add_spiritsyou();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritsyou() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritsyou();

  // repeated .main.FightSpirit spiritsHim = 4;
  inline int spiritshim_size() const;
  inline void clear_spiritshim();
  static const int kSpiritsHimFieldNumber = 4;
  inline const ::main::FightSpirit& spiritshim(int index) const;
  inline ::main::FightSpirit* mutable_spiritshim(int index);
  inline ::main::FightSpirit* add_spiritshim();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spiritshim() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spiritshim();

  // optional bool isFirstAttack = 5;
  inline bool has_isfirstattack() const;
  inline void clear_isfirstattack();
  static const int kIsFirstAttackFieldNumber = 5;
  inline bool isfirstattack() const;
  inline void set_isfirstattack(bool value);

  // optional int32 youHp = 6;
  inline bool has_youhp() const;
  inline void clear_youhp();
  static const int kYouHpFieldNumber = 6;
  inline ::google::protobuf::int32 youhp() const;
  inline void set_youhp(::google::protobuf::int32 value);

  // optional int32 himHp = 7;
  inline bool has_himhp() const;
  inline void clear_himhp();
  static const int kHimHpFieldNumber = 7;
  inline ::google::protobuf::int32 himhp() const;
  inline void set_himhp(::google::protobuf::int32 value);

  // optional int32 youActionCount = 8;
  inline bool has_youactioncount() const;
  inline void clear_youactioncount();
  static const int kYouActionCountFieldNumber = 8;
  inline ::google::protobuf::int32 youactioncount() const;
  inline void set_youactioncount(::google::protobuf::int32 value);

  // optional int32 himActionCount = 9;
  inline bool has_himactioncount() const;
  inline void clear_himactioncount();
  static const int kHimActionCountFieldNumber = 9;
  inline ::google::protobuf::int32 himactioncount() const;
  inline void set_himactioncount(::google::protobuf::int32 value);

  // optional string fid = 10;
  inline bool has_fid() const;
  inline void clear_fid();
  static const int kFidFieldNumber = 10;
  inline const ::std::string& fid() const;
  inline void set_fid(const ::std::string& value);
  inline void set_fid(const char* value);
  inline void set_fid(const char* value, size_t size);
  inline ::std::string* mutable_fid();
  inline ::std::string* release_fid();
  inline void set_allocated_fid(::std::string* fid);

  // optional int32 lordId = 11;
  inline bool has_lordid() const;
  inline void clear_lordid();
  static const int kLordIdFieldNumber = 11;
  inline ::google::protobuf::int32 lordid() const;
  inline void set_lordid(::google::protobuf::int32 value);

  // optional string lordName = 12;
  inline bool has_lordname() const;
  inline void clear_lordname();
  static const int kLordNameFieldNumber = 12;
  inline const ::std::string& lordname() const;
  inline void set_lordname(const ::std::string& value);
  inline void set_lordname(const char* value);
  inline void set_lordname(const char* value, size_t size);
  inline ::std::string* mutable_lordname();
  inline ::std::string* release_lordname();
  inline void set_allocated_lordname(::std::string* lordname);

  // optional int32 lordSkillBelongId = 13;
  inline bool has_lordskillbelongid() const;
  inline void clear_lordskillbelongid();
  static const int kLordSkillBelongIdFieldNumber = 13;
  inline ::google::protobuf::int32 lordskillbelongid() const;
  inline void set_lordskillbelongid(::google::protobuf::int32 value);

  // optional int32 lordSkillId = 14;
  inline bool has_lordskillid() const;
  inline void clear_lordskillid();
  static const int kLordSkillIdFieldNumber = 14;
  inline ::google::protobuf::int32 lordskillid() const;
  inline void set_lordskillid(::google::protobuf::int32 value);

  // optional int32 tlordId = 15;
  inline bool has_tlordid() const;
  inline void clear_tlordid();
  static const int kTlordIdFieldNumber = 15;
  inline ::google::protobuf::int32 tlordid() const;
  inline void set_tlordid(::google::protobuf::int32 value);

  // optional string tlordName = 16;
  inline bool has_tlordname() const;
  inline void clear_tlordname();
  static const int kTlordNameFieldNumber = 16;
  inline const ::std::string& tlordname() const;
  inline void set_tlordname(const ::std::string& value);
  inline void set_tlordname(const char* value);
  inline void set_tlordname(const char* value, size_t size);
  inline ::std::string* mutable_tlordname();
  inline ::std::string* release_tlordname();
  inline void set_allocated_tlordname(::std::string* tlordname);

  // optional int32 tlordSkillBelongId = 17;
  inline bool has_tlordskillbelongid() const;
  inline void clear_tlordskillbelongid();
  static const int kTlordSkillBelongIdFieldNumber = 17;
  inline ::google::protobuf::int32 tlordskillbelongid() const;
  inline void set_tlordskillbelongid(::google::protobuf::int32 value);

  // optional int32 tlordSkillId = 18;
  inline bool has_tlordskillid() const;
  inline void clear_tlordskillid();
  static const int kTlordSkillIdFieldNumber = 18;
  inline ::google::protobuf::int32 tlordskillid() const;
  inline void set_tlordskillid(::google::protobuf::int32 value);

  // optional int32 tlordSkillLevel = 19;
  inline bool has_tlordskilllevel() const;
  inline void clear_tlordskilllevel();
  static const int kTlordSkillLevelFieldNumber = 19;
  inline ::google::protobuf::int32 tlordskilllevel() const;
  inline void set_tlordskilllevel(::google::protobuf::int32 value);

  // optional int32 lordCdRoundBase = 20;
  inline bool has_lordcdroundbase() const;
  inline void clear_lordcdroundbase();
  static const int kLordCdRoundBaseFieldNumber = 20;
  inline ::google::protobuf::int32 lordcdroundbase() const;
  inline void set_lordcdroundbase(::google::protobuf::int32 value);

  // optional int32 tlordCdRoundBase = 21;
  inline bool has_tlordcdroundbase() const;
  inline void clear_tlordcdroundbase();
  static const int kTlordCdRoundBaseFieldNumber = 21;
  inline ::google::protobuf::int32 tlordcdroundbase() const;
  inline void set_tlordcdroundbase(::google::protobuf::int32 value);

  // optional int32 clientType = 22;
  inline bool has_clienttype() const;
  inline void clear_clienttype();
  static const int kClientTypeFieldNumber = 22;
  inline ::google::protobuf::int32 clienttype() const;
  inline void set_clienttype(::google::protobuf::int32 value);

  // optional int32 nation = 23;
  inline bool has_nation() const;
  inline void clear_nation();
  static const int kNationFieldNumber = 23;
  inline ::google::protobuf::int32 nation() const;
  inline void set_nation(::google::protobuf::int32 value);

  // optional int32 tnation = 24;
  inline bool has_tnation() const;
  inline void clear_tnation();
  static const int kTnationFieldNumber = 24;
  inline ::google::protobuf::int32 tnation() const;
  inline void set_tnation(::google::protobuf::int32 value);

  // optional int32 lordAtkMode = 25;
  inline bool has_lordatkmode() const;
  inline void clear_lordatkmode();
  static const int kLordAtkModeFieldNumber = 25;
  inline ::google::protobuf::int32 lordatkmode() const;
  inline void set_lordatkmode(::google::protobuf::int32 value);

  // optional int32 TlordAtkMode = 26;
  inline bool has_tlordatkmode() const;
  inline void clear_tlordatkmode();
  static const int kTlordAtkModeFieldNumber = 26;
  inline ::google::protobuf::int32 tlordatkmode() const;
  inline void set_tlordatkmode(::google::protobuf::int32 value);

  // optional int32 youActionCountByAdd = 27;
  inline bool has_youactioncountbyadd() const;
  inline void clear_youactioncountbyadd();
  static const int kYouActionCountByAddFieldNumber = 27;
  inline ::google::protobuf::int32 youactioncountbyadd() const;
  inline void set_youactioncountbyadd(::google::protobuf::int32 value);

  // optional int32 himActionCountByAdd = 28;
  inline bool has_himactioncountbyadd() const;
  inline void clear_himactioncountbyadd();
  static const int kHimActionCountByAddFieldNumber = 28;
  inline ::google::protobuf::int32 himactioncountbyadd() const;
  inline void set_himactioncountbyadd(::google::protobuf::int32 value);

  // optional int32 mapId = 29;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 29;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 friendOfficerCdRoundCurrent = 30;
  inline bool has_friendofficercdroundcurrent() const;
  inline void clear_friendofficercdroundcurrent();
  static const int kFriendOfficerCdRoundCurrentFieldNumber = 30;
  inline ::google::protobuf::int32 friendofficercdroundcurrent() const;
  inline void set_friendofficercdroundcurrent(::google::protobuf::int32 value);

  // optional int32 friendOfficerCdRound = 31;
  inline bool has_friendofficercdround() const;
  inline void clear_friendofficercdround();
  static const int kFriendOfficerCdRoundFieldNumber = 31;
  inline ::google::protobuf::int32 friendofficercdround() const;
  inline void set_friendofficercdround(::google::protobuf::int32 value);

  // optional int32 friendOfficerId = 32;
  inline bool has_friendofficerid() const;
  inline void clear_friendofficerid();
  static const int kFriendOfficerIdFieldNumber = 32;
  inline ::google::protobuf::int32 friendofficerid() const;
  inline void set_friendofficerid(::google::protobuf::int32 value);

  // optional int32 friendOfficerLevel = 33;
  inline bool has_friendofficerlevel() const;
  inline void clear_friendofficerlevel();
  static const int kFriendOfficerLevelFieldNumber = 33;
  inline ::google::protobuf::int32 friendofficerlevel() const;
  inline void set_friendofficerlevel(::google::protobuf::int32 value);

  // optional int32 roleId = 34;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 34;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional int32 tRoleId = 35;
  inline bool has_troleid() const;
  inline void clear_troleid();
  static const int kTRoleIdFieldNumber = 35;
  inline ::google::protobuf::int32 troleid() const;
  inline void set_troleid(::google::protobuf::int32 value);

  // optional int32 maxFillUnit = 36;
  inline bool has_maxfillunit() const;
  inline void clear_maxfillunit();
  static const int kMaxFillUnitFieldNumber = 36;
  inline ::google::protobuf::int32 maxfillunit() const;
  inline void set_maxfillunit(::google::protobuf::int32 value);

  // optional int32 tMaxFillUnit = 37;
  inline bool has_tmaxfillunit() const;
  inline void clear_tmaxfillunit();
  static const int kTMaxFillUnitFieldNumber = 37;
  inline ::google::protobuf::int32 tmaxfillunit() const;
  inline void set_tmaxfillunit(::google::protobuf::int32 value);

  // optional int32 tClientType = 38;
  inline bool has_tclienttype() const;
  inline void clear_tclienttype();
  static const int kTClientTypeFieldNumber = 38;
  inline ::google::protobuf::int32 tclienttype() const;
  inline void set_tclienttype(::google::protobuf::int32 value);

  // optional int32 speed = 39;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 39;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 tspeed = 40;
  inline bool has_tspeed() const;
  inline void clear_tspeed();
  static const int kTspeedFieldNumber = 40;
  inline ::google::protobuf::int32 tspeed() const;
  inline void set_tspeed(::google::protobuf::int32 value);

  // optional int32 dropItemCount = 41;
  inline bool has_dropitemcount() const;
  inline void clear_dropitemcount();
  static const int kDropItemCountFieldNumber = 41;
  inline ::google::protobuf::int32 dropitemcount() const;
  inline void set_dropitemcount(::google::protobuf::int32 value);

  // optional int32 youBaseHp = 42;
  inline bool has_youbasehp() const;
  inline void clear_youbasehp();
  static const int kYouBaseHpFieldNumber = 42;
  inline ::google::protobuf::int32 youbasehp() const;
  inline void set_youbasehp(::google::protobuf::int32 value);

  // optional int32 himBaseHp = 43;
  inline bool has_himbasehp() const;
  inline void clear_himbasehp();
  static const int kHimBaseHpFieldNumber = 43;
  inline ::google::protobuf::int32 himbasehp() const;
  inline void set_himbasehp(::google::protobuf::int32 value);

  // optional int32 lordCdRound = 44;
  inline bool has_lordcdround() const;
  inline void clear_lordcdround();
  static const int kLordCdRoundFieldNumber = 44;
  inline ::google::protobuf::int32 lordcdround() const;
  inline void set_lordcdround(::google::protobuf::int32 value);

  // optional int32 plotId = 45;
  inline bool has_plotid() const;
  inline void clear_plotid();
  static const int kPlotIdFieldNumber = 45;
  inline ::google::protobuf::int32 plotid() const;
  inline void set_plotid(::google::protobuf::int32 value);

  // repeated .main.FightSpirit selfTempOfficer = 46;
  inline int selftempofficer_size() const;
  inline void clear_selftempofficer();
  static const int kSelfTempOfficerFieldNumber = 46;
  inline const ::main::FightSpirit& selftempofficer(int index) const;
  inline ::main::FightSpirit* mutable_selftempofficer(int index);
  inline ::main::FightSpirit* add_selftempofficer();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      selftempofficer() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_selftempofficer();

  // repeated .main.FightSpirit aiTempOfficer = 47;
  inline int aitempofficer_size() const;
  inline void clear_aitempofficer();
  static const int kAiTempOfficerFieldNumber = 47;
  inline const ::main::FightSpirit& aitempofficer(int index) const;
  inline ::main::FightSpirit* mutable_aitempofficer(int index);
  inline ::main::FightSpirit* add_aitempofficer();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      aitempofficer() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_aitempofficer();

  // optional .main.FightSpirit cooTempOfficer = 48;
  inline bool has_cootempofficer() const;
  inline void clear_cootempofficer();
  static const int kCooTempOfficerFieldNumber = 48;
  inline const ::main::FightSpirit& cootempofficer() const;
  inline ::main::FightSpirit* mutable_cootempofficer();
  inline ::main::FightSpirit* release_cootempofficer();
  inline void set_allocated_cootempofficer(::main::FightSpirit* cootempofficer);

  // @@protoc_insertion_point(class_scope:main.PveStarResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_isfirstattack();
  inline void clear_has_isfirstattack();
  inline void set_has_youhp();
  inline void clear_has_youhp();
  inline void set_has_himhp();
  inline void clear_has_himhp();
  inline void set_has_youactioncount();
  inline void clear_has_youactioncount();
  inline void set_has_himactioncount();
  inline void clear_has_himactioncount();
  inline void set_has_fid();
  inline void clear_has_fid();
  inline void set_has_lordid();
  inline void clear_has_lordid();
  inline void set_has_lordname();
  inline void clear_has_lordname();
  inline void set_has_lordskillbelongid();
  inline void clear_has_lordskillbelongid();
  inline void set_has_lordskillid();
  inline void clear_has_lordskillid();
  inline void set_has_tlordid();
  inline void clear_has_tlordid();
  inline void set_has_tlordname();
  inline void clear_has_tlordname();
  inline void set_has_tlordskillbelongid();
  inline void clear_has_tlordskillbelongid();
  inline void set_has_tlordskillid();
  inline void clear_has_tlordskillid();
  inline void set_has_tlordskilllevel();
  inline void clear_has_tlordskilllevel();
  inline void set_has_lordcdroundbase();
  inline void clear_has_lordcdroundbase();
  inline void set_has_tlordcdroundbase();
  inline void clear_has_tlordcdroundbase();
  inline void set_has_clienttype();
  inline void clear_has_clienttype();
  inline void set_has_nation();
  inline void clear_has_nation();
  inline void set_has_tnation();
  inline void clear_has_tnation();
  inline void set_has_lordatkmode();
  inline void clear_has_lordatkmode();
  inline void set_has_tlordatkmode();
  inline void clear_has_tlordatkmode();
  inline void set_has_youactioncountbyadd();
  inline void clear_has_youactioncountbyadd();
  inline void set_has_himactioncountbyadd();
  inline void clear_has_himactioncountbyadd();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_friendofficercdroundcurrent();
  inline void clear_has_friendofficercdroundcurrent();
  inline void set_has_friendofficercdround();
  inline void clear_has_friendofficercdround();
  inline void set_has_friendofficerid();
  inline void clear_has_friendofficerid();
  inline void set_has_friendofficerlevel();
  inline void clear_has_friendofficerlevel();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_troleid();
  inline void clear_has_troleid();
  inline void set_has_maxfillunit();
  inline void clear_has_maxfillunit();
  inline void set_has_tmaxfillunit();
  inline void clear_has_tmaxfillunit();
  inline void set_has_tclienttype();
  inline void clear_has_tclienttype();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_tspeed();
  inline void clear_has_tspeed();
  inline void set_has_dropitemcount();
  inline void clear_has_dropitemcount();
  inline void set_has_youbasehp();
  inline void clear_has_youbasehp();
  inline void set_has_himbasehp();
  inline void clear_has_himbasehp();
  inline void set_has_lordcdround();
  inline void clear_has_lordcdround();
  inline void set_has_plotid();
  inline void clear_has_plotid();
  inline void set_has_cootempofficer();
  inline void clear_has_cootempofficer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::std::string* failmsg_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritsyou_;
  ::google::protobuf::int32 state_;
  bool isfirstattack_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spiritshim_;
  ::google::protobuf::int32 youhp_;
  ::google::protobuf::int32 himhp_;
  ::google::protobuf::int32 youactioncount_;
  ::google::protobuf::int32 himactioncount_;
  ::std::string* fid_;
  ::std::string* lordname_;
  ::google::protobuf::int32 lordid_;
  ::google::protobuf::int32 lordskillbelongid_;
  ::google::protobuf::int32 lordskillid_;
  ::google::protobuf::int32 tlordid_;
  ::std::string* tlordname_;
  ::google::protobuf::int32 tlordskillbelongid_;
  ::google::protobuf::int32 tlordskillid_;
  ::google::protobuf::int32 tlordskilllevel_;
  ::google::protobuf::int32 lordcdroundbase_;
  ::google::protobuf::int32 tlordcdroundbase_;
  ::google::protobuf::int32 clienttype_;
  ::google::protobuf::int32 nation_;
  ::google::protobuf::int32 tnation_;
  ::google::protobuf::int32 lordatkmode_;
  ::google::protobuf::int32 tlordatkmode_;
  ::google::protobuf::int32 youactioncountbyadd_;
  ::google::protobuf::int32 himactioncountbyadd_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 friendofficercdroundcurrent_;
  ::google::protobuf::int32 friendofficercdround_;
  ::google::protobuf::int32 friendofficerid_;
  ::google::protobuf::int32 friendofficerlevel_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 troleid_;
  ::google::protobuf::int32 maxfillunit_;
  ::google::protobuf::int32 tmaxfillunit_;
  ::google::protobuf::int32 tclienttype_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 tspeed_;
  ::google::protobuf::int32 dropitemcount_;
  ::google::protobuf::int32 youbasehp_;
  ::google::protobuf::int32 himbasehp_;
  ::google::protobuf::int32 lordcdround_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > selftempofficer_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > aitempofficer_;
  ::main::FightSpirit* cootempofficer_;
  ::google::protobuf::int32 plotid_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static PveStarResponse* default_instance_;
};
// -------------------------------------------------------------------

class FillUnitRequest : public ::google::protobuf::MessageLite {
 public:
  FillUnitRequest();
  virtual ~FillUnitRequest();

  FillUnitRequest(const FillUnitRequest& from);

  inline FillUnitRequest& operator=(const FillUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FillUnitRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FillUnitRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FillUnitRequest* other);

  // implements Message ----------------------------------------------

  FillUnitRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FillUnitRequest& from);
  void MergeFrom(const FillUnitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 enemyRoleId = 1;
  inline bool has_enemyroleid() const;
  inline void clear_enemyroleid();
  static const int kEnemyRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 enemyroleid() const;
  inline void set_enemyroleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FillUnitRequest)
 private:
  inline void set_has_enemyroleid();
  inline void clear_has_enemyroleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 enemyroleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FillUnitRequest* default_instance_;
};
// -------------------------------------------------------------------

class FillUnitResponse : public ::google::protobuf::MessageLite {
 public:
  FillUnitResponse();
  virtual ~FillUnitResponse();

  FillUnitResponse(const FillUnitResponse& from);

  inline FillUnitResponse& operator=(const FillUnitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FillUnitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FillUnitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FillUnitResponse* other);

  // implements Message ----------------------------------------------

  FillUnitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FillUnitResponse& from);
  void MergeFrom(const FillUnitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // repeated .main.FightSpirit spirits = 3;
  inline int spirits_size() const;
  inline void clear_spirits();
  static const int kSpiritsFieldNumber = 3;
  inline const ::main::FightSpirit& spirits(int index) const;
  inline ::main::FightSpirit* mutable_spirits(int index);
  inline ::main::FightSpirit* add_spirits();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spirits() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spirits();

  // optional int32 actionCount = 4;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 4;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // optional int32 isSelf = 5;
  inline bool has_isself() const;
  inline void clear_isself();
  static const int kIsSelfFieldNumber = 5;
  inline ::google::protobuf::int32 isself() const;
  inline void set_isself(::google::protobuf::int32 value);

  // optional int32 unLowerActionCount = 6;
  inline bool has_unloweractioncount() const;
  inline void clear_unloweractioncount();
  static const int kUnLowerActionCountFieldNumber = 6;
  inline ::google::protobuf::int32 unloweractioncount() const;
  inline void set_unloweractioncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FillUnitResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();
  inline void set_has_isself();
  inline void clear_has_isself();
  inline void set_has_unloweractioncount();
  inline void clear_has_unloweractioncount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 actioncount_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spirits_;
  ::google::protobuf::int32 isself_;
  ::google::protobuf::int32 unloweractioncount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FillUnitResponse* default_instance_;
};
// -------------------------------------------------------------------

class FillUnitReviveRequest : public ::google::protobuf::MessageLite {
 public:
  FillUnitReviveRequest();
  virtual ~FillUnitReviveRequest();

  FillUnitReviveRequest(const FillUnitReviveRequest& from);

  inline FillUnitReviveRequest& operator=(const FillUnitReviveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FillUnitReviveRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FillUnitReviveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FillUnitReviveRequest* other);

  // implements Message ----------------------------------------------

  FillUnitReviveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FillUnitReviveRequest& from);
  void MergeFrom(const FillUnitReviveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.FillUnitReviveRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FillUnitReviveRequest* default_instance_;
};
// -------------------------------------------------------------------

class FillUnitReviveResponse : public ::google::protobuf::MessageLite {
 public:
  FillUnitReviveResponse();
  virtual ~FillUnitReviveResponse();

  FillUnitReviveResponse(const FillUnitReviveResponse& from);

  inline FillUnitReviveResponse& operator=(const FillUnitReviveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FillUnitReviveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FillUnitReviveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FillUnitReviveResponse* other);

  // implements Message ----------------------------------------------

  FillUnitReviveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FillUnitReviveResponse& from);
  void MergeFrom(const FillUnitReviveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 roleId = 2;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // repeated .main.FightSpirit spirits = 3;
  inline int spirits_size() const;
  inline void clear_spirits();
  static const int kSpiritsFieldNumber = 3;
  inline const ::main::FightSpirit& spirits(int index) const;
  inline ::main::FightSpirit* mutable_spirits(int index);
  inline ::main::FightSpirit* add_spirits();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spirits() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spirits();

  // repeated .main.FightSpirit selfTempOfficer = 4;
  inline int selftempofficer_size() const;
  inline void clear_selftempofficer();
  static const int kSelfTempOfficerFieldNumber = 4;
  inline const ::main::FightSpirit& selftempofficer(int index) const;
  inline ::main::FightSpirit* mutable_selftempofficer(int index);
  inline ::main::FightSpirit* add_selftempofficer();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      selftempofficer() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_selftempofficer();

  // @@protoc_insertion_point(class_scope:main.FillUnitReviveResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spirits_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > selftempofficer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FillUnitReviveResponse* default_instance_;
};
// -------------------------------------------------------------------

class QiangZhiFillUnitRequest : public ::google::protobuf::MessageLite {
 public:
  QiangZhiFillUnitRequest();
  virtual ~QiangZhiFillUnitRequest();

  QiangZhiFillUnitRequest(const QiangZhiFillUnitRequest& from);

  inline QiangZhiFillUnitRequest& operator=(const QiangZhiFillUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QiangZhiFillUnitRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QiangZhiFillUnitRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QiangZhiFillUnitRequest* other);

  // implements Message ----------------------------------------------

  QiangZhiFillUnitRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QiangZhiFillUnitRequest& from);
  void MergeFrom(const QiangZhiFillUnitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.QiangZhiFillUnitRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static QiangZhiFillUnitRequest* default_instance_;
};
// -------------------------------------------------------------------

class QiangZhiFillUnitResponse : public ::google::protobuf::MessageLite {
 public:
  QiangZhiFillUnitResponse();
  virtual ~QiangZhiFillUnitResponse();

  QiangZhiFillUnitResponse(const QiangZhiFillUnitResponse& from);

  inline QiangZhiFillUnitResponse& operator=(const QiangZhiFillUnitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QiangZhiFillUnitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QiangZhiFillUnitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QiangZhiFillUnitResponse* other);

  // implements Message ----------------------------------------------

  QiangZhiFillUnitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QiangZhiFillUnitResponse& from);
  void MergeFrom(const QiangZhiFillUnitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // repeated .main.FightSpirit spirits = 3;
  inline int spirits_size() const;
  inline void clear_spirits();
  static const int kSpiritsFieldNumber = 3;
  inline const ::main::FightSpirit& spirits(int index) const;
  inline ::main::FightSpirit* mutable_spirits(int index);
  inline ::main::FightSpirit* add_spirits();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spirits() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spirits();

  // optional int32 actionCount = 4;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 4;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // optional int32 isSelf = 5;
  inline bool has_isself() const;
  inline void clear_isself();
  static const int kIsSelfFieldNumber = 5;
  inline ::google::protobuf::int32 isself() const;
  inline void set_isself(::google::protobuf::int32 value);

  // optional int32 unLowerActionCount = 6;
  inline bool has_unloweractioncount() const;
  inline void clear_unloweractioncount();
  static const int kUnLowerActionCountFieldNumber = 6;
  inline ::google::protobuf::int32 unloweractioncount() const;
  inline void set_unloweractioncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.QiangZhiFillUnitResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();
  inline void set_has_isself();
  inline void clear_has_isself();
  inline void set_has_unloweractioncount();
  inline void clear_has_unloweractioncount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 actioncount_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spirits_;
  ::google::protobuf::int32 isself_;
  ::google::protobuf::int32 unloweractioncount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static QiangZhiFillUnitResponse* default_instance_;
};
// -------------------------------------------------------------------

class MoveRequest : public ::google::protobuf::MessageLite {
 public:
  MoveRequest();
  virtual ~MoveRequest();

  MoveRequest(const MoveRequest& from);

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MoveRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MoveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MoveRequest* other);

  // implements Message ----------------------------------------------

  MoveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MoveRequest& from);
  void MergeFrom(const MoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 tox = 2;
  inline bool has_tox() const;
  inline void clear_tox();
  static const int kToxFieldNumber = 2;
  inline ::google::protobuf::int32 tox() const;
  inline void set_tox(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.MoveRequest)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_tox();
  inline void clear_has_tox();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 tox_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoveResponse : public ::google::protobuf::MessageLite {
 public:
  MoveResponse();
  virtual ~MoveResponse();

  MoveResponse(const MoveResponse& from);

  inline MoveResponse& operator=(const MoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MoveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MoveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MoveResponse* other);

  // implements Message ----------------------------------------------

  MoveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MoveResponse& from);
  void MergeFrom(const MoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // optional int32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 tox = 4;
  inline bool has_tox() const;
  inline void clear_tox();
  static const int kToxFieldNumber = 4;
  inline ::google::protobuf::int32 tox() const;
  inline void set_tox(::google::protobuf::int32 value);

  // optional int32 actionCount = 5;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 5;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.MoveResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_tox();
  inline void clear_has_tox();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 tox_;
  ::google::protobuf::int32 actioncount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class GiveUpRequest : public ::google::protobuf::MessageLite {
 public:
  GiveUpRequest();
  virtual ~GiveUpRequest();

  GiveUpRequest(const GiveUpRequest& from);

  inline GiveUpRequest& operator=(const GiveUpRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GiveUpRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiveUpRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiveUpRequest* other);

  // implements Message ----------------------------------------------

  GiveUpRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiveUpRequest& from);
  void MergeFrom(const GiveUpRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.GiveUpRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static GiveUpRequest* default_instance_;
};
// -------------------------------------------------------------------

class GiveUpResponse : public ::google::protobuf::MessageLite {
 public:
  GiveUpResponse();
  virtual ~GiveUpResponse();

  GiveUpResponse(const GiveUpResponse& from);

  inline GiveUpResponse& operator=(const GiveUpResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GiveUpResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiveUpResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiveUpResponse* other);

  // implements Message ----------------------------------------------

  GiveUpResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiveUpResponse& from);
  void MergeFrom(const GiveUpResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 round = 2 [default = -1];
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional sint32 skillResidueRound = 3;
  inline bool has_skillresidueround() const;
  inline void clear_skillresidueround();
  static const int kSkillResidueRoundFieldNumber = 3;
  inline ::google::protobuf::int32 skillresidueround() const;
  inline void set_skillresidueround(::google::protobuf::int32 value);

  // optional sint32 actionCount = 4;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 4;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.GiveUpResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_skillresidueround();
  inline void clear_has_skillresidueround();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 skillresidueround_;
  ::google::protobuf::int32 actioncount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static GiveUpResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveRequest : public ::google::protobuf::MessageLite {
 public:
  RemoveRequest();
  virtual ~RemoveRequest();

  RemoveRequest(const RemoveRequest& from);

  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoveRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveRequest* other);

  // implements Message ----------------------------------------------

  RemoveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveRequest& from);
  void MergeFrom(const RemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 enemyRoleId = 1;
  inline bool has_enemyroleid() const;
  inline void clear_enemyroleid();
  static const int kEnemyRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 enemyroleid() const;
  inline void set_enemyroleid(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RemoveRequest)
 private:
  inline void set_has_enemyroleid();
  inline void clear_has_enemyroleid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 enemyroleid_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static RemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveResponse : public ::google::protobuf::MessageLite {
 public:
  RemoveResponse();
  virtual ~RemoveResponse();

  RemoveResponse(const RemoveResponse& from);

  inline RemoveResponse& operator=(const RemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveResponse* other);

  // implements Message ----------------------------------------------

  RemoveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveResponse& from);
  void MergeFrom(const RemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string failMsg = 2;
  inline bool has_failmsg() const;
  inline void clear_failmsg();
  static const int kFailMsgFieldNumber = 2;
  inline const ::std::string& failmsg() const;
  inline void set_failmsg(const ::std::string& value);
  inline void set_failmsg(const char* value);
  inline void set_failmsg(const char* value, size_t size);
  inline ::std::string* mutable_failmsg();
  inline ::std::string* release_failmsg();
  inline void set_allocated_failmsg(::std::string* failmsg);

  // optional int32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 actionCount = 5;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 5;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.RemoveResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_failmsg();
  inline void clear_has_failmsg();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* failmsg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 actioncount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static RemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class ActionCountResponse : public ::google::protobuf::MessageLite {
 public:
  ActionCountResponse();
  virtual ~ActionCountResponse();

  ActionCountResponse(const ActionCountResponse& from);

  inline ActionCountResponse& operator=(const ActionCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ActionCountResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActionCountResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActionCountResponse* other);

  // implements Message ----------------------------------------------

  ActionCountResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActionCountResponse& from);
  void MergeFrom(const ActionCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 yourCount = 1;
  inline bool has_yourcount() const;
  inline void clear_yourcount();
  static const int kYourCountFieldNumber = 1;
  inline ::google::protobuf::int32 yourcount() const;
  inline void set_yourcount(::google::protobuf::int32 value);

  // optional int32 himCount = 2;
  inline bool has_himcount() const;
  inline void clear_himcount();
  static const int kHimCountFieldNumber = 2;
  inline ::google::protobuf::int32 himcount() const;
  inline void set_himcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ActionCountResponse)
 private:
  inline void set_has_yourcount();
  inline void clear_has_yourcount();
  inline void set_has_himcount();
  inline void clear_has_himcount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 yourcount_;
  ::google::protobuf::int32 himcount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static ActionCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightSpirit : public ::google::protobuf::MessageLite {
 public:
  FightSpirit();
  virtual ~FightSpirit();

  FightSpirit(const FightSpirit& from);

  inline FightSpirit& operator=(const FightSpirit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightSpirit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightSpirit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightSpirit* other);

  // implements Message ----------------------------------------------

  FightSpirit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightSpirit& from);
  void MergeFrom(const FightSpirit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline ::google::protobuf::int32 color() const;
  inline void set_color(::google::protobuf::int32 value);

  // optional int32 x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 baseAttack = 6;
  inline bool has_baseattack() const;
  inline void clear_baseattack();
  static const int kBaseAttackFieldNumber = 6;
  inline ::google::protobuf::int32 baseattack() const;
  inline void set_baseattack(::google::protobuf::int32 value);

  // optional int32 attack = 7;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 7;
  inline ::google::protobuf::int32 attack() const;
  inline void set_attack(::google::protobuf::int32 value);

  // optional int32 baseDef = 8;
  inline bool has_basedef() const;
  inline void clear_basedef();
  static const int kBaseDefFieldNumber = 8;
  inline ::google::protobuf::int32 basedef() const;
  inline void set_basedef(::google::protobuf::int32 value);

  // optional int32 def = 9;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 9;
  inline ::google::protobuf::int32 def() const;
  inline void set_def(::google::protobuf::int32 value);

  // optional int32 round = 10;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 10;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional float defeatPlus = 11;
  inline bool has_defeatplus() const;
  inline void clear_defeatplus();
  static const int kDefeatPlusFieldNumber = 11;
  inline float defeatplus() const;
  inline void set_defeatplus(float value);

  // optional float chainAndMergeAttackPlus = 12;
  inline bool has_chainandmergeattackplus() const;
  inline void clear_chainandmergeattackplus();
  static const int kChainAndMergeAttackPlusFieldNumber = 12;
  inline float chainandmergeattackplus() const;
  inline void set_chainandmergeattackplus(float value);

  // optional float wallgrow = 13;
  inline bool has_wallgrow() const;
  inline void clear_wallgrow();
  static const int kWallgrowFieldNumber = 13;
  inline float wallgrow() const;
  inline void set_wallgrow(float value);

  // optional int32 skillId = 14;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 14;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional float value1 = 15;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 15;
  inline float value1() const;
  inline void set_value1(float value);

  // optional float value2 = 16;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 16;
  inline float value2() const;
  inline void set_value2(float value);

  // optional float walltype = 17;
  inline bool has_walltype() const;
  inline void clear_walltype();
  static const int kWalltypeFieldNumber = 17;
  inline float walltype() const;
  inline void set_walltype(float value);

  // optional float wallCeiling = 18;
  inline bool has_wallceiling() const;
  inline void clear_wallceiling();
  static const int kWallCeilingFieldNumber = 18;
  inline float wallceiling() const;
  inline void set_wallceiling(float value);

  // optional int32 buffId = 19;
  inline bool has_buffid() const;
  inline void clear_buffid();
  static const int kBuffIdFieldNumber = 19;
  inline ::google::protobuf::int32 buffid() const;
  inline void set_buffid(::google::protobuf::int32 value);

  // optional float bvalue1 = 20;
  inline bool has_bvalue1() const;
  inline void clear_bvalue1();
  static const int kBvalue1FieldNumber = 20;
  inline float bvalue1() const;
  inline void set_bvalue1(float value);

  // optional int32 effectRound = 21;
  inline bool has_effectround() const;
  inline void clear_effectround();
  static const int kEffectRoundFieldNumber = 21;
  inline ::google::protobuf::int32 effectround() const;
  inline void set_effectround(::google::protobuf::int32 value);

  // optional int32 randNum = 22;
  inline bool has_randnum() const;
  inline void clear_randnum();
  static const int kRandNumFieldNumber = 22;
  inline ::google::protobuf::int32 randnum() const;
  inline void set_randnum(::google::protobuf::int32 value);

  // optional int32 buffType = 23;
  inline bool has_bufftype() const;
  inline void clear_bufftype();
  static const int kBuffTypeFieldNumber = 23;
  inline ::google::protobuf::int32 bufftype() const;
  inline void set_bufftype(::google::protobuf::int32 value);

  // optional int32 effect = 24;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 24;
  inline ::google::protobuf::int32 effect() const;
  inline void set_effect(::google::protobuf::int32 value);

  // optional int32 perRoundAddAtk = 25;
  inline bool has_perroundaddatk() const;
  inline void clear_perroundaddatk();
  static const int kPerRoundAddAtkFieldNumber = 25;
  inline ::google::protobuf::int32 perroundaddatk() const;
  inline void set_perroundaddatk(::google::protobuf::int32 value);

  // optional int32 atkModeSkill = 26;
  inline bool has_atkmodeskill() const;
  inline void clear_atkmodeskill();
  static const int kAtkModeSkillFieldNumber = 26;
  inline ::google::protobuf::int32 atkmodeskill() const;
  inline void set_atkmodeskill(::google::protobuf::int32 value);

  // optional bool defeat = 27;
  inline bool has_defeat() const;
  inline void clear_defeat();
  static const int kDefeatFieldNumber = 27;
  inline bool defeat() const;
  inline void set_defeat(bool value);

  // optional int32 currentDef = 28;
  inline bool has_currentdef() const;
  inline void clear_currentdef();
  static const int kCurrentDefFieldNumber = 28;
  inline ::google::protobuf::int32 currentdef() const;
  inline void set_currentdef(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightSpirit)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_baseattack();
  inline void clear_has_baseattack();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_basedef();
  inline void clear_has_basedef();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_defeatplus();
  inline void clear_has_defeatplus();
  inline void set_has_chainandmergeattackplus();
  inline void clear_has_chainandmergeattackplus();
  inline void set_has_wallgrow();
  inline void clear_has_wallgrow();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_walltype();
  inline void clear_has_walltype();
  inline void set_has_wallceiling();
  inline void clear_has_wallceiling();
  inline void set_has_buffid();
  inline void clear_has_buffid();
  inline void set_has_bvalue1();
  inline void clear_has_bvalue1();
  inline void set_has_effectround();
  inline void clear_has_effectround();
  inline void set_has_randnum();
  inline void clear_has_randnum();
  inline void set_has_bufftype();
  inline void clear_has_bufftype();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_perroundaddatk();
  inline void clear_has_perroundaddatk();
  inline void set_has_atkmodeskill();
  inline void clear_has_atkmodeskill();
  inline void set_has_defeat();
  inline void clear_has_defeat();
  inline void set_has_currentdef();
  inline void clear_has_currentdef();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 color_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 baseattack_;
  ::google::protobuf::int32 attack_;
  ::google::protobuf::int32 basedef_;
  ::google::protobuf::int32 def_;
  ::google::protobuf::int32 round_;
  float defeatplus_;
  float chainandmergeattackplus_;
  float wallgrow_;
  ::google::protobuf::int32 skillid_;
  float value1_;
  float value2_;
  float walltype_;
  float wallceiling_;
  ::google::protobuf::int32 buffid_;
  float bvalue1_;
  ::google::protobuf::int32 effectround_;
  ::google::protobuf::int32 randnum_;
  ::google::protobuf::int32 bufftype_;
  ::google::protobuf::int32 effect_;
  ::google::protobuf::int32 perroundaddatk_;
  ::google::protobuf::int32 atkmodeskill_;
  bool defeat_;
  ::google::protobuf::int32 currentdef_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightSpirit* default_instance_;
};
// -------------------------------------------------------------------

class VerifyRequest : public ::google::protobuf::MessageLite {
 public:
  VerifyRequest();
  virtual ~VerifyRequest();

  VerifyRequest(const VerifyRequest& from);

  inline VerifyRequest& operator=(const VerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VerifyRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VerifyRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VerifyRequest* other);

  // implements Message ----------------------------------------------

  VerifyRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VerifyRequest& from);
  void MergeFrom(const VerifyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 check = 1;
  inline int check_size() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 1;
  inline ::google::protobuf::int32 check(int index) const;
  inline void set_check(int index, ::google::protobuf::int32 value);
  inline void add_check(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      check() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_check();

  // @@protoc_insertion_point(class_scope:main.VerifyRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > check_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static VerifyRequest* default_instance_;
};
// -------------------------------------------------------------------

class VerifyResponse : public ::google::protobuf::MessageLite {
 public:
  VerifyResponse();
  virtual ~VerifyResponse();

  VerifyResponse(const VerifyResponse& from);

  inline VerifyResponse& operator=(const VerifyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VerifyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VerifyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VerifyResponse* other);

  // implements Message ----------------------------------------------

  VerifyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VerifyResponse& from);
  void MergeFrom(const VerifyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.VerifyResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static VerifyResponse* default_instance_;
};
// -------------------------------------------------------------------

class MajorSkillRequest : public ::google::protobuf::MessageLite {
 public:
  MajorSkillRequest();
  virtual ~MajorSkillRequest();

  MajorSkillRequest(const MajorSkillRequest& from);

  inline MajorSkillRequest& operator=(const MajorSkillRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MajorSkillRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MajorSkillRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MajorSkillRequest* other);

  // implements Message ----------------------------------------------

  MajorSkillRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MajorSkillRequest& from);
  void MergeFrom(const MajorSkillRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float value1 = 1;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 1;
  inline float value1() const;
  inline void set_value1(float value);

  // optional float value2 = 2;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 2;
  inline float value2() const;
  inline void set_value2(float value);

  // optional int32 test = 3;
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 3;
  inline ::google::protobuf::int32 test() const;
  inline void set_test(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.MajorSkillRequest)
 private:
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_test();
  inline void clear_has_test();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float value1_;
  float value2_;
  ::google::protobuf::int32 test_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MajorSkillRequest* default_instance_;
};
// -------------------------------------------------------------------

class MajorSkillResponse : public ::google::protobuf::MessageLite {
 public:
  MajorSkillResponse();
  virtual ~MajorSkillResponse();

  MajorSkillResponse(const MajorSkillResponse& from);

  inline MajorSkillResponse& operator=(const MajorSkillResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MajorSkillResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MajorSkillResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MajorSkillResponse* other);

  // implements Message ----------------------------------------------

  MajorSkillResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MajorSkillResponse& from);
  void MergeFrom(const MajorSkillResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .main.MajorSkillProto majorSkillProto = 1;
  inline bool has_majorskillproto() const;
  inline void clear_majorskillproto();
  static const int kMajorSkillProtoFieldNumber = 1;
  inline const ::main::MajorSkillProto& majorskillproto() const;
  inline ::main::MajorSkillProto* mutable_majorskillproto();
  inline ::main::MajorSkillProto* release_majorskillproto();
  inline void set_allocated_majorskillproto(::main::MajorSkillProto* majorskillproto);

  // @@protoc_insertion_point(class_scope:main.MajorSkillResponse)
 private:
  inline void set_has_majorskillproto();
  inline void clear_has_majorskillproto();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::MajorSkillProto* majorskillproto_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MajorSkillResponse* default_instance_;
};
// -------------------------------------------------------------------

class MajorSkillProto : public ::google::protobuf::MessageLite {
 public:
  MajorSkillProto();
  virtual ~MajorSkillProto();

  MajorSkillProto(const MajorSkillProto& from);

  inline MajorSkillProto& operator=(const MajorSkillProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MajorSkillProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MajorSkillProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MajorSkillProto* other);

  // implements Message ----------------------------------------------

  MajorSkillProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MajorSkillProto& from);
  void MergeFrom(const MajorSkillProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 skillId = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional float value1 = 3;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 3;
  inline float value1() const;
  inline void set_value1(float value);

  // optional float value2 = 4;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 4;
  inline float value2() const;
  inline void set_value2(float value);

  // optional int32 roleId = 5;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 5;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // repeated .main.CoordinateProto coordinateProtoList = 6;
  inline int coordinateprotolist_size() const;
  inline void clear_coordinateprotolist();
  static const int kCoordinateProtoListFieldNumber = 6;
  inline const ::main::CoordinateProto& coordinateprotolist(int index) const;
  inline ::main::CoordinateProto* mutable_coordinateprotolist(int index);
  inline ::main::CoordinateProto* add_coordinateprotolist();
  inline const ::google::protobuf::RepeatedPtrField< ::main::CoordinateProto >&
      coordinateprotolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::CoordinateProto >*
      mutable_coordinateprotolist();

  // optional int32 buffId = 7;
  inline bool has_buffid() const;
  inline void clear_buffid();
  static const int kBuffIdFieldNumber = 7;
  inline ::google::protobuf::int32 buffid() const;
  inline void set_buffid(::google::protobuf::int32 value);

  // optional int32 round = 8;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 8;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional float value3 = 9;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 9;
  inline float value3() const;
  inline void set_value3(float value);

  // optional int32 lordAtkMode = 10;
  inline bool has_lordatkmode() const;
  inline void clear_lordatkmode();
  static const int kLordAtkModeFieldNumber = 10;
  inline ::google::protobuf::int32 lordatkmode() const;
  inline void set_lordatkmode(::google::protobuf::int32 value);

  // repeated .main.CoordinateEffectProto coordinateEffectProto = 11;
  inline int coordinateeffectproto_size() const;
  inline void clear_coordinateeffectproto();
  static const int kCoordinateEffectProtoFieldNumber = 11;
  inline const ::main::CoordinateEffectProto& coordinateeffectproto(int index) const;
  inline ::main::CoordinateEffectProto* mutable_coordinateeffectproto(int index);
  inline ::main::CoordinateEffectProto* add_coordinateeffectproto();
  inline const ::google::protobuf::RepeatedPtrField< ::main::CoordinateEffectProto >&
      coordinateeffectproto() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::CoordinateEffectProto >*
      mutable_coordinateeffectproto();

  // @@protoc_insertion_point(class_scope:main.MajorSkillProto)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_buffid();
  inline void clear_has_buffid();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_value3();
  inline void clear_has_value3();
  inline void set_has_lordatkmode();
  inline void clear_has_lordatkmode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 skillid_;
  float value1_;
  float value2_;
  ::google::protobuf::RepeatedPtrField< ::main::CoordinateProto > coordinateprotolist_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 buffid_;
  ::google::protobuf::int32 round_;
  float value3_;
  ::google::protobuf::RepeatedPtrField< ::main::CoordinateEffectProto > coordinateeffectproto_;
  ::google::protobuf::int32 lordatkmode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MajorSkillProto* default_instance_;
};
// -------------------------------------------------------------------

class CoordinateProto : public ::google::protobuf::MessageLite {
 public:
  CoordinateProto();
  virtual ~CoordinateProto();

  CoordinateProto(const CoordinateProto& from);

  inline CoordinateProto& operator=(const CoordinateProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CoordinateProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CoordinateProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CoordinateProto* other);

  // implements Message ----------------------------------------------

  CoordinateProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CoordinateProto& from);
  void MergeFrom(const CoordinateProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.CoordinateProto)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static CoordinateProto* default_instance_;
};
// -------------------------------------------------------------------

class CoordinateEffectProto : public ::google::protobuf::MessageLite {
 public:
  CoordinateEffectProto();
  virtual ~CoordinateEffectProto();

  CoordinateEffectProto(const CoordinateEffectProto& from);

  inline CoordinateEffectProto& operator=(const CoordinateEffectProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CoordinateEffectProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CoordinateEffectProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CoordinateEffectProto* other);

  // implements Message ----------------------------------------------

  CoordinateEffectProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CoordinateEffectProto& from);
  void MergeFrom(const CoordinateEffectProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.CoordinateEffectProto)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 hp_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static CoordinateEffectProto* default_instance_;
};
// -------------------------------------------------------------------

class FightThtoughRewardRequest : public ::google::protobuf::MessageLite {
 public:
  FightThtoughRewardRequest();
  virtual ~FightThtoughRewardRequest();

  FightThtoughRewardRequest(const FightThtoughRewardRequest& from);

  inline FightThtoughRewardRequest& operator=(const FightThtoughRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightThtoughRewardRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightThtoughRewardRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightThtoughRewardRequest* other);

  // implements Message ----------------------------------------------

  FightThtoughRewardRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightThtoughRewardRequest& from);
  void MergeFrom(const FightThtoughRewardRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 fighprossId = 1;
  inline bool has_fighprossid() const;
  inline void clear_fighprossid();
  static const int kFighprossIdFieldNumber = 1;
  inline ::google::protobuf::int64 fighprossid() const;
  inline void set_fighprossid(::google::protobuf::int64 value);

  // required sint32 isWin = 2;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 2;
  inline ::google::protobuf::int32 iswin() const;
  inline void set_iswin(::google::protobuf::int32 value);

  // optional sint32 currHp = 3;
  inline bool has_currhp() const;
  inline void clear_currhp();
  static const int kCurrHpFieldNumber = 3;
  inline ::google::protobuf::int32 currhp() const;
  inline void set_currhp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightThtoughRewardRequest)
 private:
  inline void set_has_fighprossid();
  inline void clear_has_fighprossid();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_currhp();
  inline void clear_has_currhp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 fighprossid_;
  ::google::protobuf::int32 iswin_;
  ::google::protobuf::int32 currhp_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightThtoughRewardRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightRewardRequest : public ::google::protobuf::MessageLite {
 public:
  FightRewardRequest();
  virtual ~FightRewardRequest();

  FightRewardRequest(const FightRewardRequest& from);

  inline FightRewardRequest& operator=(const FightRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightRewardRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRewardRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRewardRequest* other);

  // implements Message ----------------------------------------------

  FightRewardRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRewardRequest& from);
  void MergeFrom(const FightRewardRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fighprossId = 1;
  inline bool has_fighprossid() const;
  inline void clear_fighprossid();
  static const int kFighprossIdFieldNumber = 1;
  inline const ::std::string& fighprossid() const;
  inline void set_fighprossid(const ::std::string& value);
  inline void set_fighprossid(const char* value);
  inline void set_fighprossid(const char* value, size_t size);
  inline ::std::string* mutable_fighprossid();
  inline ::std::string* release_fighprossid();
  inline void set_allocated_fighprossid(::std::string* fighprossid);

  // @@protoc_insertion_point(class_scope:main.FightRewardRequest)
 private:
  inline void set_has_fighprossid();
  inline void clear_has_fighprossid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fighprossid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightRewardRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightRewardResponse : public ::google::protobuf::MessageLite {
 public:
  FightRewardResponse();
  virtual ~FightRewardResponse();

  FightRewardResponse(const FightRewardResponse& from);

  inline FightRewardResponse& operator=(const FightRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRewardResponse* other);

  // implements Message ----------------------------------------------

  FightRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRewardResponse& from);
  void MergeFrom(const FightRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 plotId = 2;
  inline bool has_plotid() const;
  inline void clear_plotid();
  static const int kPlotIdFieldNumber = 2;
  inline ::google::protobuf::int32 plotid() const;
  inline void set_plotid(::google::protobuf::int32 value);

  // optional int32 rating = 3;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 3;
  inline ::google::protobuf::int32 rating() const;
  inline void set_rating(::google::protobuf::int32 value);

  // optional int32 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 gold = 5;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 5;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // repeated .main.FightRewardDropItems dropItems = 6;
  inline int dropitems_size() const;
  inline void clear_dropitems();
  static const int kDropItemsFieldNumber = 6;
  inline const ::main::FightRewardDropItems& dropitems(int index) const;
  inline ::main::FightRewardDropItems* mutable_dropitems(int index);
  inline ::main::FightRewardDropItems* add_dropitems();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightRewardDropItems >&
      dropitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightRewardDropItems >*
      mutable_dropitems();

  // optional int32 isWin = 7;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 7;
  inline ::google::protobuf::int32 iswin() const;
  inline void set_iswin(::google::protobuf::int32 value);

  // optional float hpRate = 8;
  inline bool has_hprate() const;
  inline void clear_hprate();
  static const int kHpRateFieldNumber = 8;
  inline float hprate() const;
  inline void set_hprate(float value);

  // optional int32 coins = 9;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 9;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // optional int32 meritorious = 10;
  inline bool has_meritorious() const;
  inline void clear_meritorious();
  static const int kMeritoriousFieldNumber = 10;
  inline ::google::protobuf::int32 meritorious() const;
  inline void set_meritorious(::google::protobuf::int32 value);

  // optional int32 lianDan = 11 [default = -1];
  inline bool has_liandan() const;
  inline void clear_liandan();
  static const int kLianDanFieldNumber = 11;
  inline ::google::protobuf::int32 liandan() const;
  inline void set_liandan(::google::protobuf::int32 value);

  // optional int32 addExp = 12;
  inline bool has_addexp() const;
  inline void clear_addexp();
  static const int kAddExpFieldNumber = 12;
  inline ::google::protobuf::int32 addexp() const;
  inline void set_addexp(::google::protobuf::int32 value);

  // optional int32 level = 13;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 13;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 isMaxLevel = 14 [default = 0];
  inline bool has_ismaxlevel() const;
  inline void clear_ismaxlevel();
  static const int kIsMaxLevelFieldNumber = 14;
  inline ::google::protobuf::int32 ismaxlevel() const;
  inline void set_ismaxlevel(::google::protobuf::int32 value);

  // optional sint32 baseHp = 15;
  inline bool has_basehp() const;
  inline void clear_basehp();
  static const int kBaseHpFieldNumber = 15;
  inline ::google::protobuf::int32 basehp() const;
  inline void set_basehp(::google::protobuf::int32 value);

  // optional sint32 currHp = 16;
  inline bool has_currhp() const;
  inline void clear_currhp();
  static const int kCurrHpFieldNumber = 16;
  inline ::google::protobuf::int32 currhp() const;
  inline void set_currhp(::google::protobuf::int32 value);

  // optional int32 oldLevel = 17;
  inline bool has_oldlevel() const;
  inline void clear_oldlevel();
  static const int kOldLevelFieldNumber = 17;
  inline ::google::protobuf::int32 oldlevel() const;
  inline void set_oldlevel(::google::protobuf::int32 value);

  // optional int32 xiyu = 18 [default = -1];
  inline bool has_xiyu() const;
  inline void clear_xiyu();
  static const int kXiyuFieldNumber = 18;
  inline ::google::protobuf::int32 xiyu() const;
  inline void set_xiyu(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightRewardResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_plotid();
  inline void clear_has_plotid();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_hprate();
  inline void clear_has_hprate();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_meritorious();
  inline void clear_has_meritorious();
  inline void set_has_liandan();
  inline void clear_has_liandan();
  inline void set_has_addexp();
  inline void clear_has_addexp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_ismaxlevel();
  inline void clear_has_ismaxlevel();
  inline void set_has_basehp();
  inline void clear_has_basehp();
  inline void set_has_currhp();
  inline void clear_has_currhp();
  inline void set_has_oldlevel();
  inline void clear_has_oldlevel();
  inline void set_has_xiyu();
  inline void clear_has_xiyu();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 plotid_;
  ::google::protobuf::int32 rating_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedPtrField< ::main::FightRewardDropItems > dropitems_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 iswin_;
  float hprate_;
  ::google::protobuf::int32 coins_;
  ::google::protobuf::int32 meritorious_;
  ::google::protobuf::int32 liandan_;
  ::google::protobuf::int32 addexp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 ismaxlevel_;
  ::google::protobuf::int32 basehp_;
  ::google::protobuf::int32 currhp_;
  ::google::protobuf::int32 oldlevel_;
  ::google::protobuf::int32 xiyu_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightRewardResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightRewardDropItems : public ::google::protobuf::MessageLite {
 public:
  FightRewardDropItems();
  virtual ~FightRewardDropItems();

  FightRewardDropItems(const FightRewardDropItems& from);

  inline FightRewardDropItems& operator=(const FightRewardDropItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightRewardDropItems& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRewardDropItems* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRewardDropItems* other);

  // implements Message ----------------------------------------------

  FightRewardDropItems* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRewardDropItems& from);
  void MergeFrom(const FightRewardDropItems& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .main.OfficerCardItemProto officerCards = 1;
  inline bool has_officercards() const;
  inline void clear_officercards();
  static const int kOfficerCardsFieldNumber = 1;
  inline const ::main::OfficerCardItemProto& officercards() const;
  inline ::main::OfficerCardItemProto* mutable_officercards();
  inline ::main::OfficerCardItemProto* release_officercards();
  inline void set_allocated_officercards(::main::OfficerCardItemProto* officercards);

  // optional .main.EquipmentCardItemProto equipmentCards = 2;
  inline bool has_equipmentcards() const;
  inline void clear_equipmentcards();
  static const int kEquipmentCardsFieldNumber = 2;
  inline const ::main::EquipmentCardItemProto& equipmentcards() const;
  inline ::main::EquipmentCardItemProto* mutable_equipmentcards();
  inline ::main::EquipmentCardItemProto* release_equipmentcards();
  inline void set_allocated_equipmentcards(::main::EquipmentCardItemProto* equipmentcards);

  // optional .main.PropsCardItemProto propsCards = 3;
  inline bool has_propscards() const;
  inline void clear_propscards();
  static const int kPropsCardsFieldNumber = 3;
  inline const ::main::PropsCardItemProto& propscards() const;
  inline ::main::PropsCardItemProto* mutable_propscards();
  inline ::main::PropsCardItemProto* release_propscards();
  inline void set_allocated_propscards(::main::PropsCardItemProto* propscards);

  // optional .main.OfficerFragmentCardItemProto fragmentCards = 4;
  inline bool has_fragmentcards() const;
  inline void clear_fragmentcards();
  static const int kFragmentCardsFieldNumber = 4;
  inline const ::main::OfficerFragmentCardItemProto& fragmentcards() const;
  inline ::main::OfficerFragmentCardItemProto* mutable_fragmentcards();
  inline ::main::OfficerFragmentCardItemProto* release_fragmentcards();
  inline void set_allocated_fragmentcards(::main::OfficerFragmentCardItemProto* fragmentcards);

  // optional .main.ConsumableCardItemProto consumableCards = 5;
  inline bool has_consumablecards() const;
  inline void clear_consumablecards();
  static const int kConsumableCardsFieldNumber = 5;
  inline const ::main::ConsumableCardItemProto& consumablecards() const;
  inline ::main::ConsumableCardItemProto* mutable_consumablecards();
  inline ::main::ConsumableCardItemProto* release_consumablecards();
  inline void set_allocated_consumablecards(::main::ConsumableCardItemProto* consumablecards);

  // optional .main.MaterialItemProto materialItemProtos = 6;
  inline bool has_materialitemprotos() const;
  inline void clear_materialitemprotos();
  static const int kMaterialItemProtosFieldNumber = 6;
  inline const ::main::MaterialItemProto& materialitemprotos() const;
  inline ::main::MaterialItemProto* mutable_materialitemprotos();
  inline ::main::MaterialItemProto* release_materialitemprotos();
  inline void set_allocated_materialitemprotos(::main::MaterialItemProto* materialitemprotos);

  // repeated .main.ItemDataProto itemData = 7;
  inline int itemdata_size() const;
  inline void clear_itemdata();
  static const int kItemDataFieldNumber = 7;
  inline const ::main::ItemDataProto& itemdata(int index) const;
  inline ::main::ItemDataProto* mutable_itemdata(int index);
  inline ::main::ItemDataProto* add_itemdata();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ItemDataProto >&
      itemdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ItemDataProto >*
      mutable_itemdata();

  // @@protoc_insertion_point(class_scope:main.FightRewardDropItems)
 private:
  inline void set_has_officercards();
  inline void clear_has_officercards();
  inline void set_has_equipmentcards();
  inline void clear_has_equipmentcards();
  inline void set_has_propscards();
  inline void clear_has_propscards();
  inline void set_has_fragmentcards();
  inline void clear_has_fragmentcards();
  inline void set_has_consumablecards();
  inline void clear_has_consumablecards();
  inline void set_has_materialitemprotos();
  inline void clear_has_materialitemprotos();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::OfficerCardItemProto* officercards_;
  ::main::EquipmentCardItemProto* equipmentcards_;
  ::main::PropsCardItemProto* propscards_;
  ::main::OfficerFragmentCardItemProto* fragmentcards_;
  ::main::ConsumableCardItemProto* consumablecards_;
  ::main::MaterialItemProto* materialitemprotos_;
  ::google::protobuf::RepeatedPtrField< ::main::ItemDataProto > itemdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightRewardDropItems* default_instance_;
};
// -------------------------------------------------------------------

class FightRunAwayRequest : public ::google::protobuf::MessageLite {
 public:
  FightRunAwayRequest();
  virtual ~FightRunAwayRequest();

  FightRunAwayRequest(const FightRunAwayRequest& from);

  inline FightRunAwayRequest& operator=(const FightRunAwayRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightRunAwayRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRunAwayRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRunAwayRequest* other);

  // implements Message ----------------------------------------------

  FightRunAwayRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRunAwayRequest& from);
  void MergeFrom(const FightRunAwayRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.FightRunAwayRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightRunAwayRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightRunAwayResponse : public ::google::protobuf::MessageLite {
 public:
  FightRunAwayResponse();
  virtual ~FightRunAwayResponse();

  FightRunAwayResponse(const FightRunAwayResponse& from);

  inline FightRunAwayResponse& operator=(const FightRunAwayResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightRunAwayResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRunAwayResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRunAwayResponse* other);

  // implements Message ----------------------------------------------

  FightRunAwayResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRunAwayResponse& from);
  void MergeFrom(const FightRunAwayResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 rating = 2;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 2;
  inline ::google::protobuf::int32 rating() const;
  inline void set_rating(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 gold = 4;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 4;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional float hpRate = 5;
  inline bool has_hprate() const;
  inline void clear_hprate();
  static const int kHpRateFieldNumber = 5;
  inline float hprate() const;
  inline void set_hprate(float value);

  // optional int32 addExp = 6;
  inline bool has_addexp() const;
  inline void clear_addexp();
  static const int kAddExpFieldNumber = 6;
  inline ::google::protobuf::int32 addexp() const;
  inline void set_addexp(::google::protobuf::int32 value);

  // optional sint32 currHp = 7;
  inline bool has_currhp() const;
  inline void clear_currhp();
  static const int kCurrHpFieldNumber = 7;
  inline ::google::protobuf::int32 currhp() const;
  inline void set_currhp(::google::protobuf::int32 value);

  // optional sint32 bashHp = 8;
  inline bool has_bashhp() const;
  inline void clear_bashhp();
  static const int kBashHpFieldNumber = 8;
  inline ::google::protobuf::int32 bashhp() const;
  inline void set_bashhp(::google::protobuf::int32 value);

  // optional int32 isRunAway = 9;
  inline bool has_isrunaway() const;
  inline void clear_isrunaway();
  static const int kIsRunAwayFieldNumber = 9;
  inline ::google::protobuf::int32 isrunaway() const;
  inline void set_isrunaway(::google::protobuf::int32 value);

  // optional int32 round = 10;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 10;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightRunAwayResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_hprate();
  inline void clear_has_hprate();
  inline void set_has_addexp();
  inline void clear_has_addexp();
  inline void set_has_currhp();
  inline void clear_has_currhp();
  inline void set_has_bashhp();
  inline void clear_has_bashhp();
  inline void set_has_isrunaway();
  inline void clear_has_isrunaway();
  inline void set_has_round();
  inline void clear_has_round();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 rating_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 gold_;
  float hprate_;
  ::google::protobuf::int32 addexp_;
  ::google::protobuf::int32 currhp_;
  ::google::protobuf::int32 bashhp_;
  ::google::protobuf::int32 isrunaway_;
  ::google::protobuf::int32 round_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightRunAwayResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnemyExitResponse : public ::google::protobuf::MessageLite {
 public:
  EnemyExitResponse();
  virtual ~EnemyExitResponse();

  EnemyExitResponse(const EnemyExitResponse& from);

  inline EnemyExitResponse& operator=(const EnemyExitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EnemyExitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnemyExitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnemyExitResponse* other);

  // implements Message ----------------------------------------------

  EnemyExitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnemyExitResponse& from);
  void MergeFrom(const EnemyExitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.EnemyExitResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static EnemyExitResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnemyResumeResponse : public ::google::protobuf::MessageLite {
 public:
  EnemyResumeResponse();
  virtual ~EnemyResumeResponse();

  EnemyResumeResponse(const EnemyResumeResponse& from);

  inline EnemyResumeResponse& operator=(const EnemyResumeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EnemyResumeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnemyResumeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnemyResumeResponse* other);

  // implements Message ----------------------------------------------

  EnemyResumeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnemyResumeResponse& from);
  void MergeFrom(const EnemyResumeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.EnemyResumeResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static EnemyResumeResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightLogRequest : public ::google::protobuf::MessageLite {
 public:
  FightLogRequest();
  virtual ~FightLogRequest();

  FightLogRequest(const FightLogRequest& from);

  inline FightLogRequest& operator=(const FightLogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightLogRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightLogRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightLogRequest* other);

  // implements Message ----------------------------------------------

  FightLogRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightLogRequest& from);
  void MergeFrom(const FightLogRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:main.FightLogRequest)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* str_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightReviveRequest : public ::google::protobuf::MessageLite {
 public:
  FightReviveRequest();
  virtual ~FightReviveRequest();

  FightReviveRequest(const FightReviveRequest& from);

  inline FightReviveRequest& operator=(const FightReviveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightReviveRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightReviveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightReviveRequest* other);

  // implements Message ----------------------------------------------

  FightReviveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightReviveRequest& from);
  void MergeFrom(const FightReviveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 isRevive = 1;
  inline bool has_isrevive() const;
  inline void clear_isrevive();
  static const int kIsReviveFieldNumber = 1;
  inline ::google::protobuf::int32 isrevive() const;
  inline void set_isrevive(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightReviveRequest)
 private:
  inline void set_has_isrevive();
  inline void clear_has_isrevive();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 isrevive_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightReviveRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightReviveResponse : public ::google::protobuf::MessageLite {
 public:
  FightReviveResponse();
  virtual ~FightReviveResponse();

  FightReviveResponse(const FightReviveResponse& from);

  inline FightReviveResponse& operator=(const FightReviveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightReviveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightReviveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightReviveResponse* other);

  // implements Message ----------------------------------------------

  FightReviveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightReviveResponse& from);
  void MergeFrom(const FightReviveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightReviveResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightReviveResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightFixMapRequest : public ::google::protobuf::MessageLite {
 public:
  FightFixMapRequest();
  virtual ~FightFixMapRequest();

  FightFixMapRequest(const FightFixMapRequest& from);

  inline FightFixMapRequest& operator=(const FightFixMapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightFixMapRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightFixMapRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightFixMapRequest* other);

  // implements Message ----------------------------------------------

  FightFixMapRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightFixMapRequest& from);
  void MergeFrom(const FightFixMapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightFixMapRequest)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 roleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightFixMapRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightFixMapResponse : public ::google::protobuf::MessageLite {
 public:
  FightFixMapResponse();
  virtual ~FightFixMapResponse();

  FightFixMapResponse(const FightFixMapResponse& from);

  inline FightFixMapResponse& operator=(const FightFixMapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightFixMapResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightFixMapResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightFixMapResponse* other);

  // implements Message ----------------------------------------------

  FightFixMapResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightFixMapResponse& from);
  void MergeFrom(const FightFixMapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional int32 freeCount = 2;
  inline bool has_freecount() const;
  inline void clear_freecount();
  static const int kFreeCountFieldNumber = 2;
  inline ::google::protobuf::int32 freecount() const;
  inline void set_freecount(::google::protobuf::int32 value);

  // optional int32 actionCount = 3;
  inline bool has_actioncount() const;
  inline void clear_actioncount();
  static const int kActionCountFieldNumber = 3;
  inline ::google::protobuf::int32 actioncount() const;
  inline void set_actioncount(::google::protobuf::int32 value);

  // optional int32 baseHp = 4;
  inline bool has_basehp() const;
  inline void clear_basehp();
  static const int kBaseHpFieldNumber = 4;
  inline ::google::protobuf::int32 basehp() const;
  inline void set_basehp(::google::protobuf::int32 value);

  // optional int32 hp = 5;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 5;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 majorSkillCurrentRound = 6;
  inline bool has_majorskillcurrentround() const;
  inline void clear_majorskillcurrentround();
  static const int kMajorSkillCurrentRoundFieldNumber = 6;
  inline ::google::protobuf::int32 majorskillcurrentround() const;
  inline void set_majorskillcurrentround(::google::protobuf::int32 value);

  // repeated .main.FightSpirit spirits = 7;
  inline int spirits_size() const;
  inline void clear_spirits();
  static const int kSpiritsFieldNumber = 7;
  inline const ::main::FightSpirit& spirits(int index) const;
  inline ::main::FightSpirit* mutable_spirits(int index);
  inline ::main::FightSpirit* add_spirits();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
      spirits() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
      mutable_spirits();

  // repeated .main.FightFixAttackUnit attackList = 8;
  inline int attacklist_size() const;
  inline void clear_attacklist();
  static const int kAttackListFieldNumber = 8;
  inline const ::main::FightFixAttackUnit& attacklist(int index) const;
  inline ::main::FightFixAttackUnit* mutable_attacklist(int index);
  inline ::main::FightFixAttackUnit* add_attacklist();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightFixAttackUnit >&
      attacklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightFixAttackUnit >*
      mutable_attacklist();

  // optional int32 cooRound = 9;
  inline bool has_cooround() const;
  inline void clear_cooround();
  static const int kCooRoundFieldNumber = 9;
  inline ::google::protobuf::int32 cooround() const;
  inline void set_cooround(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightFixMapResponse)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_freecount();
  inline void clear_has_freecount();
  inline void set_has_actioncount();
  inline void clear_has_actioncount();
  inline void set_has_basehp();
  inline void clear_has_basehp();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_majorskillcurrentround();
  inline void clear_has_majorskillcurrentround();
  inline void set_has_cooround();
  inline void clear_has_cooround();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 freecount_;
  ::google::protobuf::int32 actioncount_;
  ::google::protobuf::int32 basehp_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 majorskillcurrentround_;
  ::google::protobuf::RepeatedPtrField< ::main::FightSpirit > spirits_;
  ::google::protobuf::RepeatedPtrField< ::main::FightFixAttackUnit > attacklist_;
  ::google::protobuf::int32 cooround_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightFixMapResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightFixAttackUnit : public ::google::protobuf::MessageLite {
 public:
  FightFixAttackUnit();
  virtual ~FightFixAttackUnit();

  FightFixAttackUnit(const FightFixAttackUnit& from);

  inline FightFixAttackUnit& operator=(const FightFixAttackUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightFixAttackUnit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightFixAttackUnit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightFixAttackUnit* other);

  // implements Message ----------------------------------------------

  FightFixAttackUnit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightFixAttackUnit& from);
  void MergeFrom(const FightFixAttackUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 currentRound = 3;
  inline bool has_currentround() const;
  inline void clear_currentround();
  static const int kCurrentRoundFieldNumber = 3;
  inline ::google::protobuf::int32 currentround() const;
  inline void set_currentround(::google::protobuf::int32 value);

  // optional int32 currentAttack = 4;
  inline bool has_currentattack() const;
  inline void clear_currentattack();
  static const int kCurrentAttackFieldNumber = 4;
  inline ::google::protobuf::int32 currentattack() const;
  inline void set_currentattack(::google::protobuf::int32 value);

  // optional int32 currentChainCount = 5;
  inline bool has_currentchaincount() const;
  inline void clear_currentchaincount();
  static const int kCurrentChainCountFieldNumber = 5;
  inline ::google::protobuf::int32 currentchaincount() const;
  inline void set_currentchaincount(::google::protobuf::int32 value);

  // optional int32 currentMergeCount = 6;
  inline bool has_currentmergecount() const;
  inline void clear_currentmergecount();
  static const int kCurrentMergeCountFieldNumber = 6;
  inline ::google::protobuf::int32 currentmergecount() const;
  inline void set_currentmergecount(::google::protobuf::int32 value);

  // repeated .main.FightFixBuff buffList = 7;
  inline int bufflist_size() const;
  inline void clear_bufflist();
  static const int kBuffListFieldNumber = 7;
  inline const ::main::FightFixBuff& bufflist(int index) const;
  inline ::main::FightFixBuff* mutable_bufflist(int index);
  inline ::main::FightFixBuff* add_bufflist();
  inline const ::google::protobuf::RepeatedPtrField< ::main::FightFixBuff >&
      bufflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::FightFixBuff >*
      mutable_bufflist();

  // optional int32 acceptAmage = 8;
  inline bool has_acceptamage() const;
  inline void clear_acceptamage();
  static const int kAcceptAmageFieldNumber = 8;
  inline ::google::protobuf::int32 acceptamage() const;
  inline void set_acceptamage(::google::protobuf::int32 value);

  // optional bool ishasFuhuo = 9;
  inline bool has_ishasfuhuo() const;
  inline void clear_ishasfuhuo();
  static const int kIshasFuhuoFieldNumber = 9;
  inline bool ishasfuhuo() const;
  inline void set_ishasfuhuo(bool value);

  // optional bool isFuhuo = 10;
  inline bool has_isfuhuo() const;
  inline void clear_isfuhuo();
  static const int kIsFuhuoFieldNumber = 10;
  inline bool isfuhuo() const;
  inline void set_isfuhuo(bool value);

  // @@protoc_insertion_point(class_scope:main.FightFixAttackUnit)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_currentround();
  inline void clear_has_currentround();
  inline void set_has_currentattack();
  inline void clear_has_currentattack();
  inline void set_has_currentchaincount();
  inline void clear_has_currentchaincount();
  inline void set_has_currentmergecount();
  inline void clear_has_currentmergecount();
  inline void set_has_acceptamage();
  inline void clear_has_acceptamage();
  inline void set_has_ishasfuhuo();
  inline void clear_has_ishasfuhuo();
  inline void set_has_isfuhuo();
  inline void clear_has_isfuhuo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 currentround_;
  ::google::protobuf::int32 currentattack_;
  ::google::protobuf::int32 currentchaincount_;
  ::google::protobuf::int32 currentmergecount_;
  ::google::protobuf::RepeatedPtrField< ::main::FightFixBuff > bufflist_;
  ::google::protobuf::int32 acceptamage_;
  bool ishasfuhuo_;
  bool isfuhuo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightFixAttackUnit* default_instance_;
};
// -------------------------------------------------------------------

class FightFixBuff : public ::google::protobuf::MessageLite {
 public:
  FightFixBuff();
  virtual ~FightFixBuff();

  FightFixBuff(const FightFixBuff& from);

  inline FightFixBuff& operator=(const FightFixBuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightFixBuff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightFixBuff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightFixBuff* other);

  // implements Message ----------------------------------------------

  FightFixBuff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightFixBuff& from);
  void MergeFrom(const FightFixBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 buffId = 1;
  inline bool has_buffid() const;
  inline void clear_buffid();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::int32 buffid() const;
  inline void set_buffid(::google::protobuf::int32 value);

  // optional int32 buffType = 2;
  inline bool has_bufftype() const;
  inline void clear_bufftype();
  static const int kBuffTypeFieldNumber = 2;
  inline ::google::protobuf::int32 bufftype() const;
  inline void set_bufftype(::google::protobuf::int32 value);

  // optional int32 buffRound = 3;
  inline bool has_buffround() const;
  inline void clear_buffround();
  static const int kBuffRoundFieldNumber = 3;
  inline ::google::protobuf::int32 buffround() const;
  inline void set_buffround(::google::protobuf::int32 value);

  // optional float buffRoundValue = 4;
  inline bool has_buffroundvalue() const;
  inline void clear_buffroundvalue();
  static const int kBuffRoundValueFieldNumber = 4;
  inline float buffroundvalue() const;
  inline void set_buffroundvalue(float value);

  // optional int32 buffEffect = 5;
  inline bool has_buffeffect() const;
  inline void clear_buffeffect();
  static const int kBuffEffectFieldNumber = 5;
  inline ::google::protobuf::int32 buffeffect() const;
  inline void set_buffeffect(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightFixBuff)
 private:
  inline void set_has_buffid();
  inline void clear_has_buffid();
  inline void set_has_bufftype();
  inline void clear_has_bufftype();
  inline void set_has_buffround();
  inline void clear_has_buffround();
  inline void set_has_buffroundvalue();
  inline void clear_has_buffroundvalue();
  inline void set_has_buffeffect();
  inline void clear_has_buffeffect();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 buffid_;
  ::google::protobuf::int32 bufftype_;
  ::google::protobuf::int32 buffround_;
  float buffroundvalue_;
  ::google::protobuf::int32 buffeffect_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightFixBuff* default_instance_;
};
// -------------------------------------------------------------------

class EnterBossRequest : public ::google::protobuf::MessageLite {
 public:
  EnterBossRequest();
  virtual ~EnterBossRequest();

  EnterBossRequest(const EnterBossRequest& from);

  inline EnterBossRequest& operator=(const EnterBossRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EnterBossRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterBossRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterBossRequest* other);

  // implements Message ----------------------------------------------

  EnterBossRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterBossRequest& from);
  void MergeFrom(const EnterBossRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.EnterBossRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static EnterBossRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnterBossResponse : public ::google::protobuf::MessageLite {
 public:
  EnterBossResponse();
  virtual ~EnterBossResponse();

  EnterBossResponse(const EnterBossResponse& from);

  inline EnterBossResponse& operator=(const EnterBossResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EnterBossResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterBossResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterBossResponse* other);

  // implements Message ----------------------------------------------

  EnterBossResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterBossResponse& from);
  void MergeFrom(const EnterBossResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bossHp = 1;
  inline bool has_bosshp() const;
  inline void clear_bosshp();
  static const int kBossHpFieldNumber = 1;
  inline ::google::protobuf::int32 bosshp() const;
  inline void set_bosshp(::google::protobuf::int32 value);

  // optional int32 bossBaseHp = 2;
  inline bool has_bossbasehp() const;
  inline void clear_bossbasehp();
  static const int kBossBaseHpFieldNumber = 2;
  inline ::google::protobuf::int32 bossbasehp() const;
  inline void set_bossbasehp(::google::protobuf::int32 value);

  // optional int32 bossDamageCount = 3;
  inline bool has_bossdamagecount() const;
  inline void clear_bossdamagecount();
  static const int kBossDamageCountFieldNumber = 3;
  inline ::google::protobuf::int32 bossdamagecount() const;
  inline void set_bossdamagecount(::google::protobuf::int32 value);

  // repeated .main.BossBuffModel bossBuffModel = 4;
  inline int bossbuffmodel_size() const;
  inline void clear_bossbuffmodel();
  static const int kBossBuffModelFieldNumber = 4;
  inline const ::main::BossBuffModel& bossbuffmodel(int index) const;
  inline ::main::BossBuffModel* mutable_bossbuffmodel(int index);
  inline ::main::BossBuffModel* add_bossbuffmodel();
  inline const ::google::protobuf::RepeatedPtrField< ::main::BossBuffModel >&
      bossbuffmodel() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::BossBuffModel >*
      mutable_bossbuffmodel();

  // repeated .main.BossRankModel bossRankModel = 5;
  inline int bossrankmodel_size() const;
  inline void clear_bossrankmodel();
  static const int kBossRankModelFieldNumber = 5;
  inline const ::main::BossRankModel& bossrankmodel(int index) const;
  inline ::main::BossRankModel* mutable_bossrankmodel(int index);
  inline ::main::BossRankModel* add_bossrankmodel();
  inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >&
      bossrankmodel() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >*
      mutable_bossrankmodel();

  // optional bool state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline bool state() const;
  inline void set_state(bool value);

  // optional string errMsg = 7;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrMsgFieldNumber = 7;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional int32 time = 8;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 value1 = 9;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 9;
  inline ::google::protobuf::int32 value1() const;
  inline void set_value1(::google::protobuf::int32 value);

  // optional float value2 = 10;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 10;
  inline float value2() const;
  inline void set_value2(float value);

  // optional int32 value3 = 11;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 11;
  inline ::google::protobuf::int32 value3() const;
  inline void set_value3(::google::protobuf::int32 value);

  // optional sint32 damage = 12;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 12;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.EnterBossResponse)
 private:
  inline void set_has_bosshp();
  inline void clear_has_bosshp();
  inline void set_has_bossbasehp();
  inline void clear_has_bossbasehp();
  inline void set_has_bossdamagecount();
  inline void clear_has_bossdamagecount();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 bosshp_;
  ::google::protobuf::int32 bossbasehp_;
  ::google::protobuf::RepeatedPtrField< ::main::BossBuffModel > bossbuffmodel_;
  ::google::protobuf::int32 bossdamagecount_;
  bool state_;
  ::google::protobuf::RepeatedPtrField< ::main::BossRankModel > bossrankmodel_;
  ::std::string* errmsg_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 value1_;
  float value2_;
  ::google::protobuf::int32 value3_;
  ::google::protobuf::int32 damage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static EnterBossResponse* default_instance_;
};
// -------------------------------------------------------------------

class BossBuffModel : public ::google::protobuf::MessageLite {
 public:
  BossBuffModel();
  virtual ~BossBuffModel();

  BossBuffModel(const BossBuffModel& from);

  inline BossBuffModel& operator=(const BossBuffModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossBuffModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossBuffModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossBuffModel* other);

  // implements Message ----------------------------------------------

  BossBuffModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossBuffModel& from);
  void MergeFrom(const BossBuffModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 buffId = 1;
  inline bool has_buffid() const;
  inline void clear_buffid();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::int32 buffid() const;
  inline void set_buffid(::google::protobuf::int32 value);

  // optional string buffName = 3;
  inline bool has_buffname() const;
  inline void clear_buffname();
  static const int kBuffNameFieldNumber = 3;
  inline const ::std::string& buffname() const;
  inline void set_buffname(const ::std::string& value);
  inline void set_buffname(const char* value);
  inline void set_buffname(const char* value, size_t size);
  inline ::std::string* mutable_buffname();
  inline ::std::string* release_buffname();
  inline void set_allocated_buffname(::std::string* buffname);

  // optional int32 buffGold = 4;
  inline bool has_buffgold() const;
  inline void clear_buffgold();
  static const int kBuffGoldFieldNumber = 4;
  inline ::google::protobuf::int32 buffgold() const;
  inline void set_buffgold(::google::protobuf::int32 value);

  // optional int32 buffBasValue = 5;
  inline bool has_buffbasvalue() const;
  inline void clear_buffbasvalue();
  static const int kBuffBasValueFieldNumber = 5;
  inline ::google::protobuf::int32 buffbasvalue() const;
  inline void set_buffbasvalue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.BossBuffModel)
 private:
  inline void set_has_buffid();
  inline void clear_has_buffid();
  inline void set_has_buffname();
  inline void clear_has_buffname();
  inline void set_has_buffgold();
  inline void clear_has_buffgold();
  inline void set_has_buffbasvalue();
  inline void clear_has_buffbasvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* buffname_;
  ::google::protobuf::int32 buffid_;
  ::google::protobuf::int32 buffgold_;
  ::google::protobuf::int32 buffbasvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossBuffModel* default_instance_;
};
// -------------------------------------------------------------------

class BossRankModel : public ::google::protobuf::MessageLite {
 public:
  BossRankModel();
  virtual ~BossRankModel();

  BossRankModel(const BossRankModel& from);

  inline BossRankModel& operator=(const BossRankModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossRankModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossRankModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossRankModel* other);

  // implements Message ----------------------------------------------

  BossRankModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossRankModel& from);
  void MergeFrom(const BossRankModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional string roleName = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.BossRankModel)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rolename_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 damage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossRankModel* default_instance_;
};
// -------------------------------------------------------------------

class AtkBossRequest : public ::google::protobuf::MessageLite {
 public:
  AtkBossRequest();
  virtual ~AtkBossRequest();

  AtkBossRequest(const AtkBossRequest& from);

  inline AtkBossRequest& operator=(const AtkBossRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AtkBossRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AtkBossRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AtkBossRequest* other);

  // implements Message ----------------------------------------------

  AtkBossRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AtkBossRequest& from);
  void MergeFrom(const AtkBossRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.AtkBossRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static AtkBossRequest* default_instance_;
};
// -------------------------------------------------------------------

class AtkBossResponse : public ::google::protobuf::MessageLite {
 public:
  AtkBossResponse();
  virtual ~AtkBossResponse();

  AtkBossResponse(const AtkBossResponse& from);

  inline AtkBossResponse& operator=(const AtkBossResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AtkBossResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AtkBossResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AtkBossResponse* other);

  // implements Message ----------------------------------------------

  AtkBossResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AtkBossResponse& from);
  void MergeFrom(const AtkBossResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bossItemId = 1;
  inline bool has_bossitemid() const;
  inline void clear_bossitemid();
  static const int kBossItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 bossitemid() const;
  inline void set_bossitemid(::google::protobuf::int32 value);

  // optional int32 bossHp = 2;
  inline bool has_bosshp() const;
  inline void clear_bosshp();
  static const int kBossHpFieldNumber = 2;
  inline ::google::protobuf::int32 bosshp() const;
  inline void set_bosshp(::google::protobuf::int32 value);

  // optional int32 bossBaseHp = 3;
  inline bool has_bossbasehp() const;
  inline void clear_bossbasehp();
  static const int kBossBaseHpFieldNumber = 3;
  inline ::google::protobuf::int32 bossbasehp() const;
  inline void set_bossbasehp(::google::protobuf::int32 value);

  // optional int32 roleItemId = 4;
  inline bool has_roleitemid() const;
  inline void clear_roleitemid();
  static const int kRoleItemIdFieldNumber = 4;
  inline ::google::protobuf::int32 roleitemid() const;
  inline void set_roleitemid(::google::protobuf::int32 value);

  // optional sint32 lordType = 8;
  inline bool has_lordtype() const;
  inline void clear_lordtype();
  static const int kLordTypeFieldNumber = 8;
  inline ::google::protobuf::int32 lordtype() const;
  inline void set_lordtype(::google::protobuf::int32 value);

  // optional int32 roledamage = 5;
  inline bool has_roledamage() const;
  inline void clear_roledamage();
  static const int kRoledamageFieldNumber = 5;
  inline ::google::protobuf::int32 roledamage() const;
  inline void set_roledamage(::google::protobuf::int32 value);

  // optional bool state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline bool state() const;
  inline void set_state(bool value);

  // optional string errMsg = 7;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrMsgFieldNumber = 7;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional bool isCrit = 9;
  inline bool has_iscrit() const;
  inline void clear_iscrit();
  static const int kIsCritFieldNumber = 9;
  inline bool iscrit() const;
  inline void set_iscrit(bool value);

  // optional sint32 coins = 10;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 10;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // optional sint32 medal = 11;
  inline bool has_medal() const;
  inline void clear_medal();
  static const int kMedalFieldNumber = 11;
  inline ::google::protobuf::int32 medal() const;
  inline void set_medal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.AtkBossResponse)
 private:
  inline void set_has_bossitemid();
  inline void clear_has_bossitemid();
  inline void set_has_bosshp();
  inline void clear_has_bosshp();
  inline void set_has_bossbasehp();
  inline void clear_has_bossbasehp();
  inline void set_has_roleitemid();
  inline void clear_has_roleitemid();
  inline void set_has_lordtype();
  inline void clear_has_lordtype();
  inline void set_has_roledamage();
  inline void clear_has_roledamage();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_iscrit();
  inline void clear_has_iscrit();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_medal();
  inline void clear_has_medal();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 bossitemid_;
  ::google::protobuf::int32 bosshp_;
  ::google::protobuf::int32 bossbasehp_;
  ::google::protobuf::int32 roleitemid_;
  ::google::protobuf::int32 lordtype_;
  ::google::protobuf::int32 roledamage_;
  ::std::string* errmsg_;
  bool state_;
  bool iscrit_;
  ::google::protobuf::int32 coins_;
  ::google::protobuf::int32 medal_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static AtkBossResponse* default_instance_;
};
// -------------------------------------------------------------------

class BossCurrStateRequest : public ::google::protobuf::MessageLite {
 public:
  BossCurrStateRequest();
  virtual ~BossCurrStateRequest();

  BossCurrStateRequest(const BossCurrStateRequest& from);

  inline BossCurrStateRequest& operator=(const BossCurrStateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossCurrStateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossCurrStateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossCurrStateRequest* other);

  // implements Message ----------------------------------------------

  BossCurrStateRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossCurrStateRequest& from);
  void MergeFrom(const BossCurrStateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.BossCurrStateRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossCurrStateRequest* default_instance_;
};
// -------------------------------------------------------------------

class BossCurrStateResponse : public ::google::protobuf::MessageLite {
 public:
  BossCurrStateResponse();
  virtual ~BossCurrStateResponse();

  BossCurrStateResponse(const BossCurrStateResponse& from);

  inline BossCurrStateResponse& operator=(const BossCurrStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossCurrStateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossCurrStateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossCurrStateResponse* other);

  // implements Message ----------------------------------------------

  BossCurrStateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossCurrStateResponse& from);
  void MergeFrom(const BossCurrStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bossHp = 1;
  inline bool has_bosshp() const;
  inline void clear_bosshp();
  static const int kBossHpFieldNumber = 1;
  inline ::google::protobuf::int32 bosshp() const;
  inline void set_bosshp(::google::protobuf::int32 value);

  // optional int32 bossBaseHp = 2;
  inline bool has_bossbasehp() const;
  inline void clear_bossbasehp();
  static const int kBossBaseHpFieldNumber = 2;
  inline ::google::protobuf::int32 bossbasehp() const;
  inline void set_bossbasehp(::google::protobuf::int32 value);

  // repeated .main.BossRankModel bossRankModel = 3;
  inline int bossrankmodel_size() const;
  inline void clear_bossrankmodel();
  static const int kBossRankModelFieldNumber = 3;
  inline const ::main::BossRankModel& bossrankmodel(int index) const;
  inline ::main::BossRankModel* mutable_bossrankmodel(int index);
  inline ::main::BossRankModel* add_bossrankmodel();
  inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >&
      bossrankmodel() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >*
      mutable_bossrankmodel();

  // @@protoc_insertion_point(class_scope:main.BossCurrStateResponse)
 private:
  inline void set_has_bosshp();
  inline void clear_has_bosshp();
  inline void set_has_bossbasehp();
  inline void clear_has_bossbasehp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 bosshp_;
  ::google::protobuf::int32 bossbasehp_;
  ::google::protobuf::RepeatedPtrField< ::main::BossRankModel > bossrankmodel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossCurrStateResponse* default_instance_;
};
// -------------------------------------------------------------------

class MainBossRequest : public ::google::protobuf::MessageLite {
 public:
  MainBossRequest();
  virtual ~MainBossRequest();

  MainBossRequest(const MainBossRequest& from);

  inline MainBossRequest& operator=(const MainBossRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MainBossRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MainBossRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MainBossRequest* other);

  // implements Message ----------------------------------------------

  MainBossRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MainBossRequest& from);
  void MergeFrom(const MainBossRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.MainBossRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MainBossRequest* default_instance_;
};
// -------------------------------------------------------------------

class MainBossResponse : public ::google::protobuf::MessageLite {
 public:
  MainBossResponse();
  virtual ~MainBossResponse();

  MainBossResponse(const MainBossResponse& from);

  inline MainBossResponse& operator=(const MainBossResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MainBossResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MainBossResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MainBossResponse* other);

  // implements Message ----------------------------------------------

  MainBossResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MainBossResponse& from);
  void MergeFrom(const MainBossResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional sint32 bossLevel = 2;
  inline bool has_bosslevel() const;
  inline void clear_bosslevel();
  static const int kBossLevelFieldNumber = 2;
  inline ::google::protobuf::int32 bosslevel() const;
  inline void set_bosslevel(::google::protobuf::int32 value);

  // optional sint64 residueTime = 3;
  inline bool has_residuetime() const;
  inline void clear_residuetime();
  static const int kResidueTimeFieldNumber = 3;
  inline ::google::protobuf::int64 residuetime() const;
  inline void set_residuetime(::google::protobuf::int64 value);

  // optional string theFirstThree = 4;
  inline bool has_thefirstthree() const;
  inline void clear_thefirstthree();
  static const int kTheFirstThreeFieldNumber = 4;
  inline const ::std::string& thefirstthree() const;
  inline void set_thefirstthree(const ::std::string& value);
  inline void set_thefirstthree(const char* value);
  inline void set_thefirstthree(const char* value, size_t size);
  inline ::std::string* mutable_thefirstthree();
  inline ::std::string* release_thefirstthree();
  inline void set_allocated_thefirstthree(::std::string* thefirstthree);

  // optional string slayInfo = 5;
  inline bool has_slayinfo() const;
  inline void clear_slayinfo();
  static const int kSlayInfoFieldNumber = 5;
  inline const ::std::string& slayinfo() const;
  inline void set_slayinfo(const ::std::string& value);
  inline void set_slayinfo(const char* value);
  inline void set_slayinfo(const char* value, size_t size);
  inline ::std::string* mutable_slayinfo();
  inline ::std::string* release_slayinfo();
  inline void set_allocated_slayinfo(::std::string* slayinfo);

  // optional sint32 startedTime = 6;
  inline bool has_startedtime() const;
  inline void clear_startedtime();
  static const int kStartedTimeFieldNumber = 6;
  inline ::google::protobuf::int32 startedtime() const;
  inline void set_startedtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.MainBossResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_bosslevel();
  inline void clear_has_bosslevel();
  inline void set_has_residuetime();
  inline void clear_has_residuetime();
  inline void set_has_thefirstthree();
  inline void clear_has_thefirstthree();
  inline void set_has_slayinfo();
  inline void clear_has_slayinfo();
  inline void set_has_startedtime();
  inline void clear_has_startedtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 bosslevel_;
  ::google::protobuf::int64 residuetime_;
  ::std::string* thefirstthree_;
  ::std::string* slayinfo_;
  ::google::protobuf::int32 startedtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static MainBossResponse* default_instance_;
};
// -------------------------------------------------------------------

class BossDamageRankRequest : public ::google::protobuf::MessageLite {
 public:
  BossDamageRankRequest();
  virtual ~BossDamageRankRequest();

  BossDamageRankRequest(const BossDamageRankRequest& from);

  inline BossDamageRankRequest& operator=(const BossDamageRankRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossDamageRankRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossDamageRankRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossDamageRankRequest* other);

  // implements Message ----------------------------------------------

  BossDamageRankRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossDamageRankRequest& from);
  void MergeFrom(const BossDamageRankRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.BossDamageRankRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossDamageRankRequest* default_instance_;
};
// -------------------------------------------------------------------

class BossDamageRankResponse : public ::google::protobuf::MessageLite {
 public:
  BossDamageRankResponse();
  virtual ~BossDamageRankResponse();

  BossDamageRankResponse(const BossDamageRankResponse& from);

  inline BossDamageRankResponse& operator=(const BossDamageRankResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossDamageRankResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossDamageRankResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossDamageRankResponse* other);

  // implements Message ----------------------------------------------

  BossDamageRankResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossDamageRankResponse& from);
  void MergeFrom(const BossDamageRankResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.BossRankInfo bossRankInfo = 1;
  inline int bossrankinfo_size() const;
  inline void clear_bossrankinfo();
  static const int kBossRankInfoFieldNumber = 1;
  inline const ::main::BossRankInfo& bossrankinfo(int index) const;
  inline ::main::BossRankInfo* mutable_bossrankinfo(int index);
  inline ::main::BossRankInfo* add_bossrankinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankInfo >&
      bossrankinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::BossRankInfo >*
      mutable_bossrankinfo();

  // optional sint32 minute = 2;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 2;
  inline ::google::protobuf::int32 minute() const;
  inline void set_minute(::google::protobuf::int32 value);

  // optional string playerName = 3;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 3;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // optional sint64 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::int64 damage() const;
  inline void set_damage(::google::protobuf::int64 value);

  // optional sint32 selfDamage = 5;
  inline bool has_selfdamage() const;
  inline void clear_selfdamage();
  static const int kSelfDamageFieldNumber = 5;
  inline ::google::protobuf::int32 selfdamage() const;
  inline void set_selfdamage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.BossDamageRankResponse)
 private:
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_selfdamage();
  inline void clear_has_selfdamage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::BossRankInfo > bossrankinfo_;
  ::std::string* playername_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 selfdamage_;
  ::google::protobuf::int64 damage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossDamageRankResponse* default_instance_;
};
// -------------------------------------------------------------------

class BossRankInfo : public ::google::protobuf::MessageLite {
 public:
  BossRankInfo();
  virtual ~BossRankInfo();

  BossRankInfo(const BossRankInfo& from);

  inline BossRankInfo& operator=(const BossRankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossRankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossRankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossRankInfo* other);

  // implements Message ----------------------------------------------

  BossRankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossRankInfo& from);
  void MergeFrom(const BossRankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional string roleName = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // optional sint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional sint32 icon = 4;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 4;
  inline ::google::protobuf::int32 icon() const;
  inline void set_icon(::google::protobuf::int32 value);

  // optional sint32 country = 5;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 5;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional sint32 damage = 6;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 6;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // optional sint32 rankIndex = 7;
  inline bool has_rankindex() const;
  inline void clear_rankindex();
  static const int kRankIndexFieldNumber = 7;
  inline ::google::protobuf::int32 rankindex() const;
  inline void set_rankindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.BossRankInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_rankindex();
  inline void clear_has_rankindex();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rolename_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 icon_;
  ::google::protobuf::int32 country_;
  ::google::protobuf::int32 damage_;
  ::google::protobuf::int32 rankindex_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossRankInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetBossBuffRequest : public ::google::protobuf::MessageLite {
 public:
  GetBossBuffRequest();
  virtual ~GetBossBuffRequest();

  GetBossBuffRequest(const GetBossBuffRequest& from);

  inline GetBossBuffRequest& operator=(const GetBossBuffRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetBossBuffRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetBossBuffRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetBossBuffRequest* other);

  // implements Message ----------------------------------------------

  GetBossBuffRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetBossBuffRequest& from);
  void MergeFrom(const GetBossBuffRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.GetBossBuffRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static GetBossBuffRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetBossBuffResponse : public ::google::protobuf::MessageLite {
 public:
  GetBossBuffResponse();
  virtual ~GetBossBuffResponse();

  GetBossBuffResponse(const GetBossBuffResponse& from);

  inline GetBossBuffResponse& operator=(const GetBossBuffResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetBossBuffResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetBossBuffResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetBossBuffResponse* other);

  // implements Message ----------------------------------------------

  GetBossBuffResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetBossBuffResponse& from);
  void MergeFrom(const GetBossBuffResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional sint32 value1 = 2;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 2;
  inline ::google::protobuf::int32 value1() const;
  inline void set_value1(::google::protobuf::int32 value);

  // optional float value2 = 3;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 3;
  inline float value2() const;
  inline void set_value2(float value);

  // optional sint32 value3 = 4;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 4;
  inline ::google::protobuf::int32 value3() const;
  inline void set_value3(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.GetBossBuffResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 value1_;
  float value2_;
  ::google::protobuf::int32 value3_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static GetBossBuffResponse* default_instance_;
};
// -------------------------------------------------------------------

class BossEndRewardResponse : public ::google::protobuf::MessageLite {
 public:
  BossEndRewardResponse();
  virtual ~BossEndRewardResponse();

  BossEndRewardResponse(const BossEndRewardResponse& from);

  inline BossEndRewardResponse& operator=(const BossEndRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BossEndRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BossEndRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BossEndRewardResponse* other);

  // implements Message ----------------------------------------------

  BossEndRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BossEndRewardResponse& from);
  void MergeFrom(const BossEndRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rewardString = 1;
  inline bool has_rewardstring() const;
  inline void clear_rewardstring();
  static const int kRewardStringFieldNumber = 1;
  inline const ::std::string& rewardstring() const;
  inline void set_rewardstring(const ::std::string& value);
  inline void set_rewardstring(const char* value);
  inline void set_rewardstring(const char* value, size_t size);
  inline ::std::string* mutable_rewardstring();
  inline ::std::string* release_rewardstring();
  inline void set_allocated_rewardstring(::std::string* rewardstring);

  // @@protoc_insertion_point(class_scope:main.BossEndRewardResponse)
 private:
  inline void set_has_rewardstring();
  inline void clear_has_rewardstring();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rewardstring_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static BossEndRewardResponse* default_instance_;
};
// -------------------------------------------------------------------

class FightPvpRewardRequest : public ::google::protobuf::MessageLite {
 public:
  FightPvpRewardRequest();
  virtual ~FightPvpRewardRequest();

  FightPvpRewardRequest(const FightPvpRewardRequest& from);

  inline FightPvpRewardRequest& operator=(const FightPvpRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightPvpRewardRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightPvpRewardRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightPvpRewardRequest* other);

  // implements Message ----------------------------------------------

  FightPvpRewardRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightPvpRewardRequest& from);
  void MergeFrom(const FightPvpRewardRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 fightId = 1;
  inline bool has_fightid() const;
  inline void clear_fightid();
  static const int kFightIdFieldNumber = 1;
  inline ::google::protobuf::int64 fightid() const;
  inline void set_fightid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:main.FightPvpRewardRequest)
 private:
  inline void set_has_fightid();
  inline void clear_has_fightid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 fightid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightPvpRewardRequest* default_instance_;
};
// -------------------------------------------------------------------

class FightPvpRewardResponse : public ::google::protobuf::MessageLite {
 public:
  FightPvpRewardResponse();
  virtual ~FightPvpRewardResponse();

  FightPvpRewardResponse(const FightPvpRewardResponse& from);

  inline FightPvpRewardResponse& operator=(const FightPvpRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FightPvpRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightPvpRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightPvpRewardResponse* other);

  // implements Message ----------------------------------------------

  FightPvpRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightPvpRewardResponse& from);
  void MergeFrom(const FightPvpRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional bool isWin = 2;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 2;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // optional sint32 prestige = 3;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 3;
  inline ::google::protobuf::int32 prestige() const;
  inline void set_prestige(::google::protobuf::int32 value);

  // optional sint32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional sint32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional sint32 count = 6;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.FightPvpRewardResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  bool iswin_;
  ::google::protobuf::int32 prestige_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightBaseModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightBaseModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightBaseModule_2eproto();
  friend void protobuf_ShutdownFile_FightBaseModule_2eproto();

  void InitAsDefaultInstance();
  static FightPvpRewardResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// FightMatrixRequest

// -------------------------------------------------------------------

// FightMatrixResponse

// repeated .main.FightSpirit spiritsYou = 1;
inline int FightMatrixResponse::spiritsyou_size() const {
  return spiritsyou_.size();
}
inline void FightMatrixResponse::clear_spiritsyou() {
  spiritsyou_.Clear();
}
inline const ::main::FightSpirit& FightMatrixResponse::spiritsyou(int index) const {
  // @@protoc_insertion_point(field_get:main.FightMatrixResponse.spiritsYou)
  return spiritsyou_.Get(index);
}
inline ::main::FightSpirit* FightMatrixResponse::mutable_spiritsyou(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightMatrixResponse.spiritsYou)
  return spiritsyou_.Mutable(index);
}
inline ::main::FightSpirit* FightMatrixResponse::add_spiritsyou() {
  // @@protoc_insertion_point(field_add:main.FightMatrixResponse.spiritsYou)
  return spiritsyou_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FightMatrixResponse::spiritsyou() const {
  // @@protoc_insertion_point(field_list:main.FightMatrixResponse.spiritsYou)
  return spiritsyou_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FightMatrixResponse::mutable_spiritsyou() {
  // @@protoc_insertion_point(field_mutable_list:main.FightMatrixResponse.spiritsYou)
  return &spiritsyou_;
}

// repeated .main.FightSpirit spiritsHim = 2;
inline int FightMatrixResponse::spiritshim_size() const {
  return spiritshim_.size();
}
inline void FightMatrixResponse::clear_spiritshim() {
  spiritshim_.Clear();
}
inline const ::main::FightSpirit& FightMatrixResponse::spiritshim(int index) const {
  // @@protoc_insertion_point(field_get:main.FightMatrixResponse.spiritsHim)
  return spiritshim_.Get(index);
}
inline ::main::FightSpirit* FightMatrixResponse::mutable_spiritshim(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightMatrixResponse.spiritsHim)
  return spiritshim_.Mutable(index);
}
inline ::main::FightSpirit* FightMatrixResponse::add_spiritshim() {
  // @@protoc_insertion_point(field_add:main.FightMatrixResponse.spiritsHim)
  return spiritshim_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FightMatrixResponse::spiritshim() const {
  // @@protoc_insertion_point(field_list:main.FightMatrixResponse.spiritsHim)
  return spiritshim_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FightMatrixResponse::mutable_spiritshim() {
  // @@protoc_insertion_point(field_mutable_list:main.FightMatrixResponse.spiritsHim)
  return &spiritshim_;
}

// -------------------------------------------------------------------

// StartStatePVPResponse

// optional int32 state = 1;
inline bool StartStatePVPResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartStatePVPResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartStatePVPResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartStatePVPResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 StartStatePVPResponse::state() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.state)
  return state_;
}
inline void StartStatePVPResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.state)
}

// optional string failMsg = 2;
inline bool StartStatePVPResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartStatePVPResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartStatePVPResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartStatePVPResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& StartStatePVPResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.failMsg)
  return *failmsg_;
}
inline void StartStatePVPResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.failMsg)
}
inline void StartStatePVPResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVPResponse.failMsg)
}
inline void StartStatePVPResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVPResponse.failMsg)
}
inline ::std::string* StartStatePVPResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVPResponse.failMsg)
  return failmsg_;
}
inline ::std::string* StartStatePVPResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVPResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVPResponse.failMsg)
}

// optional string name = 3;
inline bool StartStatePVPResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartStatePVPResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartStatePVPResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartStatePVPResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StartStatePVPResponse::name() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.name)
  return *name_;
}
inline void StartStatePVPResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.name)
}
inline void StartStatePVPResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVPResponse.name)
}
inline void StartStatePVPResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVPResponse.name)
}
inline ::std::string* StartStatePVPResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVPResponse.name)
  return name_;
}
inline ::std::string* StartStatePVPResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVPResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVPResponse.name)
}

// optional string tname = 4;
inline bool StartStatePVPResponse::has_tname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartStatePVPResponse::set_has_tname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartStatePVPResponse::clear_has_tname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartStatePVPResponse::clear_tname() {
  if (tname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_->clear();
  }
  clear_has_tname();
}
inline const ::std::string& StartStatePVPResponse::tname() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.tname)
  return *tname_;
}
inline void StartStatePVPResponse::set_tname(const ::std::string& value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.tname)
}
inline void StartStatePVPResponse::set_tname(const char* value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVPResponse.tname)
}
inline void StartStatePVPResponse::set_tname(const char* value, size_t size) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVPResponse.tname)
}
inline ::std::string* StartStatePVPResponse::mutable_tname() {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVPResponse.tname)
  return tname_;
}
inline ::std::string* StartStatePVPResponse::release_tname() {
  clear_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tname_;
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVPResponse::set_allocated_tname(::std::string* tname) {
  if (tname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tname_;
  }
  if (tname) {
    set_has_tname();
    tname_ = tname;
  } else {
    clear_has_tname();
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVPResponse.tname)
}

// optional int32 image = 5;
inline bool StartStatePVPResponse::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartStatePVPResponse::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartStatePVPResponse::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartStatePVPResponse::clear_image() {
  image_ = 0;
  clear_has_image();
}
inline ::google::protobuf::int32 StartStatePVPResponse::image() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.image)
  return image_;
}
inline void StartStatePVPResponse::set_image(::google::protobuf::int32 value) {
  set_has_image();
  image_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.image)
}

// optional int32 tImage = 6;
inline bool StartStatePVPResponse::has_timage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartStatePVPResponse::set_has_timage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartStatePVPResponse::clear_has_timage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartStatePVPResponse::clear_timage() {
  timage_ = 0;
  clear_has_timage();
}
inline ::google::protobuf::int32 StartStatePVPResponse::timage() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.tImage)
  return timage_;
}
inline void StartStatePVPResponse::set_timage(::google::protobuf::int32 value) {
  set_has_timage();
  timage_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.tImage)
}

// optional int32 majorPosition = 7;
inline bool StartStatePVPResponse::has_majorposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartStatePVPResponse::set_has_majorposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartStatePVPResponse::clear_has_majorposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartStatePVPResponse::clear_majorposition() {
  majorposition_ = 0;
  clear_has_majorposition();
}
inline ::google::protobuf::int32 StartStatePVPResponse::majorposition() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.majorPosition)
  return majorposition_;
}
inline void StartStatePVPResponse::set_majorposition(::google::protobuf::int32 value) {
  set_has_majorposition();
  majorposition_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.majorPosition)
}

// optional int32 tmajorPosition = 8;
inline bool StartStatePVPResponse::has_tmajorposition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StartStatePVPResponse::set_has_tmajorposition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StartStatePVPResponse::clear_has_tmajorposition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StartStatePVPResponse::clear_tmajorposition() {
  tmajorposition_ = 0;
  clear_has_tmajorposition();
}
inline ::google::protobuf::int32 StartStatePVPResponse::tmajorposition() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.tmajorPosition)
  return tmajorposition_;
}
inline void StartStatePVPResponse::set_tmajorposition(::google::protobuf::int32 value) {
  set_has_tmajorposition();
  tmajorposition_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.tmajorPosition)
}

// repeated .main.StartStateItemModel itemId = 9;
inline int StartStatePVPResponse::itemid_size() const {
  return itemid_.size();
}
inline void StartStatePVPResponse::clear_itemid() {
  itemid_.Clear();
}
inline const ::main::StartStateItemModel& StartStatePVPResponse::itemid(int index) const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.itemId)
  return itemid_.Get(index);
}
inline ::main::StartStateItemModel* StartStatePVPResponse::mutable_itemid(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartStatePVPResponse.itemId)
  return itemid_.Mutable(index);
}
inline ::main::StartStateItemModel* StartStatePVPResponse::add_itemid() {
  // @@protoc_insertion_point(field_add:main.StartStatePVPResponse.itemId)
  return itemid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
StartStatePVPResponse::itemid() const {
  // @@protoc_insertion_point(field_list:main.StartStatePVPResponse.itemId)
  return itemid_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
StartStatePVPResponse::mutable_itemid() {
  // @@protoc_insertion_point(field_mutable_list:main.StartStatePVPResponse.itemId)
  return &itemid_;
}

// repeated .main.StartStateItemModel tItemId = 10;
inline int StartStatePVPResponse::titemid_size() const {
  return titemid_.size();
}
inline void StartStatePVPResponse::clear_titemid() {
  titemid_.Clear();
}
inline const ::main::StartStateItemModel& StartStatePVPResponse::titemid(int index) const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.tItemId)
  return titemid_.Get(index);
}
inline ::main::StartStateItemModel* StartStatePVPResponse::mutable_titemid(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartStatePVPResponse.tItemId)
  return titemid_.Mutable(index);
}
inline ::main::StartStateItemModel* StartStatePVPResponse::add_titemid() {
  // @@protoc_insertion_point(field_add:main.StartStatePVPResponse.tItemId)
  return titemid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
StartStatePVPResponse::titemid() const {
  // @@protoc_insertion_point(field_list:main.StartStatePVPResponse.tItemId)
  return titemid_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
StartStatePVPResponse::mutable_titemid() {
  // @@protoc_insertion_point(field_mutable_list:main.StartStatePVPResponse.tItemId)
  return &titemid_;
}

// optional int32 nation = 11;
inline bool StartStatePVPResponse::has_nation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StartStatePVPResponse::set_has_nation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StartStatePVPResponse::clear_has_nation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StartStatePVPResponse::clear_nation() {
  nation_ = 0;
  clear_has_nation();
}
inline ::google::protobuf::int32 StartStatePVPResponse::nation() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.nation)
  return nation_;
}
inline void StartStatePVPResponse::set_nation(::google::protobuf::int32 value) {
  set_has_nation();
  nation_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.nation)
}

// optional int32 tNation = 12;
inline bool StartStatePVPResponse::has_tnation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StartStatePVPResponse::set_has_tnation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StartStatePVPResponse::clear_has_tnation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StartStatePVPResponse::clear_tnation() {
  tnation_ = 0;
  clear_has_tnation();
}
inline ::google::protobuf::int32 StartStatePVPResponse::tnation() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.tNation)
  return tnation_;
}
inline void StartStatePVPResponse::set_tnation(::google::protobuf::int32 value) {
  set_has_tnation();
  tnation_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.tNation)
}

// optional int32 isAI = 13;
inline bool StartStatePVPResponse::has_isai() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StartStatePVPResponse::set_has_isai() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StartStatePVPResponse::clear_has_isai() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StartStatePVPResponse::clear_isai() {
  isai_ = 0;
  clear_has_isai();
}
inline ::google::protobuf::int32 StartStatePVPResponse::isai() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.isAI)
  return isai_;
}
inline void StartStatePVPResponse::set_isai(::google::protobuf::int32 value) {
  set_has_isai();
  isai_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.isAI)
}

// optional int32 branchType = 14 [default = 201];
inline bool StartStatePVPResponse::has_branchtype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StartStatePVPResponse::set_has_branchtype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StartStatePVPResponse::clear_has_branchtype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StartStatePVPResponse::clear_branchtype() {
  branchtype_ = 201;
  clear_has_branchtype();
}
inline ::google::protobuf::int32 StartStatePVPResponse::branchtype() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVPResponse.branchType)
  return branchtype_;
}
inline void StartStatePVPResponse::set_branchtype(::google::protobuf::int32 value) {
  set_has_branchtype();
  branchtype_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVPResponse.branchType)
}

// -------------------------------------------------------------------

// StartStatePVERequest

// optional int32 storyId = 1;
inline bool StartStatePVERequest::has_storyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartStatePVERequest::set_has_storyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartStatePVERequest::clear_has_storyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartStatePVERequest::clear_storyid() {
  storyid_ = 0;
  clear_has_storyid();
}
inline ::google::protobuf::int32 StartStatePVERequest::storyid() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVERequest.storyId)
  return storyid_;
}
inline void StartStatePVERequest::set_storyid(::google::protobuf::int32 value) {
  set_has_storyid();
  storyid_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVERequest.storyId)
}

// optional int32 plotId = 2;
inline bool StartStatePVERequest::has_plotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartStatePVERequest::set_has_plotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartStatePVERequest::clear_has_plotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartStatePVERequest::clear_plotid() {
  plotid_ = 0;
  clear_has_plotid();
}
inline ::google::protobuf::int32 StartStatePVERequest::plotid() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVERequest.plotId)
  return plotid_;
}
inline void StartStatePVERequest::set_plotid(::google::protobuf::int32 value) {
  set_has_plotid();
  plotid_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVERequest.plotId)
}

// optional int32 cooId = 3;
inline bool StartStatePVERequest::has_cooid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartStatePVERequest::set_has_cooid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartStatePVERequest::clear_has_cooid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartStatePVERequest::clear_cooid() {
  cooid_ = 0;
  clear_has_cooid();
}
inline ::google::protobuf::int32 StartStatePVERequest::cooid() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVERequest.cooId)
  return cooid_;
}
inline void StartStatePVERequest::set_cooid(::google::protobuf::int32 value) {
  set_has_cooid();
  cooid_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVERequest.cooId)
}

// -------------------------------------------------------------------

// StartStatePVEResponse

// optional int32 state = 1;
inline bool StartStatePVEResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartStatePVEResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartStatePVEResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartStatePVEResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 StartStatePVEResponse::state() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.state)
  return state_;
}
inline void StartStatePVEResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.state)
}

// optional string fightId = 2;
inline bool StartStatePVEResponse::has_fightid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartStatePVEResponse::set_has_fightid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartStatePVEResponse::clear_has_fightid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartStatePVEResponse::clear_fightid() {
  if (fightid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_->clear();
  }
  clear_has_fightid();
}
inline const ::std::string& StartStatePVEResponse::fightid() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.fightId)
  return *fightid_;
}
inline void StartStatePVEResponse::set_fightid(const ::std::string& value) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.fightId)
}
inline void StartStatePVEResponse::set_fightid(const char* value) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVEResponse.fightId)
}
inline void StartStatePVEResponse::set_fightid(const char* value, size_t size) {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  fightid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVEResponse.fightId)
}
inline ::std::string* StartStatePVEResponse::mutable_fightid() {
  set_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fightid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVEResponse.fightId)
  return fightid_;
}
inline ::std::string* StartStatePVEResponse::release_fightid() {
  clear_has_fightid();
  if (fightid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fightid_;
    fightid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVEResponse::set_allocated_fightid(::std::string* fightid) {
  if (fightid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fightid_;
  }
  if (fightid) {
    set_has_fightid();
    fightid_ = fightid;
  } else {
    clear_has_fightid();
    fightid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVEResponse.fightId)
}

// optional string name = 3;
inline bool StartStatePVEResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartStatePVEResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartStatePVEResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartStatePVEResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StartStatePVEResponse::name() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.name)
  return *name_;
}
inline void StartStatePVEResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.name)
}
inline void StartStatePVEResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVEResponse.name)
}
inline void StartStatePVEResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVEResponse.name)
}
inline ::std::string* StartStatePVEResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVEResponse.name)
  return name_;
}
inline ::std::string* StartStatePVEResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVEResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVEResponse.name)
}

// optional string tname = 4;
inline bool StartStatePVEResponse::has_tname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartStatePVEResponse::set_has_tname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartStatePVEResponse::clear_has_tname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartStatePVEResponse::clear_tname() {
  if (tname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_->clear();
  }
  clear_has_tname();
}
inline const ::std::string& StartStatePVEResponse::tname() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.tname)
  return *tname_;
}
inline void StartStatePVEResponse::set_tname(const ::std::string& value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.tname)
}
inline void StartStatePVEResponse::set_tname(const char* value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartStatePVEResponse.tname)
}
inline void StartStatePVEResponse::set_tname(const char* value, size_t size) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  tname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartStatePVEResponse.tname)
}
inline ::std::string* StartStatePVEResponse::mutable_tname() {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartStatePVEResponse.tname)
  return tname_;
}
inline ::std::string* StartStatePVEResponse::release_tname() {
  clear_has_tname();
  if (tname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tname_;
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartStatePVEResponse::set_allocated_tname(::std::string* tname) {
  if (tname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tname_;
  }
  if (tname) {
    set_has_tname();
    tname_ = tname;
  } else {
    clear_has_tname();
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartStatePVEResponse.tname)
}

// optional int32 image = 5;
inline bool StartStatePVEResponse::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartStatePVEResponse::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartStatePVEResponse::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartStatePVEResponse::clear_image() {
  image_ = 0;
  clear_has_image();
}
inline ::google::protobuf::int32 StartStatePVEResponse::image() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.image)
  return image_;
}
inline void StartStatePVEResponse::set_image(::google::protobuf::int32 value) {
  set_has_image();
  image_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.image)
}

// optional int32 tImage = 6;
inline bool StartStatePVEResponse::has_timage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartStatePVEResponse::set_has_timage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartStatePVEResponse::clear_has_timage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartStatePVEResponse::clear_timage() {
  timage_ = 0;
  clear_has_timage();
}
inline ::google::protobuf::int32 StartStatePVEResponse::timage() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.tImage)
  return timage_;
}
inline void StartStatePVEResponse::set_timage(::google::protobuf::int32 value) {
  set_has_timage();
  timage_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.tImage)
}

// optional int32 majorPosition = 7;
inline bool StartStatePVEResponse::has_majorposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartStatePVEResponse::set_has_majorposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartStatePVEResponse::clear_has_majorposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartStatePVEResponse::clear_majorposition() {
  majorposition_ = 0;
  clear_has_majorposition();
}
inline ::google::protobuf::int32 StartStatePVEResponse::majorposition() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.majorPosition)
  return majorposition_;
}
inline void StartStatePVEResponse::set_majorposition(::google::protobuf::int32 value) {
  set_has_majorposition();
  majorposition_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.majorPosition)
}

// optional int32 tmajorPosition = 8;
inline bool StartStatePVEResponse::has_tmajorposition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StartStatePVEResponse::set_has_tmajorposition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StartStatePVEResponse::clear_has_tmajorposition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StartStatePVEResponse::clear_tmajorposition() {
  tmajorposition_ = 0;
  clear_has_tmajorposition();
}
inline ::google::protobuf::int32 StartStatePVEResponse::tmajorposition() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.tmajorPosition)
  return tmajorposition_;
}
inline void StartStatePVEResponse::set_tmajorposition(::google::protobuf::int32 value) {
  set_has_tmajorposition();
  tmajorposition_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.tmajorPosition)
}

// repeated .main.StartStateItemModel item = 9;
inline int StartStatePVEResponse::item_size() const {
  return item_.size();
}
inline void StartStatePVEResponse::clear_item() {
  item_.Clear();
}
inline const ::main::StartStateItemModel& StartStatePVEResponse::item(int index) const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.item)
  return item_.Get(index);
}
inline ::main::StartStateItemModel* StartStatePVEResponse::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartStatePVEResponse.item)
  return item_.Mutable(index);
}
inline ::main::StartStateItemModel* StartStatePVEResponse::add_item() {
  // @@protoc_insertion_point(field_add:main.StartStatePVEResponse.item)
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
StartStatePVEResponse::item() const {
  // @@protoc_insertion_point(field_list:main.StartStatePVEResponse.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
StartStatePVEResponse::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:main.StartStatePVEResponse.item)
  return &item_;
}

// repeated .main.StartStateItemModel tItem = 10;
inline int StartStatePVEResponse::titem_size() const {
  return titem_.size();
}
inline void StartStatePVEResponse::clear_titem() {
  titem_.Clear();
}
inline const ::main::StartStateItemModel& StartStatePVEResponse::titem(int index) const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.tItem)
  return titem_.Get(index);
}
inline ::main::StartStateItemModel* StartStatePVEResponse::mutable_titem(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartStatePVEResponse.tItem)
  return titem_.Mutable(index);
}
inline ::main::StartStateItemModel* StartStatePVEResponse::add_titem() {
  // @@protoc_insertion_point(field_add:main.StartStatePVEResponse.tItem)
  return titem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >&
StartStatePVEResponse::titem() const {
  // @@protoc_insertion_point(field_list:main.StartStatePVEResponse.tItem)
  return titem_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::StartStateItemModel >*
StartStatePVEResponse::mutable_titem() {
  // @@protoc_insertion_point(field_mutable_list:main.StartStatePVEResponse.tItem)
  return &titem_;
}

// optional int32 nation = 11;
inline bool StartStatePVEResponse::has_nation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StartStatePVEResponse::set_has_nation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StartStatePVEResponse::clear_has_nation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StartStatePVEResponse::clear_nation() {
  nation_ = 0;
  clear_has_nation();
}
inline ::google::protobuf::int32 StartStatePVEResponse::nation() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.nation)
  return nation_;
}
inline void StartStatePVEResponse::set_nation(::google::protobuf::int32 value) {
  set_has_nation();
  nation_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.nation)
}

// optional int32 tNation = 12;
inline bool StartStatePVEResponse::has_tnation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StartStatePVEResponse::set_has_tnation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StartStatePVEResponse::clear_has_tnation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StartStatePVEResponse::clear_tnation() {
  tnation_ = 0;
  clear_has_tnation();
}
inline ::google::protobuf::int32 StartStatePVEResponse::tnation() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.tNation)
  return tnation_;
}
inline void StartStatePVEResponse::set_tnation(::google::protobuf::int32 value) {
  set_has_tnation();
  tnation_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.tNation)
}

// optional int32 branchType = 13 [default = 101];
inline bool StartStatePVEResponse::has_branchtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StartStatePVEResponse::set_has_branchtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StartStatePVEResponse::clear_has_branchtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StartStatePVEResponse::clear_branchtype() {
  branchtype_ = 101;
  clear_has_branchtype();
}
inline ::google::protobuf::int32 StartStatePVEResponse::branchtype() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.branchType)
  return branchtype_;
}
inline void StartStatePVEResponse::set_branchtype(::google::protobuf::int32 value) {
  set_has_branchtype();
  branchtype_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.branchType)
}

// optional int32 survivalLevel = 14 [default = -1];
inline bool StartStatePVEResponse::has_survivallevel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StartStatePVEResponse::set_has_survivallevel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StartStatePVEResponse::clear_has_survivallevel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StartStatePVEResponse::clear_survivallevel() {
  survivallevel_ = -1;
  clear_has_survivallevel();
}
inline ::google::protobuf::int32 StartStatePVEResponse::survivallevel() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.survivalLevel)
  return survivallevel_;
}
inline void StartStatePVEResponse::set_survivallevel(::google::protobuf::int32 value) {
  set_has_survivallevel();
  survivallevel_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.survivalLevel)
}

// optional bool needVerify = 15 [default = true];
inline bool StartStatePVEResponse::has_needverify() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StartStatePVEResponse::set_has_needverify() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StartStatePVEResponse::clear_has_needverify() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StartStatePVEResponse::clear_needverify() {
  needverify_ = true;
  clear_has_needverify();
}
inline bool StartStatePVEResponse::needverify() const {
  // @@protoc_insertion_point(field_get:main.StartStatePVEResponse.needVerify)
  return needverify_;
}
inline void StartStatePVEResponse::set_needverify(bool value) {
  set_has_needverify();
  needverify_ = value;
  // @@protoc_insertion_point(field_set:main.StartStatePVEResponse.needVerify)
}

// -------------------------------------------------------------------

// StartStateItemModel

// optional int32 itemId = 1;
inline bool StartStateItemModel::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartStateItemModel::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartStateItemModel::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartStateItemModel::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 StartStateItemModel::itemid() const {
  // @@protoc_insertion_point(field_get:main.StartStateItemModel.itemId)
  return itemid_;
}
inline void StartStateItemModel::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:main.StartStateItemModel.itemId)
}

// optional int32 itemLevel = 2;
inline bool StartStateItemModel::has_itemlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartStateItemModel::set_has_itemlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartStateItemModel::clear_has_itemlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartStateItemModel::clear_itemlevel() {
  itemlevel_ = 0;
  clear_has_itemlevel();
}
inline ::google::protobuf::int32 StartStateItemModel::itemlevel() const {
  // @@protoc_insertion_point(field_get:main.StartStateItemModel.itemLevel)
  return itemlevel_;
}
inline void StartStateItemModel::set_itemlevel(::google::protobuf::int32 value) {
  set_has_itemlevel();
  itemlevel_ = value;
  // @@protoc_insertion_point(field_set:main.StartStateItemModel.itemLevel)
}

// -------------------------------------------------------------------

// StartRequest

// optional int32 enemyRoleId = 1;
inline bool StartRequest::has_enemyroleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRequest::set_has_enemyroleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRequest::clear_has_enemyroleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartRequest::clear_enemyroleid() {
  enemyroleid_ = 0;
  clear_has_enemyroleid();
}
inline ::google::protobuf::int32 StartRequest::enemyroleid() const {
  // @@protoc_insertion_point(field_get:main.StartRequest.enemyRoleId)
  return enemyroleid_;
}
inline void StartRequest::set_enemyroleid(::google::protobuf::int32 value) {
  set_has_enemyroleid();
  enemyroleid_ = value;
  // @@protoc_insertion_point(field_set:main.StartRequest.enemyRoleId)
}

// -------------------------------------------------------------------

// StartResponse

// optional int32 state = 1;
inline bool StartResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 StartResponse::state() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.state)
  return state_;
}
inline void StartResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.state)
}

// optional string failMsg = 2;
inline bool StartResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& StartResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.failMsg)
  return *failmsg_;
}
inline void StartResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartResponse.failMsg)
}
inline void StartResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartResponse.failMsg)
}
inline void StartResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartResponse.failMsg)
}
inline ::std::string* StartResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartResponse.failMsg)
  return failmsg_;
}
inline ::std::string* StartResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartResponse.failMsg)
}

// repeated .main.FightSpirit spiritsYou = 3;
inline int StartResponse::spiritsyou_size() const {
  return spiritsyou_.size();
}
inline void StartResponse::clear_spiritsyou() {
  spiritsyou_.Clear();
}
inline const ::main::FightSpirit& StartResponse::spiritsyou(int index) const {
  // @@protoc_insertion_point(field_get:main.StartResponse.spiritsYou)
  return spiritsyou_.Get(index);
}
inline ::main::FightSpirit* StartResponse::mutable_spiritsyou(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartResponse.spiritsYou)
  return spiritsyou_.Mutable(index);
}
inline ::main::FightSpirit* StartResponse::add_spiritsyou() {
  // @@protoc_insertion_point(field_add:main.StartResponse.spiritsYou)
  return spiritsyou_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
StartResponse::spiritsyou() const {
  // @@protoc_insertion_point(field_list:main.StartResponse.spiritsYou)
  return spiritsyou_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
StartResponse::mutable_spiritsyou() {
  // @@protoc_insertion_point(field_mutable_list:main.StartResponse.spiritsYou)
  return &spiritsyou_;
}

// repeated .main.FightSpirit spiritsHim = 4;
inline int StartResponse::spiritshim_size() const {
  return spiritshim_.size();
}
inline void StartResponse::clear_spiritshim() {
  spiritshim_.Clear();
}
inline const ::main::FightSpirit& StartResponse::spiritshim(int index) const {
  // @@protoc_insertion_point(field_get:main.StartResponse.spiritsHim)
  return spiritshim_.Get(index);
}
inline ::main::FightSpirit* StartResponse::mutable_spiritshim(int index) {
  // @@protoc_insertion_point(field_mutable:main.StartResponse.spiritsHim)
  return spiritshim_.Mutable(index);
}
inline ::main::FightSpirit* StartResponse::add_spiritshim() {
  // @@protoc_insertion_point(field_add:main.StartResponse.spiritsHim)
  return spiritshim_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
StartResponse::spiritshim() const {
  // @@protoc_insertion_point(field_list:main.StartResponse.spiritsHim)
  return spiritshim_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
StartResponse::mutable_spiritshim() {
  // @@protoc_insertion_point(field_mutable_list:main.StartResponse.spiritsHim)
  return &spiritshim_;
}

// optional bool isFirstAttack = 5;
inline bool StartResponse::has_isfirstattack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartResponse::set_has_isfirstattack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartResponse::clear_has_isfirstattack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartResponse::clear_isfirstattack() {
  isfirstattack_ = false;
  clear_has_isfirstattack();
}
inline bool StartResponse::isfirstattack() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.isFirstAttack)
  return isfirstattack_;
}
inline void StartResponse::set_isfirstattack(bool value) {
  set_has_isfirstattack();
  isfirstattack_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.isFirstAttack)
}

// optional int32 youHp = 6;
inline bool StartResponse::has_youhp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartResponse::set_has_youhp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartResponse::clear_has_youhp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartResponse::clear_youhp() {
  youhp_ = 0;
  clear_has_youhp();
}
inline ::google::protobuf::int32 StartResponse::youhp() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.youHp)
  return youhp_;
}
inline void StartResponse::set_youhp(::google::protobuf::int32 value) {
  set_has_youhp();
  youhp_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.youHp)
}

// optional int32 himHp = 7;
inline bool StartResponse::has_himhp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartResponse::set_has_himhp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartResponse::clear_has_himhp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartResponse::clear_himhp() {
  himhp_ = 0;
  clear_has_himhp();
}
inline ::google::protobuf::int32 StartResponse::himhp() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.himHp)
  return himhp_;
}
inline void StartResponse::set_himhp(::google::protobuf::int32 value) {
  set_has_himhp();
  himhp_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.himHp)
}

// optional int32 youActionCount = 8;
inline bool StartResponse::has_youactioncount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StartResponse::set_has_youactioncount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StartResponse::clear_has_youactioncount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StartResponse::clear_youactioncount() {
  youactioncount_ = 0;
  clear_has_youactioncount();
}
inline ::google::protobuf::int32 StartResponse::youactioncount() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.youActionCount)
  return youactioncount_;
}
inline void StartResponse::set_youactioncount(::google::protobuf::int32 value) {
  set_has_youactioncount();
  youactioncount_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.youActionCount)
}

// optional int32 himActionCount = 9;
inline bool StartResponse::has_himactioncount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StartResponse::set_has_himactioncount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StartResponse::clear_has_himactioncount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StartResponse::clear_himactioncount() {
  himactioncount_ = 0;
  clear_has_himactioncount();
}
inline ::google::protobuf::int32 StartResponse::himactioncount() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.himActionCount)
  return himactioncount_;
}
inline void StartResponse::set_himactioncount(::google::protobuf::int32 value) {
  set_has_himactioncount();
  himactioncount_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.himActionCount)
}

// optional string fid = 10;
inline bool StartResponse::has_fid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StartResponse::set_has_fid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StartResponse::clear_has_fid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StartResponse::clear_fid() {
  if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_->clear();
  }
  clear_has_fid();
}
inline const ::std::string& StartResponse::fid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.fid)
  return *fid_;
}
inline void StartResponse::set_fid(const ::std::string& value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartResponse.fid)
}
inline void StartResponse::set_fid(const char* value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartResponse.fid)
}
inline void StartResponse::set_fid(const char* value, size_t size) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartResponse.fid)
}
inline ::std::string* StartResponse::mutable_fid() {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartResponse.fid)
  return fid_;
}
inline ::std::string* StartResponse::release_fid() {
  clear_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fid_;
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartResponse::set_allocated_fid(::std::string* fid) {
  if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fid_;
  }
  if (fid) {
    set_has_fid();
    fid_ = fid;
  } else {
    clear_has_fid();
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartResponse.fid)
}

// optional int32 lordId = 11;
inline bool StartResponse::has_lordid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StartResponse::set_has_lordid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StartResponse::clear_has_lordid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StartResponse::clear_lordid() {
  lordid_ = 0;
  clear_has_lordid();
}
inline ::google::protobuf::int32 StartResponse::lordid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordId)
  return lordid_;
}
inline void StartResponse::set_lordid(::google::protobuf::int32 value) {
  set_has_lordid();
  lordid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.lordId)
}

// optional string lordName = 12;
inline bool StartResponse::has_lordname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StartResponse::set_has_lordname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StartResponse::clear_has_lordname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StartResponse::clear_lordname() {
  if (lordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_->clear();
  }
  clear_has_lordname();
}
inline const ::std::string& StartResponse::lordname() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordName)
  return *lordname_;
}
inline void StartResponse::set_lordname(const ::std::string& value) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartResponse.lordName)
}
inline void StartResponse::set_lordname(const char* value) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartResponse.lordName)
}
inline void StartResponse::set_lordname(const char* value, size_t size) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartResponse.lordName)
}
inline ::std::string* StartResponse::mutable_lordname() {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartResponse.lordName)
  return lordname_;
}
inline ::std::string* StartResponse::release_lordname() {
  clear_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lordname_;
    lordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartResponse::set_allocated_lordname(::std::string* lordname) {
  if (lordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lordname_;
  }
  if (lordname) {
    set_has_lordname();
    lordname_ = lordname;
  } else {
    clear_has_lordname();
    lordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartResponse.lordName)
}

// optional int32 lordSkillBelongId = 13;
inline bool StartResponse::has_lordskillbelongid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StartResponse::set_has_lordskillbelongid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StartResponse::clear_has_lordskillbelongid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StartResponse::clear_lordskillbelongid() {
  lordskillbelongid_ = 0;
  clear_has_lordskillbelongid();
}
inline ::google::protobuf::int32 StartResponse::lordskillbelongid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordSkillBelongId)
  return lordskillbelongid_;
}
inline void StartResponse::set_lordskillbelongid(::google::protobuf::int32 value) {
  set_has_lordskillbelongid();
  lordskillbelongid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.lordSkillBelongId)
}

// optional int32 lordSkillId = 14;
inline bool StartResponse::has_lordskillid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StartResponse::set_has_lordskillid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StartResponse::clear_has_lordskillid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StartResponse::clear_lordskillid() {
  lordskillid_ = 0;
  clear_has_lordskillid();
}
inline ::google::protobuf::int32 StartResponse::lordskillid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordSkillId)
  return lordskillid_;
}
inline void StartResponse::set_lordskillid(::google::protobuf::int32 value) {
  set_has_lordskillid();
  lordskillid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.lordSkillId)
}

// optional int32 tlordId = 15;
inline bool StartResponse::has_tlordid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StartResponse::set_has_tlordid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StartResponse::clear_has_tlordid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StartResponse::clear_tlordid() {
  tlordid_ = 0;
  clear_has_tlordid();
}
inline ::google::protobuf::int32 StartResponse::tlordid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordId)
  return tlordid_;
}
inline void StartResponse::set_tlordid(::google::protobuf::int32 value) {
  set_has_tlordid();
  tlordid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordId)
}

// optional string tlordName = 16;
inline bool StartResponse::has_tlordname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StartResponse::set_has_tlordname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StartResponse::clear_has_tlordname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StartResponse::clear_tlordname() {
  if (tlordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_->clear();
  }
  clear_has_tlordname();
}
inline const ::std::string& StartResponse::tlordname() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordName)
  return *tlordname_;
}
inline void StartResponse::set_tlordname(const ::std::string& value) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(value);
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordName)
}
inline void StartResponse::set_tlordname(const char* value) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.StartResponse.tlordName)
}
inline void StartResponse::set_tlordname(const char* value, size_t size) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.StartResponse.tlordName)
}
inline ::std::string* StartResponse::mutable_tlordname() {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.StartResponse.tlordName)
  return tlordname_;
}
inline ::std::string* StartResponse::release_tlordname() {
  clear_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tlordname_;
    tlordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartResponse::set_allocated_tlordname(::std::string* tlordname) {
  if (tlordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tlordname_;
  }
  if (tlordname) {
    set_has_tlordname();
    tlordname_ = tlordname;
  } else {
    clear_has_tlordname();
    tlordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.StartResponse.tlordName)
}

// optional int32 tlordSkillBelongId = 17;
inline bool StartResponse::has_tlordskillbelongid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StartResponse::set_has_tlordskillbelongid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StartResponse::clear_has_tlordskillbelongid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StartResponse::clear_tlordskillbelongid() {
  tlordskillbelongid_ = 0;
  clear_has_tlordskillbelongid();
}
inline ::google::protobuf::int32 StartResponse::tlordskillbelongid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordSkillBelongId)
  return tlordskillbelongid_;
}
inline void StartResponse::set_tlordskillbelongid(::google::protobuf::int32 value) {
  set_has_tlordskillbelongid();
  tlordskillbelongid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordSkillBelongId)
}

// optional int32 tlordSkillId = 18;
inline bool StartResponse::has_tlordskillid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StartResponse::set_has_tlordskillid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StartResponse::clear_has_tlordskillid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StartResponse::clear_tlordskillid() {
  tlordskillid_ = 0;
  clear_has_tlordskillid();
}
inline ::google::protobuf::int32 StartResponse::tlordskillid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordSkillId)
  return tlordskillid_;
}
inline void StartResponse::set_tlordskillid(::google::protobuf::int32 value) {
  set_has_tlordskillid();
  tlordskillid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordSkillId)
}

// optional int32 tlordSkillLevel = 19;
inline bool StartResponse::has_tlordskilllevel() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StartResponse::set_has_tlordskilllevel() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StartResponse::clear_has_tlordskilllevel() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StartResponse::clear_tlordskilllevel() {
  tlordskilllevel_ = 0;
  clear_has_tlordskilllevel();
}
inline ::google::protobuf::int32 StartResponse::tlordskilllevel() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordSkillLevel)
  return tlordskilllevel_;
}
inline void StartResponse::set_tlordskilllevel(::google::protobuf::int32 value) {
  set_has_tlordskilllevel();
  tlordskilllevel_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordSkillLevel)
}

// optional int32 lordCdRound = 20;
inline bool StartResponse::has_lordcdround() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StartResponse::set_has_lordcdround() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StartResponse::clear_has_lordcdround() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StartResponse::clear_lordcdround() {
  lordcdround_ = 0;
  clear_has_lordcdround();
}
inline ::google::protobuf::int32 StartResponse::lordcdround() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordCdRound)
  return lordcdround_;
}
inline void StartResponse::set_lordcdround(::google::protobuf::int32 value) {
  set_has_lordcdround();
  lordcdround_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.lordCdRound)
}

// optional int32 tlordCdRound = 21;
inline bool StartResponse::has_tlordcdround() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void StartResponse::set_has_tlordcdround() {
  _has_bits_[0] |= 0x00100000u;
}
inline void StartResponse::clear_has_tlordcdround() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void StartResponse::clear_tlordcdround() {
  tlordcdround_ = 0;
  clear_has_tlordcdround();
}
inline ::google::protobuf::int32 StartResponse::tlordcdround() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tlordCdRound)
  return tlordcdround_;
}
inline void StartResponse::set_tlordcdround(::google::protobuf::int32 value) {
  set_has_tlordcdround();
  tlordcdround_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tlordCdRound)
}

// optional int32 clientType = 22;
inline bool StartResponse::has_clienttype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void StartResponse::set_has_clienttype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void StartResponse::clear_has_clienttype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void StartResponse::clear_clienttype() {
  clienttype_ = 0;
  clear_has_clienttype();
}
inline ::google::protobuf::int32 StartResponse::clienttype() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.clientType)
  return clienttype_;
}
inline void StartResponse::set_clienttype(::google::protobuf::int32 value) {
  set_has_clienttype();
  clienttype_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.clientType)
}

// optional int32 nation = 23;
inline bool StartResponse::has_nation() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void StartResponse::set_has_nation() {
  _has_bits_[0] |= 0x00400000u;
}
inline void StartResponse::clear_has_nation() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void StartResponse::clear_nation() {
  nation_ = 0;
  clear_has_nation();
}
inline ::google::protobuf::int32 StartResponse::nation() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.nation)
  return nation_;
}
inline void StartResponse::set_nation(::google::protobuf::int32 value) {
  set_has_nation();
  nation_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.nation)
}

// optional int32 tnation = 24;
inline bool StartResponse::has_tnation() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void StartResponse::set_has_tnation() {
  _has_bits_[0] |= 0x00800000u;
}
inline void StartResponse::clear_has_tnation() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void StartResponse::clear_tnation() {
  tnation_ = 0;
  clear_has_tnation();
}
inline ::google::protobuf::int32 StartResponse::tnation() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tnation)
  return tnation_;
}
inline void StartResponse::set_tnation(::google::protobuf::int32 value) {
  set_has_tnation();
  tnation_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tnation)
}

// optional int32 lordAtkMode = 25;
inline bool StartResponse::has_lordatkmode() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void StartResponse::set_has_lordatkmode() {
  _has_bits_[0] |= 0x01000000u;
}
inline void StartResponse::clear_has_lordatkmode() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void StartResponse::clear_lordatkmode() {
  lordatkmode_ = 0;
  clear_has_lordatkmode();
}
inline ::google::protobuf::int32 StartResponse::lordatkmode() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.lordAtkMode)
  return lordatkmode_;
}
inline void StartResponse::set_lordatkmode(::google::protobuf::int32 value) {
  set_has_lordatkmode();
  lordatkmode_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.lordAtkMode)
}

// optional int32 TlordAtkMode = 26;
inline bool StartResponse::has_tlordatkmode() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void StartResponse::set_has_tlordatkmode() {
  _has_bits_[0] |= 0x02000000u;
}
inline void StartResponse::clear_has_tlordatkmode() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void StartResponse::clear_tlordatkmode() {
  tlordatkmode_ = 0;
  clear_has_tlordatkmode();
}
inline ::google::protobuf::int32 StartResponse::tlordatkmode() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.TlordAtkMode)
  return tlordatkmode_;
}
inline void StartResponse::set_tlordatkmode(::google::protobuf::int32 value) {
  set_has_tlordatkmode();
  tlordatkmode_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.TlordAtkMode)
}

// optional int32 speed = 27;
inline bool StartResponse::has_speed() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void StartResponse::set_has_speed() {
  _has_bits_[0] |= 0x04000000u;
}
inline void StartResponse::clear_has_speed() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void StartResponse::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 StartResponse::speed() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.speed)
  return speed_;
}
inline void StartResponse::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.speed)
}

// optional int32 tspeed = 28;
inline bool StartResponse::has_tspeed() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void StartResponse::set_has_tspeed() {
  _has_bits_[0] |= 0x08000000u;
}
inline void StartResponse::clear_has_tspeed() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void StartResponse::clear_tspeed() {
  tspeed_ = 0;
  clear_has_tspeed();
}
inline ::google::protobuf::int32 StartResponse::tspeed() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tspeed)
  return tspeed_;
}
inline void StartResponse::set_tspeed(::google::protobuf::int32 value) {
  set_has_tspeed();
  tspeed_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tspeed)
}

// optional int32 youActionCountByAdd = 29;
inline bool StartResponse::has_youactioncountbyadd() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void StartResponse::set_has_youactioncountbyadd() {
  _has_bits_[0] |= 0x10000000u;
}
inline void StartResponse::clear_has_youactioncountbyadd() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void StartResponse::clear_youactioncountbyadd() {
  youactioncountbyadd_ = 0;
  clear_has_youactioncountbyadd();
}
inline ::google::protobuf::int32 StartResponse::youactioncountbyadd() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.youActionCountByAdd)
  return youactioncountbyadd_;
}
inline void StartResponse::set_youactioncountbyadd(::google::protobuf::int32 value) {
  set_has_youactioncountbyadd();
  youactioncountbyadd_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.youActionCountByAdd)
}

// optional int32 himActionCountByAdd = 30;
inline bool StartResponse::has_himactioncountbyadd() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void StartResponse::set_has_himactioncountbyadd() {
  _has_bits_[0] |= 0x20000000u;
}
inline void StartResponse::clear_has_himactioncountbyadd() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void StartResponse::clear_himactioncountbyadd() {
  himactioncountbyadd_ = 0;
  clear_has_himactioncountbyadd();
}
inline ::google::protobuf::int32 StartResponse::himactioncountbyadd() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.himActionCountByAdd)
  return himactioncountbyadd_;
}
inline void StartResponse::set_himactioncountbyadd(::google::protobuf::int32 value) {
  set_has_himactioncountbyadd();
  himactioncountbyadd_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.himActionCountByAdd)
}

// optional int32 mapId = 31;
inline bool StartResponse::has_mapid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void StartResponse::set_has_mapid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void StartResponse::clear_has_mapid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void StartResponse::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 StartResponse::mapid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.mapId)
  return mapid_;
}
inline void StartResponse::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.mapId)
}

// optional int32 roleId = 32;
inline bool StartResponse::has_roleid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void StartResponse::set_has_roleid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void StartResponse::clear_has_roleid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void StartResponse::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 StartResponse::roleid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.roleId)
  return roleid_;
}
inline void StartResponse::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.roleId)
}

// optional int32 tRoleId = 33;
inline bool StartResponse::has_troleid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void StartResponse::set_has_troleid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void StartResponse::clear_has_troleid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void StartResponse::clear_troleid() {
  troleid_ = 0;
  clear_has_troleid();
}
inline ::google::protobuf::int32 StartResponse::troleid() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tRoleId)
  return troleid_;
}
inline void StartResponse::set_troleid(::google::protobuf::int32 value) {
  set_has_troleid();
  troleid_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tRoleId)
}

// optional int32 maxFillUnit = 34;
inline bool StartResponse::has_maxfillunit() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void StartResponse::set_has_maxfillunit() {
  _has_bits_[1] |= 0x00000002u;
}
inline void StartResponse::clear_has_maxfillunit() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void StartResponse::clear_maxfillunit() {
  maxfillunit_ = 0;
  clear_has_maxfillunit();
}
inline ::google::protobuf::int32 StartResponse::maxfillunit() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.maxFillUnit)
  return maxfillunit_;
}
inline void StartResponse::set_maxfillunit(::google::protobuf::int32 value) {
  set_has_maxfillunit();
  maxfillunit_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.maxFillUnit)
}

// optional int32 tMaxFillUnit = 35;
inline bool StartResponse::has_tmaxfillunit() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void StartResponse::set_has_tmaxfillunit() {
  _has_bits_[1] |= 0x00000004u;
}
inline void StartResponse::clear_has_tmaxfillunit() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void StartResponse::clear_tmaxfillunit() {
  tmaxfillunit_ = 0;
  clear_has_tmaxfillunit();
}
inline ::google::protobuf::int32 StartResponse::tmaxfillunit() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tMaxFillUnit)
  return tmaxfillunit_;
}
inline void StartResponse::set_tmaxfillunit(::google::protobuf::int32 value) {
  set_has_tmaxfillunit();
  tmaxfillunit_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tMaxFillUnit)
}

// optional int32 actionTIme = 36;
inline bool StartResponse::has_actiontime() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void StartResponse::set_has_actiontime() {
  _has_bits_[1] |= 0x00000008u;
}
inline void StartResponse::clear_has_actiontime() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void StartResponse::clear_actiontime() {
  actiontime_ = 0;
  clear_has_actiontime();
}
inline ::google::protobuf::int32 StartResponse::actiontime() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.actionTIme)
  return actiontime_;
}
inline void StartResponse::set_actiontime(::google::protobuf::int32 value) {
  set_has_actiontime();
  actiontime_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.actionTIme)
}

// optional int32 tActionTIme = 37;
inline bool StartResponse::has_tactiontime() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void StartResponse::set_has_tactiontime() {
  _has_bits_[1] |= 0x00000010u;
}
inline void StartResponse::clear_has_tactiontime() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void StartResponse::clear_tactiontime() {
  tactiontime_ = 0;
  clear_has_tactiontime();
}
inline ::google::protobuf::int32 StartResponse::tactiontime() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.tActionTIme)
  return tactiontime_;
}
inline void StartResponse::set_tactiontime(::google::protobuf::int32 value) {
  set_has_tactiontime();
  tactiontime_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.tActionTIme)
}

// optional int32 youBaseHp = 38;
inline bool StartResponse::has_youbasehp() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void StartResponse::set_has_youbasehp() {
  _has_bits_[1] |= 0x00000020u;
}
inline void StartResponse::clear_has_youbasehp() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void StartResponse::clear_youbasehp() {
  youbasehp_ = 0;
  clear_has_youbasehp();
}
inline ::google::protobuf::int32 StartResponse::youbasehp() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.youBaseHp)
  return youbasehp_;
}
inline void StartResponse::set_youbasehp(::google::protobuf::int32 value) {
  set_has_youbasehp();
  youbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.youBaseHp)
}

// optional int32 himBaseHp = 39;
inline bool StartResponse::has_himbasehp() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void StartResponse::set_has_himbasehp() {
  _has_bits_[1] |= 0x00000040u;
}
inline void StartResponse::clear_has_himbasehp() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void StartResponse::clear_himbasehp() {
  himbasehp_ = 0;
  clear_has_himbasehp();
}
inline ::google::protobuf::int32 StartResponse::himbasehp() const {
  // @@protoc_insertion_point(field_get:main.StartResponse.himBaseHp)
  return himbasehp_;
}
inline void StartResponse::set_himbasehp(::google::protobuf::int32 value) {
  set_has_himbasehp();
  himbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.StartResponse.himBaseHp)
}

// -------------------------------------------------------------------

// PveContinuePlayRequest

// required int32 request = 1;
inline bool PveContinuePlayRequest::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveContinuePlayRequest::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveContinuePlayRequest::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveContinuePlayRequest::clear_request() {
  request_ = 0;
  clear_has_request();
}
inline ::google::protobuf::int32 PveContinuePlayRequest::request() const {
  // @@protoc_insertion_point(field_get:main.PveContinuePlayRequest.request)
  return request_;
}
inline void PveContinuePlayRequest::set_request(::google::protobuf::int32 value) {
  set_has_request();
  request_ = value;
  // @@protoc_insertion_point(field_set:main.PveContinuePlayRequest.request)
}

// -------------------------------------------------------------------

// PveStarRequest

// -------------------------------------------------------------------

// PveStarResponse

// optional int32 state = 1;
inline bool PveStarResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveStarResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveStarResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveStarResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 PveStarResponse::state() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.state)
  return state_;
}
inline void PveStarResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.state)
}

// optional string failMsg = 2;
inline bool PveStarResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PveStarResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PveStarResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PveStarResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& PveStarResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.failMsg)
  return *failmsg_;
}
inline void PveStarResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.PveStarResponse.failMsg)
}
inline void PveStarResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PveStarResponse.failMsg)
}
inline void PveStarResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PveStarResponse.failMsg)
}
inline ::std::string* PveStarResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.failMsg)
  return failmsg_;
}
inline ::std::string* PveStarResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PveStarResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PveStarResponse.failMsg)
}

// repeated .main.FightSpirit spiritsYou = 3;
inline int PveStarResponse::spiritsyou_size() const {
  return spiritsyou_.size();
}
inline void PveStarResponse::clear_spiritsyou() {
  spiritsyou_.Clear();
}
inline const ::main::FightSpirit& PveStarResponse::spiritsyou(int index) const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.spiritsYou)
  return spiritsyou_.Get(index);
}
inline ::main::FightSpirit* PveStarResponse::mutable_spiritsyou(int index) {
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.spiritsYou)
  return spiritsyou_.Mutable(index);
}
inline ::main::FightSpirit* PveStarResponse::add_spiritsyou() {
  // @@protoc_insertion_point(field_add:main.PveStarResponse.spiritsYou)
  return spiritsyou_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
PveStarResponse::spiritsyou() const {
  // @@protoc_insertion_point(field_list:main.PveStarResponse.spiritsYou)
  return spiritsyou_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
PveStarResponse::mutable_spiritsyou() {
  // @@protoc_insertion_point(field_mutable_list:main.PveStarResponse.spiritsYou)
  return &spiritsyou_;
}

// repeated .main.FightSpirit spiritsHim = 4;
inline int PveStarResponse::spiritshim_size() const {
  return spiritshim_.size();
}
inline void PveStarResponse::clear_spiritshim() {
  spiritshim_.Clear();
}
inline const ::main::FightSpirit& PveStarResponse::spiritshim(int index) const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.spiritsHim)
  return spiritshim_.Get(index);
}
inline ::main::FightSpirit* PveStarResponse::mutable_spiritshim(int index) {
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.spiritsHim)
  return spiritshim_.Mutable(index);
}
inline ::main::FightSpirit* PveStarResponse::add_spiritshim() {
  // @@protoc_insertion_point(field_add:main.PveStarResponse.spiritsHim)
  return spiritshim_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
PveStarResponse::spiritshim() const {
  // @@protoc_insertion_point(field_list:main.PveStarResponse.spiritsHim)
  return spiritshim_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
PveStarResponse::mutable_spiritshim() {
  // @@protoc_insertion_point(field_mutable_list:main.PveStarResponse.spiritsHim)
  return &spiritshim_;
}

// optional bool isFirstAttack = 5;
inline bool PveStarResponse::has_isfirstattack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PveStarResponse::set_has_isfirstattack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PveStarResponse::clear_has_isfirstattack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PveStarResponse::clear_isfirstattack() {
  isfirstattack_ = false;
  clear_has_isfirstattack();
}
inline bool PveStarResponse::isfirstattack() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.isFirstAttack)
  return isfirstattack_;
}
inline void PveStarResponse::set_isfirstattack(bool value) {
  set_has_isfirstattack();
  isfirstattack_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.isFirstAttack)
}

// optional int32 youHp = 6;
inline bool PveStarResponse::has_youhp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PveStarResponse::set_has_youhp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PveStarResponse::clear_has_youhp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PveStarResponse::clear_youhp() {
  youhp_ = 0;
  clear_has_youhp();
}
inline ::google::protobuf::int32 PveStarResponse::youhp() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.youHp)
  return youhp_;
}
inline void PveStarResponse::set_youhp(::google::protobuf::int32 value) {
  set_has_youhp();
  youhp_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.youHp)
}

// optional int32 himHp = 7;
inline bool PveStarResponse::has_himhp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PveStarResponse::set_has_himhp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PveStarResponse::clear_has_himhp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PveStarResponse::clear_himhp() {
  himhp_ = 0;
  clear_has_himhp();
}
inline ::google::protobuf::int32 PveStarResponse::himhp() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.himHp)
  return himhp_;
}
inline void PveStarResponse::set_himhp(::google::protobuf::int32 value) {
  set_has_himhp();
  himhp_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.himHp)
}

// optional int32 youActionCount = 8;
inline bool PveStarResponse::has_youactioncount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PveStarResponse::set_has_youactioncount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PveStarResponse::clear_has_youactioncount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PveStarResponse::clear_youactioncount() {
  youactioncount_ = 0;
  clear_has_youactioncount();
}
inline ::google::protobuf::int32 PveStarResponse::youactioncount() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.youActionCount)
  return youactioncount_;
}
inline void PveStarResponse::set_youactioncount(::google::protobuf::int32 value) {
  set_has_youactioncount();
  youactioncount_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.youActionCount)
}

// optional int32 himActionCount = 9;
inline bool PveStarResponse::has_himactioncount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PveStarResponse::set_has_himactioncount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PveStarResponse::clear_has_himactioncount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PveStarResponse::clear_himactioncount() {
  himactioncount_ = 0;
  clear_has_himactioncount();
}
inline ::google::protobuf::int32 PveStarResponse::himactioncount() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.himActionCount)
  return himactioncount_;
}
inline void PveStarResponse::set_himactioncount(::google::protobuf::int32 value) {
  set_has_himactioncount();
  himactioncount_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.himActionCount)
}

// optional string fid = 10;
inline bool PveStarResponse::has_fid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PveStarResponse::set_has_fid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PveStarResponse::clear_has_fid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PveStarResponse::clear_fid() {
  if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_->clear();
  }
  clear_has_fid();
}
inline const ::std::string& PveStarResponse::fid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.fid)
  return *fid_;
}
inline void PveStarResponse::set_fid(const ::std::string& value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
  // @@protoc_insertion_point(field_set:main.PveStarResponse.fid)
}
inline void PveStarResponse::set_fid(const char* value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PveStarResponse.fid)
}
inline void PveStarResponse::set_fid(const char* value, size_t size) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PveStarResponse.fid)
}
inline ::std::string* PveStarResponse::mutable_fid() {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.fid)
  return fid_;
}
inline ::std::string* PveStarResponse::release_fid() {
  clear_has_fid();
  if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fid_;
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PveStarResponse::set_allocated_fid(::std::string* fid) {
  if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fid_;
  }
  if (fid) {
    set_has_fid();
    fid_ = fid;
  } else {
    clear_has_fid();
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PveStarResponse.fid)
}

// optional int32 lordId = 11;
inline bool PveStarResponse::has_lordid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PveStarResponse::set_has_lordid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PveStarResponse::clear_has_lordid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PveStarResponse::clear_lordid() {
  lordid_ = 0;
  clear_has_lordid();
}
inline ::google::protobuf::int32 PveStarResponse::lordid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordId)
  return lordid_;
}
inline void PveStarResponse::set_lordid(::google::protobuf::int32 value) {
  set_has_lordid();
  lordid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordId)
}

// optional string lordName = 12;
inline bool PveStarResponse::has_lordname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PveStarResponse::set_has_lordname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PveStarResponse::clear_has_lordname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PveStarResponse::clear_lordname() {
  if (lordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_->clear();
  }
  clear_has_lordname();
}
inline const ::std::string& PveStarResponse::lordname() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordName)
  return *lordname_;
}
inline void PveStarResponse::set_lordname(const ::std::string& value) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(value);
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordName)
}
inline void PveStarResponse::set_lordname(const char* value) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PveStarResponse.lordName)
}
inline void PveStarResponse::set_lordname(const char* value, size_t size) {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  lordname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PveStarResponse.lordName)
}
inline ::std::string* PveStarResponse::mutable_lordname() {
  set_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lordname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.lordName)
  return lordname_;
}
inline ::std::string* PveStarResponse::release_lordname() {
  clear_has_lordname();
  if (lordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lordname_;
    lordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PveStarResponse::set_allocated_lordname(::std::string* lordname) {
  if (lordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lordname_;
  }
  if (lordname) {
    set_has_lordname();
    lordname_ = lordname;
  } else {
    clear_has_lordname();
    lordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PveStarResponse.lordName)
}

// optional int32 lordSkillBelongId = 13;
inline bool PveStarResponse::has_lordskillbelongid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PveStarResponse::set_has_lordskillbelongid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PveStarResponse::clear_has_lordskillbelongid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PveStarResponse::clear_lordskillbelongid() {
  lordskillbelongid_ = 0;
  clear_has_lordskillbelongid();
}
inline ::google::protobuf::int32 PveStarResponse::lordskillbelongid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordSkillBelongId)
  return lordskillbelongid_;
}
inline void PveStarResponse::set_lordskillbelongid(::google::protobuf::int32 value) {
  set_has_lordskillbelongid();
  lordskillbelongid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordSkillBelongId)
}

// optional int32 lordSkillId = 14;
inline bool PveStarResponse::has_lordskillid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PveStarResponse::set_has_lordskillid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PveStarResponse::clear_has_lordskillid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PveStarResponse::clear_lordskillid() {
  lordskillid_ = 0;
  clear_has_lordskillid();
}
inline ::google::protobuf::int32 PveStarResponse::lordskillid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordSkillId)
  return lordskillid_;
}
inline void PveStarResponse::set_lordskillid(::google::protobuf::int32 value) {
  set_has_lordskillid();
  lordskillid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordSkillId)
}

// optional int32 tlordId = 15;
inline bool PveStarResponse::has_tlordid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PveStarResponse::set_has_tlordid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PveStarResponse::clear_has_tlordid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PveStarResponse::clear_tlordid() {
  tlordid_ = 0;
  clear_has_tlordid();
}
inline ::google::protobuf::int32 PveStarResponse::tlordid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordId)
  return tlordid_;
}
inline void PveStarResponse::set_tlordid(::google::protobuf::int32 value) {
  set_has_tlordid();
  tlordid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordId)
}

// optional string tlordName = 16;
inline bool PveStarResponse::has_tlordname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PveStarResponse::set_has_tlordname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PveStarResponse::clear_has_tlordname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PveStarResponse::clear_tlordname() {
  if (tlordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_->clear();
  }
  clear_has_tlordname();
}
inline const ::std::string& PveStarResponse::tlordname() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordName)
  return *tlordname_;
}
inline void PveStarResponse::set_tlordname(const ::std::string& value) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(value);
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordName)
}
inline void PveStarResponse::set_tlordname(const char* value) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.PveStarResponse.tlordName)
}
inline void PveStarResponse::set_tlordname(const char* value, size_t size) {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  tlordname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.PveStarResponse.tlordName)
}
inline ::std::string* PveStarResponse::mutable_tlordname() {
  set_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tlordname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.tlordName)
  return tlordname_;
}
inline ::std::string* PveStarResponse::release_tlordname() {
  clear_has_tlordname();
  if (tlordname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tlordname_;
    tlordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PveStarResponse::set_allocated_tlordname(::std::string* tlordname) {
  if (tlordname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tlordname_;
  }
  if (tlordname) {
    set_has_tlordname();
    tlordname_ = tlordname;
  } else {
    clear_has_tlordname();
    tlordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.PveStarResponse.tlordName)
}

// optional int32 tlordSkillBelongId = 17;
inline bool PveStarResponse::has_tlordskillbelongid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PveStarResponse::set_has_tlordskillbelongid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PveStarResponse::clear_has_tlordskillbelongid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PveStarResponse::clear_tlordskillbelongid() {
  tlordskillbelongid_ = 0;
  clear_has_tlordskillbelongid();
}
inline ::google::protobuf::int32 PveStarResponse::tlordskillbelongid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordSkillBelongId)
  return tlordskillbelongid_;
}
inline void PveStarResponse::set_tlordskillbelongid(::google::protobuf::int32 value) {
  set_has_tlordskillbelongid();
  tlordskillbelongid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordSkillBelongId)
}

// optional int32 tlordSkillId = 18;
inline bool PveStarResponse::has_tlordskillid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PveStarResponse::set_has_tlordskillid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PveStarResponse::clear_has_tlordskillid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PveStarResponse::clear_tlordskillid() {
  tlordskillid_ = 0;
  clear_has_tlordskillid();
}
inline ::google::protobuf::int32 PveStarResponse::tlordskillid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordSkillId)
  return tlordskillid_;
}
inline void PveStarResponse::set_tlordskillid(::google::protobuf::int32 value) {
  set_has_tlordskillid();
  tlordskillid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordSkillId)
}

// optional int32 tlordSkillLevel = 19;
inline bool PveStarResponse::has_tlordskilllevel() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PveStarResponse::set_has_tlordskilllevel() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PveStarResponse::clear_has_tlordskilllevel() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PveStarResponse::clear_tlordskilllevel() {
  tlordskilllevel_ = 0;
  clear_has_tlordskilllevel();
}
inline ::google::protobuf::int32 PveStarResponse::tlordskilllevel() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordSkillLevel)
  return tlordskilllevel_;
}
inline void PveStarResponse::set_tlordskilllevel(::google::protobuf::int32 value) {
  set_has_tlordskilllevel();
  tlordskilllevel_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordSkillLevel)
}

// optional int32 lordCdRoundBase = 20;
inline bool PveStarResponse::has_lordcdroundbase() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PveStarResponse::set_has_lordcdroundbase() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PveStarResponse::clear_has_lordcdroundbase() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PveStarResponse::clear_lordcdroundbase() {
  lordcdroundbase_ = 0;
  clear_has_lordcdroundbase();
}
inline ::google::protobuf::int32 PveStarResponse::lordcdroundbase() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordCdRoundBase)
  return lordcdroundbase_;
}
inline void PveStarResponse::set_lordcdroundbase(::google::protobuf::int32 value) {
  set_has_lordcdroundbase();
  lordcdroundbase_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordCdRoundBase)
}

// optional int32 tlordCdRoundBase = 21;
inline bool PveStarResponse::has_tlordcdroundbase() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PveStarResponse::set_has_tlordcdroundbase() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PveStarResponse::clear_has_tlordcdroundbase() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PveStarResponse::clear_tlordcdroundbase() {
  tlordcdroundbase_ = 0;
  clear_has_tlordcdroundbase();
}
inline ::google::protobuf::int32 PveStarResponse::tlordcdroundbase() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tlordCdRoundBase)
  return tlordcdroundbase_;
}
inline void PveStarResponse::set_tlordcdroundbase(::google::protobuf::int32 value) {
  set_has_tlordcdroundbase();
  tlordcdroundbase_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tlordCdRoundBase)
}

// optional int32 clientType = 22;
inline bool PveStarResponse::has_clienttype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PveStarResponse::set_has_clienttype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PveStarResponse::clear_has_clienttype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PveStarResponse::clear_clienttype() {
  clienttype_ = 0;
  clear_has_clienttype();
}
inline ::google::protobuf::int32 PveStarResponse::clienttype() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.clientType)
  return clienttype_;
}
inline void PveStarResponse::set_clienttype(::google::protobuf::int32 value) {
  set_has_clienttype();
  clienttype_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.clientType)
}

// optional int32 nation = 23;
inline bool PveStarResponse::has_nation() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PveStarResponse::set_has_nation() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PveStarResponse::clear_has_nation() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PveStarResponse::clear_nation() {
  nation_ = 0;
  clear_has_nation();
}
inline ::google::protobuf::int32 PveStarResponse::nation() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.nation)
  return nation_;
}
inline void PveStarResponse::set_nation(::google::protobuf::int32 value) {
  set_has_nation();
  nation_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.nation)
}

// optional int32 tnation = 24;
inline bool PveStarResponse::has_tnation() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PveStarResponse::set_has_tnation() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PveStarResponse::clear_has_tnation() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PveStarResponse::clear_tnation() {
  tnation_ = 0;
  clear_has_tnation();
}
inline ::google::protobuf::int32 PveStarResponse::tnation() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tnation)
  return tnation_;
}
inline void PveStarResponse::set_tnation(::google::protobuf::int32 value) {
  set_has_tnation();
  tnation_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tnation)
}

// optional int32 lordAtkMode = 25;
inline bool PveStarResponse::has_lordatkmode() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PveStarResponse::set_has_lordatkmode() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PveStarResponse::clear_has_lordatkmode() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PveStarResponse::clear_lordatkmode() {
  lordatkmode_ = 0;
  clear_has_lordatkmode();
}
inline ::google::protobuf::int32 PveStarResponse::lordatkmode() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordAtkMode)
  return lordatkmode_;
}
inline void PveStarResponse::set_lordatkmode(::google::protobuf::int32 value) {
  set_has_lordatkmode();
  lordatkmode_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordAtkMode)
}

// optional int32 TlordAtkMode = 26;
inline bool PveStarResponse::has_tlordatkmode() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PveStarResponse::set_has_tlordatkmode() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PveStarResponse::clear_has_tlordatkmode() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PveStarResponse::clear_tlordatkmode() {
  tlordatkmode_ = 0;
  clear_has_tlordatkmode();
}
inline ::google::protobuf::int32 PveStarResponse::tlordatkmode() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.TlordAtkMode)
  return tlordatkmode_;
}
inline void PveStarResponse::set_tlordatkmode(::google::protobuf::int32 value) {
  set_has_tlordatkmode();
  tlordatkmode_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.TlordAtkMode)
}

// optional int32 youActionCountByAdd = 27;
inline bool PveStarResponse::has_youactioncountbyadd() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PveStarResponse::set_has_youactioncountbyadd() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PveStarResponse::clear_has_youactioncountbyadd() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PveStarResponse::clear_youactioncountbyadd() {
  youactioncountbyadd_ = 0;
  clear_has_youactioncountbyadd();
}
inline ::google::protobuf::int32 PveStarResponse::youactioncountbyadd() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.youActionCountByAdd)
  return youactioncountbyadd_;
}
inline void PveStarResponse::set_youactioncountbyadd(::google::protobuf::int32 value) {
  set_has_youactioncountbyadd();
  youactioncountbyadd_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.youActionCountByAdd)
}

// optional int32 himActionCountByAdd = 28;
inline bool PveStarResponse::has_himactioncountbyadd() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PveStarResponse::set_has_himactioncountbyadd() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PveStarResponse::clear_has_himactioncountbyadd() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PveStarResponse::clear_himactioncountbyadd() {
  himactioncountbyadd_ = 0;
  clear_has_himactioncountbyadd();
}
inline ::google::protobuf::int32 PveStarResponse::himactioncountbyadd() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.himActionCountByAdd)
  return himactioncountbyadd_;
}
inline void PveStarResponse::set_himactioncountbyadd(::google::protobuf::int32 value) {
  set_has_himactioncountbyadd();
  himactioncountbyadd_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.himActionCountByAdd)
}

// optional int32 mapId = 29;
inline bool PveStarResponse::has_mapid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PveStarResponse::set_has_mapid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PveStarResponse::clear_has_mapid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PveStarResponse::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 PveStarResponse::mapid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.mapId)
  return mapid_;
}
inline void PveStarResponse::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.mapId)
}

// optional int32 friendOfficerCdRoundCurrent = 30;
inline bool PveStarResponse::has_friendofficercdroundcurrent() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PveStarResponse::set_has_friendofficercdroundcurrent() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PveStarResponse::clear_has_friendofficercdroundcurrent() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PveStarResponse::clear_friendofficercdroundcurrent() {
  friendofficercdroundcurrent_ = 0;
  clear_has_friendofficercdroundcurrent();
}
inline ::google::protobuf::int32 PveStarResponse::friendofficercdroundcurrent() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.friendOfficerCdRoundCurrent)
  return friendofficercdroundcurrent_;
}
inline void PveStarResponse::set_friendofficercdroundcurrent(::google::protobuf::int32 value) {
  set_has_friendofficercdroundcurrent();
  friendofficercdroundcurrent_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.friendOfficerCdRoundCurrent)
}

// optional int32 friendOfficerCdRound = 31;
inline bool PveStarResponse::has_friendofficercdround() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PveStarResponse::set_has_friendofficercdround() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PveStarResponse::clear_has_friendofficercdround() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PveStarResponse::clear_friendofficercdround() {
  friendofficercdround_ = 0;
  clear_has_friendofficercdround();
}
inline ::google::protobuf::int32 PveStarResponse::friendofficercdround() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.friendOfficerCdRound)
  return friendofficercdround_;
}
inline void PveStarResponse::set_friendofficercdround(::google::protobuf::int32 value) {
  set_has_friendofficercdround();
  friendofficercdround_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.friendOfficerCdRound)
}

// optional int32 friendOfficerId = 32;
inline bool PveStarResponse::has_friendofficerid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PveStarResponse::set_has_friendofficerid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PveStarResponse::clear_has_friendofficerid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PveStarResponse::clear_friendofficerid() {
  friendofficerid_ = 0;
  clear_has_friendofficerid();
}
inline ::google::protobuf::int32 PveStarResponse::friendofficerid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.friendOfficerId)
  return friendofficerid_;
}
inline void PveStarResponse::set_friendofficerid(::google::protobuf::int32 value) {
  set_has_friendofficerid();
  friendofficerid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.friendOfficerId)
}

// optional int32 friendOfficerLevel = 33;
inline bool PveStarResponse::has_friendofficerlevel() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PveStarResponse::set_has_friendofficerlevel() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PveStarResponse::clear_has_friendofficerlevel() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PveStarResponse::clear_friendofficerlevel() {
  friendofficerlevel_ = 0;
  clear_has_friendofficerlevel();
}
inline ::google::protobuf::int32 PveStarResponse::friendofficerlevel() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.friendOfficerLevel)
  return friendofficerlevel_;
}
inline void PveStarResponse::set_friendofficerlevel(::google::protobuf::int32 value) {
  set_has_friendofficerlevel();
  friendofficerlevel_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.friendOfficerLevel)
}

// optional int32 roleId = 34;
inline bool PveStarResponse::has_roleid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PveStarResponse::set_has_roleid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PveStarResponse::clear_has_roleid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PveStarResponse::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 PveStarResponse::roleid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.roleId)
  return roleid_;
}
inline void PveStarResponse::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.roleId)
}

// optional int32 tRoleId = 35;
inline bool PveStarResponse::has_troleid() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PveStarResponse::set_has_troleid() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PveStarResponse::clear_has_troleid() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PveStarResponse::clear_troleid() {
  troleid_ = 0;
  clear_has_troleid();
}
inline ::google::protobuf::int32 PveStarResponse::troleid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tRoleId)
  return troleid_;
}
inline void PveStarResponse::set_troleid(::google::protobuf::int32 value) {
  set_has_troleid();
  troleid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tRoleId)
}

// optional int32 maxFillUnit = 36;
inline bool PveStarResponse::has_maxfillunit() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PveStarResponse::set_has_maxfillunit() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PveStarResponse::clear_has_maxfillunit() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PveStarResponse::clear_maxfillunit() {
  maxfillunit_ = 0;
  clear_has_maxfillunit();
}
inline ::google::protobuf::int32 PveStarResponse::maxfillunit() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.maxFillUnit)
  return maxfillunit_;
}
inline void PveStarResponse::set_maxfillunit(::google::protobuf::int32 value) {
  set_has_maxfillunit();
  maxfillunit_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.maxFillUnit)
}

// optional int32 tMaxFillUnit = 37;
inline bool PveStarResponse::has_tmaxfillunit() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PveStarResponse::set_has_tmaxfillunit() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PveStarResponse::clear_has_tmaxfillunit() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PveStarResponse::clear_tmaxfillunit() {
  tmaxfillunit_ = 0;
  clear_has_tmaxfillunit();
}
inline ::google::protobuf::int32 PveStarResponse::tmaxfillunit() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tMaxFillUnit)
  return tmaxfillunit_;
}
inline void PveStarResponse::set_tmaxfillunit(::google::protobuf::int32 value) {
  set_has_tmaxfillunit();
  tmaxfillunit_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tMaxFillUnit)
}

// optional int32 tClientType = 38;
inline bool PveStarResponse::has_tclienttype() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PveStarResponse::set_has_tclienttype() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PveStarResponse::clear_has_tclienttype() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PveStarResponse::clear_tclienttype() {
  tclienttype_ = 0;
  clear_has_tclienttype();
}
inline ::google::protobuf::int32 PveStarResponse::tclienttype() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tClientType)
  return tclienttype_;
}
inline void PveStarResponse::set_tclienttype(::google::protobuf::int32 value) {
  set_has_tclienttype();
  tclienttype_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tClientType)
}

// optional int32 speed = 39;
inline bool PveStarResponse::has_speed() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PveStarResponse::set_has_speed() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PveStarResponse::clear_has_speed() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PveStarResponse::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 PveStarResponse::speed() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.speed)
  return speed_;
}
inline void PveStarResponse::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.speed)
}

// optional int32 tspeed = 40;
inline bool PveStarResponse::has_tspeed() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PveStarResponse::set_has_tspeed() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PveStarResponse::clear_has_tspeed() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PveStarResponse::clear_tspeed() {
  tspeed_ = 0;
  clear_has_tspeed();
}
inline ::google::protobuf::int32 PveStarResponse::tspeed() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.tspeed)
  return tspeed_;
}
inline void PveStarResponse::set_tspeed(::google::protobuf::int32 value) {
  set_has_tspeed();
  tspeed_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.tspeed)
}

// optional int32 dropItemCount = 41;
inline bool PveStarResponse::has_dropitemcount() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PveStarResponse::set_has_dropitemcount() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PveStarResponse::clear_has_dropitemcount() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PveStarResponse::clear_dropitemcount() {
  dropitemcount_ = 0;
  clear_has_dropitemcount();
}
inline ::google::protobuf::int32 PveStarResponse::dropitemcount() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.dropItemCount)
  return dropitemcount_;
}
inline void PveStarResponse::set_dropitemcount(::google::protobuf::int32 value) {
  set_has_dropitemcount();
  dropitemcount_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.dropItemCount)
}

// optional int32 youBaseHp = 42;
inline bool PveStarResponse::has_youbasehp() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PveStarResponse::set_has_youbasehp() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PveStarResponse::clear_has_youbasehp() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PveStarResponse::clear_youbasehp() {
  youbasehp_ = 0;
  clear_has_youbasehp();
}
inline ::google::protobuf::int32 PveStarResponse::youbasehp() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.youBaseHp)
  return youbasehp_;
}
inline void PveStarResponse::set_youbasehp(::google::protobuf::int32 value) {
  set_has_youbasehp();
  youbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.youBaseHp)
}

// optional int32 himBaseHp = 43;
inline bool PveStarResponse::has_himbasehp() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PveStarResponse::set_has_himbasehp() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PveStarResponse::clear_has_himbasehp() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PveStarResponse::clear_himbasehp() {
  himbasehp_ = 0;
  clear_has_himbasehp();
}
inline ::google::protobuf::int32 PveStarResponse::himbasehp() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.himBaseHp)
  return himbasehp_;
}
inline void PveStarResponse::set_himbasehp(::google::protobuf::int32 value) {
  set_has_himbasehp();
  himbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.himBaseHp)
}

// optional int32 lordCdRound = 44;
inline bool PveStarResponse::has_lordcdround() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PveStarResponse::set_has_lordcdround() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PveStarResponse::clear_has_lordcdround() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PveStarResponse::clear_lordcdround() {
  lordcdround_ = 0;
  clear_has_lordcdround();
}
inline ::google::protobuf::int32 PveStarResponse::lordcdround() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.lordCdRound)
  return lordcdround_;
}
inline void PveStarResponse::set_lordcdround(::google::protobuf::int32 value) {
  set_has_lordcdround();
  lordcdround_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.lordCdRound)
}

// optional int32 plotId = 45;
inline bool PveStarResponse::has_plotid() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PveStarResponse::set_has_plotid() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PveStarResponse::clear_has_plotid() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PveStarResponse::clear_plotid() {
  plotid_ = 0;
  clear_has_plotid();
}
inline ::google::protobuf::int32 PveStarResponse::plotid() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.plotId)
  return plotid_;
}
inline void PveStarResponse::set_plotid(::google::protobuf::int32 value) {
  set_has_plotid();
  plotid_ = value;
  // @@protoc_insertion_point(field_set:main.PveStarResponse.plotId)
}

// repeated .main.FightSpirit selfTempOfficer = 46;
inline int PveStarResponse::selftempofficer_size() const {
  return selftempofficer_.size();
}
inline void PveStarResponse::clear_selftempofficer() {
  selftempofficer_.Clear();
}
inline const ::main::FightSpirit& PveStarResponse::selftempofficer(int index) const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.selfTempOfficer)
  return selftempofficer_.Get(index);
}
inline ::main::FightSpirit* PveStarResponse::mutable_selftempofficer(int index) {
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.selfTempOfficer)
  return selftempofficer_.Mutable(index);
}
inline ::main::FightSpirit* PveStarResponse::add_selftempofficer() {
  // @@protoc_insertion_point(field_add:main.PveStarResponse.selfTempOfficer)
  return selftempofficer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
PveStarResponse::selftempofficer() const {
  // @@protoc_insertion_point(field_list:main.PveStarResponse.selfTempOfficer)
  return selftempofficer_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
PveStarResponse::mutable_selftempofficer() {
  // @@protoc_insertion_point(field_mutable_list:main.PveStarResponse.selfTempOfficer)
  return &selftempofficer_;
}

// repeated .main.FightSpirit aiTempOfficer = 47;
inline int PveStarResponse::aitempofficer_size() const {
  return aitempofficer_.size();
}
inline void PveStarResponse::clear_aitempofficer() {
  aitempofficer_.Clear();
}
inline const ::main::FightSpirit& PveStarResponse::aitempofficer(int index) const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.aiTempOfficer)
  return aitempofficer_.Get(index);
}
inline ::main::FightSpirit* PveStarResponse::mutable_aitempofficer(int index) {
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.aiTempOfficer)
  return aitempofficer_.Mutable(index);
}
inline ::main::FightSpirit* PveStarResponse::add_aitempofficer() {
  // @@protoc_insertion_point(field_add:main.PveStarResponse.aiTempOfficer)
  return aitempofficer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
PveStarResponse::aitempofficer() const {
  // @@protoc_insertion_point(field_list:main.PveStarResponse.aiTempOfficer)
  return aitempofficer_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
PveStarResponse::mutable_aitempofficer() {
  // @@protoc_insertion_point(field_mutable_list:main.PveStarResponse.aiTempOfficer)
  return &aitempofficer_;
}

// optional .main.FightSpirit cooTempOfficer = 48;
inline bool PveStarResponse::has_cootempofficer() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PveStarResponse::set_has_cootempofficer() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PveStarResponse::clear_has_cootempofficer() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PveStarResponse::clear_cootempofficer() {
  if (cootempofficer_ != NULL) cootempofficer_->::main::FightSpirit::Clear();
  clear_has_cootempofficer();
}
inline const ::main::FightSpirit& PveStarResponse::cootempofficer() const {
  // @@protoc_insertion_point(field_get:main.PveStarResponse.cooTempOfficer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cootempofficer_ != NULL ? *cootempofficer_ : *default_instance().cootempofficer_;
#else
  return cootempofficer_ != NULL ? *cootempofficer_ : *default_instance_->cootempofficer_;
#endif
}
inline ::main::FightSpirit* PveStarResponse::mutable_cootempofficer() {
  set_has_cootempofficer();
  if (cootempofficer_ == NULL) cootempofficer_ = new ::main::FightSpirit;
  // @@protoc_insertion_point(field_mutable:main.PveStarResponse.cooTempOfficer)
  return cootempofficer_;
}
inline ::main::FightSpirit* PveStarResponse::release_cootempofficer() {
  clear_has_cootempofficer();
  ::main::FightSpirit* temp = cootempofficer_;
  cootempofficer_ = NULL;
  return temp;
}
inline void PveStarResponse::set_allocated_cootempofficer(::main::FightSpirit* cootempofficer) {
  delete cootempofficer_;
  cootempofficer_ = cootempofficer;
  if (cootempofficer) {
    set_has_cootempofficer();
  } else {
    clear_has_cootempofficer();
  }
  // @@protoc_insertion_point(field_set_allocated:main.PveStarResponse.cooTempOfficer)
}

// -------------------------------------------------------------------

// FillUnitRequest

// optional int32 enemyRoleId = 1;
inline bool FillUnitRequest::has_enemyroleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillUnitRequest::set_has_enemyroleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillUnitRequest::clear_has_enemyroleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillUnitRequest::clear_enemyroleid() {
  enemyroleid_ = 0;
  clear_has_enemyroleid();
}
inline ::google::protobuf::int32 FillUnitRequest::enemyroleid() const {
  // @@protoc_insertion_point(field_get:main.FillUnitRequest.enemyRoleId)
  return enemyroleid_;
}
inline void FillUnitRequest::set_enemyroleid(::google::protobuf::int32 value) {
  set_has_enemyroleid();
  enemyroleid_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitRequest.enemyRoleId)
}

// -------------------------------------------------------------------

// FillUnitResponse

// optional int32 state = 1;
inline bool FillUnitResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillUnitResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillUnitResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillUnitResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FillUnitResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.state)
  return state_;
}
inline void FillUnitResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitResponse.state)
}

// optional string failMsg = 2;
inline bool FillUnitResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillUnitResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillUnitResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillUnitResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& FillUnitResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.failMsg)
  return *failmsg_;
}
inline void FillUnitResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.FillUnitResponse.failMsg)
}
inline void FillUnitResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.FillUnitResponse.failMsg)
}
inline void FillUnitResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.FillUnitResponse.failMsg)
}
inline ::std::string* FillUnitResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.FillUnitResponse.failMsg)
  return failmsg_;
}
inline ::std::string* FillUnitResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FillUnitResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.FillUnitResponse.failMsg)
}

// repeated .main.FightSpirit spirits = 3;
inline int FillUnitResponse::spirits_size() const {
  return spirits_.size();
}
inline void FillUnitResponse::clear_spirits() {
  spirits_.Clear();
}
inline const ::main::FightSpirit& FillUnitResponse::spirits(int index) const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.spirits)
  return spirits_.Get(index);
}
inline ::main::FightSpirit* FillUnitResponse::mutable_spirits(int index) {
  // @@protoc_insertion_point(field_mutable:main.FillUnitResponse.spirits)
  return spirits_.Mutable(index);
}
inline ::main::FightSpirit* FillUnitResponse::add_spirits() {
  // @@protoc_insertion_point(field_add:main.FillUnitResponse.spirits)
  return spirits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FillUnitResponse::spirits() const {
  // @@protoc_insertion_point(field_list:main.FillUnitResponse.spirits)
  return spirits_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FillUnitResponse::mutable_spirits() {
  // @@protoc_insertion_point(field_mutable_list:main.FillUnitResponse.spirits)
  return &spirits_;
}

// optional int32 actionCount = 4;
inline bool FillUnitResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FillUnitResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FillUnitResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FillUnitResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 FillUnitResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.actionCount)
  return actioncount_;
}
inline void FillUnitResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitResponse.actionCount)
}

// optional int32 isSelf = 5;
inline bool FillUnitResponse::has_isself() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FillUnitResponse::set_has_isself() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FillUnitResponse::clear_has_isself() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FillUnitResponse::clear_isself() {
  isself_ = 0;
  clear_has_isself();
}
inline ::google::protobuf::int32 FillUnitResponse::isself() const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.isSelf)
  return isself_;
}
inline void FillUnitResponse::set_isself(::google::protobuf::int32 value) {
  set_has_isself();
  isself_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitResponse.isSelf)
}

// optional int32 unLowerActionCount = 6;
inline bool FillUnitResponse::has_unloweractioncount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FillUnitResponse::set_has_unloweractioncount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FillUnitResponse::clear_has_unloweractioncount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FillUnitResponse::clear_unloweractioncount() {
  unloweractioncount_ = 0;
  clear_has_unloweractioncount();
}
inline ::google::protobuf::int32 FillUnitResponse::unloweractioncount() const {
  // @@protoc_insertion_point(field_get:main.FillUnitResponse.unLowerActionCount)
  return unloweractioncount_;
}
inline void FillUnitResponse::set_unloweractioncount(::google::protobuf::int32 value) {
  set_has_unloweractioncount();
  unloweractioncount_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitResponse.unLowerActionCount)
}

// -------------------------------------------------------------------

// FillUnitReviveRequest

// -------------------------------------------------------------------

// FillUnitReviveResponse

// optional int32 state = 1;
inline bool FillUnitReviveResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillUnitReviveResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillUnitReviveResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillUnitReviveResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FillUnitReviveResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FillUnitReviveResponse.state)
  return state_;
}
inline void FillUnitReviveResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitReviveResponse.state)
}

// optional int32 roleId = 2;
inline bool FillUnitReviveResponse::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillUnitReviveResponse::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillUnitReviveResponse::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillUnitReviveResponse::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 FillUnitReviveResponse::roleid() const {
  // @@protoc_insertion_point(field_get:main.FillUnitReviveResponse.roleId)
  return roleid_;
}
inline void FillUnitReviveResponse::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.FillUnitReviveResponse.roleId)
}

// repeated .main.FightSpirit spirits = 3;
inline int FillUnitReviveResponse::spirits_size() const {
  return spirits_.size();
}
inline void FillUnitReviveResponse::clear_spirits() {
  spirits_.Clear();
}
inline const ::main::FightSpirit& FillUnitReviveResponse::spirits(int index) const {
  // @@protoc_insertion_point(field_get:main.FillUnitReviveResponse.spirits)
  return spirits_.Get(index);
}
inline ::main::FightSpirit* FillUnitReviveResponse::mutable_spirits(int index) {
  // @@protoc_insertion_point(field_mutable:main.FillUnitReviveResponse.spirits)
  return spirits_.Mutable(index);
}
inline ::main::FightSpirit* FillUnitReviveResponse::add_spirits() {
  // @@protoc_insertion_point(field_add:main.FillUnitReviveResponse.spirits)
  return spirits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FillUnitReviveResponse::spirits() const {
  // @@protoc_insertion_point(field_list:main.FillUnitReviveResponse.spirits)
  return spirits_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FillUnitReviveResponse::mutable_spirits() {
  // @@protoc_insertion_point(field_mutable_list:main.FillUnitReviveResponse.spirits)
  return &spirits_;
}

// repeated .main.FightSpirit selfTempOfficer = 4;
inline int FillUnitReviveResponse::selftempofficer_size() const {
  return selftempofficer_.size();
}
inline void FillUnitReviveResponse::clear_selftempofficer() {
  selftempofficer_.Clear();
}
inline const ::main::FightSpirit& FillUnitReviveResponse::selftempofficer(int index) const {
  // @@protoc_insertion_point(field_get:main.FillUnitReviveResponse.selfTempOfficer)
  return selftempofficer_.Get(index);
}
inline ::main::FightSpirit* FillUnitReviveResponse::mutable_selftempofficer(int index) {
  // @@protoc_insertion_point(field_mutable:main.FillUnitReviveResponse.selfTempOfficer)
  return selftempofficer_.Mutable(index);
}
inline ::main::FightSpirit* FillUnitReviveResponse::add_selftempofficer() {
  // @@protoc_insertion_point(field_add:main.FillUnitReviveResponse.selfTempOfficer)
  return selftempofficer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FillUnitReviveResponse::selftempofficer() const {
  // @@protoc_insertion_point(field_list:main.FillUnitReviveResponse.selfTempOfficer)
  return selftempofficer_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FillUnitReviveResponse::mutable_selftempofficer() {
  // @@protoc_insertion_point(field_mutable_list:main.FillUnitReviveResponse.selfTempOfficer)
  return &selftempofficer_;
}

// -------------------------------------------------------------------

// QiangZhiFillUnitRequest

// -------------------------------------------------------------------

// QiangZhiFillUnitResponse

// optional int32 state = 1;
inline bool QiangZhiFillUnitResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QiangZhiFillUnitResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QiangZhiFillUnitResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QiangZhiFillUnitResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 QiangZhiFillUnitResponse::state() const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.state)
  return state_;
}
inline void QiangZhiFillUnitResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.QiangZhiFillUnitResponse.state)
}

// optional string failMsg = 2;
inline bool QiangZhiFillUnitResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QiangZhiFillUnitResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QiangZhiFillUnitResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QiangZhiFillUnitResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& QiangZhiFillUnitResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.failMsg)
  return *failmsg_;
}
inline void QiangZhiFillUnitResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.QiangZhiFillUnitResponse.failMsg)
}
inline void QiangZhiFillUnitResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.QiangZhiFillUnitResponse.failMsg)
}
inline void QiangZhiFillUnitResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.QiangZhiFillUnitResponse.failMsg)
}
inline ::std::string* QiangZhiFillUnitResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.QiangZhiFillUnitResponse.failMsg)
  return failmsg_;
}
inline ::std::string* QiangZhiFillUnitResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QiangZhiFillUnitResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.QiangZhiFillUnitResponse.failMsg)
}

// repeated .main.FightSpirit spirits = 3;
inline int QiangZhiFillUnitResponse::spirits_size() const {
  return spirits_.size();
}
inline void QiangZhiFillUnitResponse::clear_spirits() {
  spirits_.Clear();
}
inline const ::main::FightSpirit& QiangZhiFillUnitResponse::spirits(int index) const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.spirits)
  return spirits_.Get(index);
}
inline ::main::FightSpirit* QiangZhiFillUnitResponse::mutable_spirits(int index) {
  // @@protoc_insertion_point(field_mutable:main.QiangZhiFillUnitResponse.spirits)
  return spirits_.Mutable(index);
}
inline ::main::FightSpirit* QiangZhiFillUnitResponse::add_spirits() {
  // @@protoc_insertion_point(field_add:main.QiangZhiFillUnitResponse.spirits)
  return spirits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
QiangZhiFillUnitResponse::spirits() const {
  // @@protoc_insertion_point(field_list:main.QiangZhiFillUnitResponse.spirits)
  return spirits_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
QiangZhiFillUnitResponse::mutable_spirits() {
  // @@protoc_insertion_point(field_mutable_list:main.QiangZhiFillUnitResponse.spirits)
  return &spirits_;
}

// optional int32 actionCount = 4;
inline bool QiangZhiFillUnitResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QiangZhiFillUnitResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QiangZhiFillUnitResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QiangZhiFillUnitResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 QiangZhiFillUnitResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.actionCount)
  return actioncount_;
}
inline void QiangZhiFillUnitResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.QiangZhiFillUnitResponse.actionCount)
}

// optional int32 isSelf = 5;
inline bool QiangZhiFillUnitResponse::has_isself() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QiangZhiFillUnitResponse::set_has_isself() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QiangZhiFillUnitResponse::clear_has_isself() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QiangZhiFillUnitResponse::clear_isself() {
  isself_ = 0;
  clear_has_isself();
}
inline ::google::protobuf::int32 QiangZhiFillUnitResponse::isself() const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.isSelf)
  return isself_;
}
inline void QiangZhiFillUnitResponse::set_isself(::google::protobuf::int32 value) {
  set_has_isself();
  isself_ = value;
  // @@protoc_insertion_point(field_set:main.QiangZhiFillUnitResponse.isSelf)
}

// optional int32 unLowerActionCount = 6;
inline bool QiangZhiFillUnitResponse::has_unloweractioncount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QiangZhiFillUnitResponse::set_has_unloweractioncount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QiangZhiFillUnitResponse::clear_has_unloweractioncount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QiangZhiFillUnitResponse::clear_unloweractioncount() {
  unloweractioncount_ = 0;
  clear_has_unloweractioncount();
}
inline ::google::protobuf::int32 QiangZhiFillUnitResponse::unloweractioncount() const {
  // @@protoc_insertion_point(field_get:main.QiangZhiFillUnitResponse.unLowerActionCount)
  return unloweractioncount_;
}
inline void QiangZhiFillUnitResponse::set_unloweractioncount(::google::protobuf::int32 value) {
  set_has_unloweractioncount();
  unloweractioncount_ = value;
  // @@protoc_insertion_point(field_set:main.QiangZhiFillUnitResponse.unLowerActionCount)
}

// -------------------------------------------------------------------

// MoveRequest

// optional int32 x = 1;
inline bool MoveRequest::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveRequest::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MoveRequest::x() const {
  // @@protoc_insertion_point(field_get:main.MoveRequest.x)
  return x_;
}
inline void MoveRequest::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.MoveRequest.x)
}

// optional int32 tox = 2;
inline bool MoveRequest::has_tox() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveRequest::set_has_tox() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveRequest::clear_has_tox() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveRequest::clear_tox() {
  tox_ = 0;
  clear_has_tox();
}
inline ::google::protobuf::int32 MoveRequest::tox() const {
  // @@protoc_insertion_point(field_get:main.MoveRequest.tox)
  return tox_;
}
inline void MoveRequest::set_tox(::google::protobuf::int32 value) {
  set_has_tox();
  tox_ = value;
  // @@protoc_insertion_point(field_set:main.MoveRequest.tox)
}

// -------------------------------------------------------------------

// MoveResponse

// optional int32 state = 1;
inline bool MoveResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MoveResponse::state() const {
  // @@protoc_insertion_point(field_get:main.MoveResponse.state)
  return state_;
}
inline void MoveResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.MoveResponse.state)
}

// optional string failMsg = 2;
inline bool MoveResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& MoveResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.MoveResponse.failMsg)
  return *failmsg_;
}
inline void MoveResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.MoveResponse.failMsg)
}
inline void MoveResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.MoveResponse.failMsg)
}
inline void MoveResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.MoveResponse.failMsg)
}
inline ::std::string* MoveResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.MoveResponse.failMsg)
  return failmsg_;
}
inline ::std::string* MoveResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoveResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.MoveResponse.failMsg)
}

// optional int32 x = 3;
inline bool MoveResponse::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveResponse::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MoveResponse::x() const {
  // @@protoc_insertion_point(field_get:main.MoveResponse.x)
  return x_;
}
inline void MoveResponse::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.MoveResponse.x)
}

// optional int32 tox = 4;
inline bool MoveResponse::has_tox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveResponse::set_has_tox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveResponse::clear_has_tox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveResponse::clear_tox() {
  tox_ = 0;
  clear_has_tox();
}
inline ::google::protobuf::int32 MoveResponse::tox() const {
  // @@protoc_insertion_point(field_get:main.MoveResponse.tox)
  return tox_;
}
inline void MoveResponse::set_tox(::google::protobuf::int32 value) {
  set_has_tox();
  tox_ = value;
  // @@protoc_insertion_point(field_set:main.MoveResponse.tox)
}

// optional int32 actionCount = 5;
inline bool MoveResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 MoveResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.MoveResponse.actionCount)
  return actioncount_;
}
inline void MoveResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.MoveResponse.actionCount)
}

// -------------------------------------------------------------------

// GiveUpRequest

// -------------------------------------------------------------------

// GiveUpResponse

// optional int32 state = 1;
inline bool GiveUpResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiveUpResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiveUpResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiveUpResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 GiveUpResponse::state() const {
  // @@protoc_insertion_point(field_get:main.GiveUpResponse.state)
  return state_;
}
inline void GiveUpResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.GiveUpResponse.state)
}

// optional int32 round = 2 [default = -1];
inline bool GiveUpResponse::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiveUpResponse::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiveUpResponse::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiveUpResponse::clear_round() {
  round_ = -1;
  clear_has_round();
}
inline ::google::protobuf::int32 GiveUpResponse::round() const {
  // @@protoc_insertion_point(field_get:main.GiveUpResponse.round)
  return round_;
}
inline void GiveUpResponse::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
  // @@protoc_insertion_point(field_set:main.GiveUpResponse.round)
}

// optional sint32 skillResidueRound = 3;
inline bool GiveUpResponse::has_skillresidueround() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GiveUpResponse::set_has_skillresidueround() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GiveUpResponse::clear_has_skillresidueround() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GiveUpResponse::clear_skillresidueround() {
  skillresidueround_ = 0;
  clear_has_skillresidueround();
}
inline ::google::protobuf::int32 GiveUpResponse::skillresidueround() const {
  // @@protoc_insertion_point(field_get:main.GiveUpResponse.skillResidueRound)
  return skillresidueround_;
}
inline void GiveUpResponse::set_skillresidueround(::google::protobuf::int32 value) {
  set_has_skillresidueround();
  skillresidueround_ = value;
  // @@protoc_insertion_point(field_set:main.GiveUpResponse.skillResidueRound)
}

// optional sint32 actionCount = 4;
inline bool GiveUpResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GiveUpResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GiveUpResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GiveUpResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 GiveUpResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.GiveUpResponse.actionCount)
  return actioncount_;
}
inline void GiveUpResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.GiveUpResponse.actionCount)
}

// -------------------------------------------------------------------

// RemoveRequest

// optional int32 enemyRoleId = 1;
inline bool RemoveRequest::has_enemyroleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveRequest::set_has_enemyroleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveRequest::clear_has_enemyroleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveRequest::clear_enemyroleid() {
  enemyroleid_ = 0;
  clear_has_enemyroleid();
}
inline ::google::protobuf::int32 RemoveRequest::enemyroleid() const {
  // @@protoc_insertion_point(field_get:main.RemoveRequest.enemyRoleId)
  return enemyroleid_;
}
inline void RemoveRequest::set_enemyroleid(::google::protobuf::int32 value) {
  set_has_enemyroleid();
  enemyroleid_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveRequest.enemyRoleId)
}

// optional int32 x = 2;
inline bool RemoveRequest::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveRequest::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 RemoveRequest::x() const {
  // @@protoc_insertion_point(field_get:main.RemoveRequest.x)
  return x_;
}
inline void RemoveRequest::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveRequest.x)
}

// optional int32 y = 3;
inline bool RemoveRequest::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveRequest::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveRequest::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveRequest::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 RemoveRequest::y() const {
  // @@protoc_insertion_point(field_get:main.RemoveRequest.y)
  return y_;
}
inline void RemoveRequest::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveRequest.y)
}

// -------------------------------------------------------------------

// RemoveResponse

// optional int32 state = 1;
inline bool RemoveResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 RemoveResponse::state() const {
  // @@protoc_insertion_point(field_get:main.RemoveResponse.state)
  return state_;
}
inline void RemoveResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveResponse.state)
}

// optional string failMsg = 2;
inline bool RemoveResponse::has_failmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveResponse::set_has_failmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveResponse::clear_has_failmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveResponse::clear_failmsg() {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_->clear();
  }
  clear_has_failmsg();
}
inline const ::std::string& RemoveResponse::failmsg() const {
  // @@protoc_insertion_point(field_get:main.RemoveResponse.failMsg)
  return *failmsg_;
}
inline void RemoveResponse::set_failmsg(const ::std::string& value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.RemoveResponse.failMsg)
}
inline void RemoveResponse::set_failmsg(const char* value) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.RemoveResponse.failMsg)
}
inline void RemoveResponse::set_failmsg(const char* value, size_t size) {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  failmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.RemoveResponse.failMsg)
}
inline ::std::string* RemoveResponse::mutable_failmsg() {
  set_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.RemoveResponse.failMsg)
  return failmsg_;
}
inline ::std::string* RemoveResponse::release_failmsg() {
  clear_has_failmsg();
  if (failmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failmsg_;
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RemoveResponse::set_allocated_failmsg(::std::string* failmsg) {
  if (failmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failmsg_;
  }
  if (failmsg) {
    set_has_failmsg();
    failmsg_ = failmsg;
  } else {
    clear_has_failmsg();
    failmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.RemoveResponse.failMsg)
}

// optional int32 x = 3;
inline bool RemoveResponse::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveResponse::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 RemoveResponse::x() const {
  // @@protoc_insertion_point(field_get:main.RemoveResponse.x)
  return x_;
}
inline void RemoveResponse::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveResponse.x)
}

// optional int32 y = 4;
inline bool RemoveResponse::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveResponse::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 RemoveResponse::y() const {
  // @@protoc_insertion_point(field_get:main.RemoveResponse.y)
  return y_;
}
inline void RemoveResponse::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveResponse.y)
}

// optional int32 actionCount = 5;
inline bool RemoveResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 RemoveResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.RemoveResponse.actionCount)
  return actioncount_;
}
inline void RemoveResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.RemoveResponse.actionCount)
}

// -------------------------------------------------------------------

// ActionCountResponse

// optional int32 yourCount = 1;
inline bool ActionCountResponse::has_yourcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionCountResponse::set_has_yourcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionCountResponse::clear_has_yourcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionCountResponse::clear_yourcount() {
  yourcount_ = 0;
  clear_has_yourcount();
}
inline ::google::protobuf::int32 ActionCountResponse::yourcount() const {
  // @@protoc_insertion_point(field_get:main.ActionCountResponse.yourCount)
  return yourcount_;
}
inline void ActionCountResponse::set_yourcount(::google::protobuf::int32 value) {
  set_has_yourcount();
  yourcount_ = value;
  // @@protoc_insertion_point(field_set:main.ActionCountResponse.yourCount)
}

// optional int32 himCount = 2;
inline bool ActionCountResponse::has_himcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionCountResponse::set_has_himcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionCountResponse::clear_has_himcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionCountResponse::clear_himcount() {
  himcount_ = 0;
  clear_has_himcount();
}
inline ::google::protobuf::int32 ActionCountResponse::himcount() const {
  // @@protoc_insertion_point(field_get:main.ActionCountResponse.himCount)
  return himcount_;
}
inline void ActionCountResponse::set_himcount(::google::protobuf::int32 value) {
  set_has_himcount();
  himcount_ = value;
  // @@protoc_insertion_point(field_set:main.ActionCountResponse.himCount)
}

// -------------------------------------------------------------------

// FightSpirit

// optional int32 sid = 1;
inline bool FightSpirit::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightSpirit::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightSpirit::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightSpirit::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 FightSpirit::sid() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.sid)
  return sid_;
}
inline void FightSpirit::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.sid)
}

// optional int32 type = 2;
inline bool FightSpirit::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightSpirit::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightSpirit::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightSpirit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FightSpirit::type() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.type)
  return type_;
}
inline void FightSpirit::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.type)
}

// optional int32 color = 3;
inline bool FightSpirit::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightSpirit::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightSpirit::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightSpirit::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::google::protobuf::int32 FightSpirit::color() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.color)
  return color_;
}
inline void FightSpirit::set_color(::google::protobuf::int32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.color)
}

// optional int32 x = 4;
inline bool FightSpirit::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightSpirit::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightSpirit::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightSpirit::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 FightSpirit::x() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.x)
  return x_;
}
inline void FightSpirit::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.x)
}

// optional int32 y = 5;
inline bool FightSpirit::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightSpirit::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightSpirit::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightSpirit::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 FightSpirit::y() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.y)
  return y_;
}
inline void FightSpirit::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.y)
}

// optional int32 baseAttack = 6;
inline bool FightSpirit::has_baseattack() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightSpirit::set_has_baseattack() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightSpirit::clear_has_baseattack() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightSpirit::clear_baseattack() {
  baseattack_ = 0;
  clear_has_baseattack();
}
inline ::google::protobuf::int32 FightSpirit::baseattack() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.baseAttack)
  return baseattack_;
}
inline void FightSpirit::set_baseattack(::google::protobuf::int32 value) {
  set_has_baseattack();
  baseattack_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.baseAttack)
}

// optional int32 attack = 7;
inline bool FightSpirit::has_attack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FightSpirit::set_has_attack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FightSpirit::clear_has_attack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FightSpirit::clear_attack() {
  attack_ = 0;
  clear_has_attack();
}
inline ::google::protobuf::int32 FightSpirit::attack() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.attack)
  return attack_;
}
inline void FightSpirit::set_attack(::google::protobuf::int32 value) {
  set_has_attack();
  attack_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.attack)
}

// optional int32 baseDef = 8;
inline bool FightSpirit::has_basedef() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FightSpirit::set_has_basedef() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FightSpirit::clear_has_basedef() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FightSpirit::clear_basedef() {
  basedef_ = 0;
  clear_has_basedef();
}
inline ::google::protobuf::int32 FightSpirit::basedef() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.baseDef)
  return basedef_;
}
inline void FightSpirit::set_basedef(::google::protobuf::int32 value) {
  set_has_basedef();
  basedef_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.baseDef)
}

// optional int32 def = 9;
inline bool FightSpirit::has_def() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightSpirit::set_has_def() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightSpirit::clear_has_def() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightSpirit::clear_def() {
  def_ = 0;
  clear_has_def();
}
inline ::google::protobuf::int32 FightSpirit::def() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.def)
  return def_;
}
inline void FightSpirit::set_def(::google::protobuf::int32 value) {
  set_has_def();
  def_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.def)
}

// optional int32 round = 10;
inline bool FightSpirit::has_round() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FightSpirit::set_has_round() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FightSpirit::clear_has_round() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FightSpirit::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 FightSpirit::round() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.round)
  return round_;
}
inline void FightSpirit::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.round)
}

// optional float defeatPlus = 11;
inline bool FightSpirit::has_defeatplus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FightSpirit::set_has_defeatplus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FightSpirit::clear_has_defeatplus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FightSpirit::clear_defeatplus() {
  defeatplus_ = 0;
  clear_has_defeatplus();
}
inline float FightSpirit::defeatplus() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.defeatPlus)
  return defeatplus_;
}
inline void FightSpirit::set_defeatplus(float value) {
  set_has_defeatplus();
  defeatplus_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.defeatPlus)
}

// optional float chainAndMergeAttackPlus = 12;
inline bool FightSpirit::has_chainandmergeattackplus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FightSpirit::set_has_chainandmergeattackplus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FightSpirit::clear_has_chainandmergeattackplus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FightSpirit::clear_chainandmergeattackplus() {
  chainandmergeattackplus_ = 0;
  clear_has_chainandmergeattackplus();
}
inline float FightSpirit::chainandmergeattackplus() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.chainAndMergeAttackPlus)
  return chainandmergeattackplus_;
}
inline void FightSpirit::set_chainandmergeattackplus(float value) {
  set_has_chainandmergeattackplus();
  chainandmergeattackplus_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.chainAndMergeAttackPlus)
}

// optional float wallgrow = 13;
inline bool FightSpirit::has_wallgrow() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FightSpirit::set_has_wallgrow() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FightSpirit::clear_has_wallgrow() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FightSpirit::clear_wallgrow() {
  wallgrow_ = 0;
  clear_has_wallgrow();
}
inline float FightSpirit::wallgrow() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.wallgrow)
  return wallgrow_;
}
inline void FightSpirit::set_wallgrow(float value) {
  set_has_wallgrow();
  wallgrow_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.wallgrow)
}

// optional int32 skillId = 14;
inline bool FightSpirit::has_skillid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FightSpirit::set_has_skillid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FightSpirit::clear_has_skillid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FightSpirit::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 FightSpirit::skillid() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.skillId)
  return skillid_;
}
inline void FightSpirit::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.skillId)
}

// optional float value1 = 15;
inline bool FightSpirit::has_value1() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FightSpirit::set_has_value1() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FightSpirit::clear_has_value1() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FightSpirit::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline float FightSpirit::value1() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.value1)
  return value1_;
}
inline void FightSpirit::set_value1(float value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.value1)
}

// optional float value2 = 16;
inline bool FightSpirit::has_value2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FightSpirit::set_has_value2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FightSpirit::clear_has_value2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FightSpirit::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline float FightSpirit::value2() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.value2)
  return value2_;
}
inline void FightSpirit::set_value2(float value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.value2)
}

// optional float walltype = 17;
inline bool FightSpirit::has_walltype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FightSpirit::set_has_walltype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FightSpirit::clear_has_walltype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FightSpirit::clear_walltype() {
  walltype_ = 0;
  clear_has_walltype();
}
inline float FightSpirit::walltype() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.walltype)
  return walltype_;
}
inline void FightSpirit::set_walltype(float value) {
  set_has_walltype();
  walltype_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.walltype)
}

// optional float wallCeiling = 18;
inline bool FightSpirit::has_wallceiling() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FightSpirit::set_has_wallceiling() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FightSpirit::clear_has_wallceiling() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FightSpirit::clear_wallceiling() {
  wallceiling_ = 0;
  clear_has_wallceiling();
}
inline float FightSpirit::wallceiling() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.wallCeiling)
  return wallceiling_;
}
inline void FightSpirit::set_wallceiling(float value) {
  set_has_wallceiling();
  wallceiling_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.wallCeiling)
}

// optional int32 buffId = 19;
inline bool FightSpirit::has_buffid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FightSpirit::set_has_buffid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FightSpirit::clear_has_buffid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FightSpirit::clear_buffid() {
  buffid_ = 0;
  clear_has_buffid();
}
inline ::google::protobuf::int32 FightSpirit::buffid() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.buffId)
  return buffid_;
}
inline void FightSpirit::set_buffid(::google::protobuf::int32 value) {
  set_has_buffid();
  buffid_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.buffId)
}

// optional float bvalue1 = 20;
inline bool FightSpirit::has_bvalue1() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void FightSpirit::set_has_bvalue1() {
  _has_bits_[0] |= 0x00080000u;
}
inline void FightSpirit::clear_has_bvalue1() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void FightSpirit::clear_bvalue1() {
  bvalue1_ = 0;
  clear_has_bvalue1();
}
inline float FightSpirit::bvalue1() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.bvalue1)
  return bvalue1_;
}
inline void FightSpirit::set_bvalue1(float value) {
  set_has_bvalue1();
  bvalue1_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.bvalue1)
}

// optional int32 effectRound = 21;
inline bool FightSpirit::has_effectround() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void FightSpirit::set_has_effectround() {
  _has_bits_[0] |= 0x00100000u;
}
inline void FightSpirit::clear_has_effectround() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void FightSpirit::clear_effectround() {
  effectround_ = 0;
  clear_has_effectround();
}
inline ::google::protobuf::int32 FightSpirit::effectround() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.effectRound)
  return effectround_;
}
inline void FightSpirit::set_effectround(::google::protobuf::int32 value) {
  set_has_effectround();
  effectround_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.effectRound)
}

// optional int32 randNum = 22;
inline bool FightSpirit::has_randnum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void FightSpirit::set_has_randnum() {
  _has_bits_[0] |= 0x00200000u;
}
inline void FightSpirit::clear_has_randnum() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void FightSpirit::clear_randnum() {
  randnum_ = 0;
  clear_has_randnum();
}
inline ::google::protobuf::int32 FightSpirit::randnum() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.randNum)
  return randnum_;
}
inline void FightSpirit::set_randnum(::google::protobuf::int32 value) {
  set_has_randnum();
  randnum_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.randNum)
}

// optional int32 buffType = 23;
inline bool FightSpirit::has_bufftype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void FightSpirit::set_has_bufftype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void FightSpirit::clear_has_bufftype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void FightSpirit::clear_bufftype() {
  bufftype_ = 0;
  clear_has_bufftype();
}
inline ::google::protobuf::int32 FightSpirit::bufftype() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.buffType)
  return bufftype_;
}
inline void FightSpirit::set_bufftype(::google::protobuf::int32 value) {
  set_has_bufftype();
  bufftype_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.buffType)
}

// optional int32 effect = 24;
inline bool FightSpirit::has_effect() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void FightSpirit::set_has_effect() {
  _has_bits_[0] |= 0x00800000u;
}
inline void FightSpirit::clear_has_effect() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void FightSpirit::clear_effect() {
  effect_ = 0;
  clear_has_effect();
}
inline ::google::protobuf::int32 FightSpirit::effect() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.effect)
  return effect_;
}
inline void FightSpirit::set_effect(::google::protobuf::int32 value) {
  set_has_effect();
  effect_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.effect)
}

// optional int32 perRoundAddAtk = 25;
inline bool FightSpirit::has_perroundaddatk() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void FightSpirit::set_has_perroundaddatk() {
  _has_bits_[0] |= 0x01000000u;
}
inline void FightSpirit::clear_has_perroundaddatk() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void FightSpirit::clear_perroundaddatk() {
  perroundaddatk_ = 0;
  clear_has_perroundaddatk();
}
inline ::google::protobuf::int32 FightSpirit::perroundaddatk() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.perRoundAddAtk)
  return perroundaddatk_;
}
inline void FightSpirit::set_perroundaddatk(::google::protobuf::int32 value) {
  set_has_perroundaddatk();
  perroundaddatk_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.perRoundAddAtk)
}

// optional int32 atkModeSkill = 26;
inline bool FightSpirit::has_atkmodeskill() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void FightSpirit::set_has_atkmodeskill() {
  _has_bits_[0] |= 0x02000000u;
}
inline void FightSpirit::clear_has_atkmodeskill() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void FightSpirit::clear_atkmodeskill() {
  atkmodeskill_ = 0;
  clear_has_atkmodeskill();
}
inline ::google::protobuf::int32 FightSpirit::atkmodeskill() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.atkModeSkill)
  return atkmodeskill_;
}
inline void FightSpirit::set_atkmodeskill(::google::protobuf::int32 value) {
  set_has_atkmodeskill();
  atkmodeskill_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.atkModeSkill)
}

// optional bool defeat = 27;
inline bool FightSpirit::has_defeat() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void FightSpirit::set_has_defeat() {
  _has_bits_[0] |= 0x04000000u;
}
inline void FightSpirit::clear_has_defeat() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void FightSpirit::clear_defeat() {
  defeat_ = false;
  clear_has_defeat();
}
inline bool FightSpirit::defeat() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.defeat)
  return defeat_;
}
inline void FightSpirit::set_defeat(bool value) {
  set_has_defeat();
  defeat_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.defeat)
}

// optional int32 currentDef = 28;
inline bool FightSpirit::has_currentdef() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void FightSpirit::set_has_currentdef() {
  _has_bits_[0] |= 0x08000000u;
}
inline void FightSpirit::clear_has_currentdef() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void FightSpirit::clear_currentdef() {
  currentdef_ = 0;
  clear_has_currentdef();
}
inline ::google::protobuf::int32 FightSpirit::currentdef() const {
  // @@protoc_insertion_point(field_get:main.FightSpirit.currentDef)
  return currentdef_;
}
inline void FightSpirit::set_currentdef(::google::protobuf::int32 value) {
  set_has_currentdef();
  currentdef_ = value;
  // @@protoc_insertion_point(field_set:main.FightSpirit.currentDef)
}

// -------------------------------------------------------------------

// VerifyRequest

// repeated int32 check = 1;
inline int VerifyRequest::check_size() const {
  return check_.size();
}
inline void VerifyRequest::clear_check() {
  check_.Clear();
}
inline ::google::protobuf::int32 VerifyRequest::check(int index) const {
  // @@protoc_insertion_point(field_get:main.VerifyRequest.check)
  return check_.Get(index);
}
inline void VerifyRequest::set_check(int index, ::google::protobuf::int32 value) {
  check_.Set(index, value);
  // @@protoc_insertion_point(field_set:main.VerifyRequest.check)
}
inline void VerifyRequest::add_check(::google::protobuf::int32 value) {
  check_.Add(value);
  // @@protoc_insertion_point(field_add:main.VerifyRequest.check)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
VerifyRequest::check() const {
  // @@protoc_insertion_point(field_list:main.VerifyRequest.check)
  return check_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
VerifyRequest::mutable_check() {
  // @@protoc_insertion_point(field_mutable_list:main.VerifyRequest.check)
  return &check_;
}

// -------------------------------------------------------------------

// VerifyResponse

// optional int32 result = 1;
inline bool VerifyResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 VerifyResponse::result() const {
  // @@protoc_insertion_point(field_get:main.VerifyResponse.result)
  return result_;
}
inline void VerifyResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:main.VerifyResponse.result)
}

// -------------------------------------------------------------------

// MajorSkillRequest

// optional float value1 = 1;
inline bool MajorSkillRequest::has_value1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MajorSkillRequest::set_has_value1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MajorSkillRequest::clear_has_value1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MajorSkillRequest::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline float MajorSkillRequest::value1() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillRequest.value1)
  return value1_;
}
inline void MajorSkillRequest::set_value1(float value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillRequest.value1)
}

// optional float value2 = 2;
inline bool MajorSkillRequest::has_value2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MajorSkillRequest::set_has_value2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MajorSkillRequest::clear_has_value2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MajorSkillRequest::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline float MajorSkillRequest::value2() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillRequest.value2)
  return value2_;
}
inline void MajorSkillRequest::set_value2(float value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillRequest.value2)
}

// optional int32 test = 3;
inline bool MajorSkillRequest::has_test() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MajorSkillRequest::set_has_test() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MajorSkillRequest::clear_has_test() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MajorSkillRequest::clear_test() {
  test_ = 0;
  clear_has_test();
}
inline ::google::protobuf::int32 MajorSkillRequest::test() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillRequest.test)
  return test_;
}
inline void MajorSkillRequest::set_test(::google::protobuf::int32 value) {
  set_has_test();
  test_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillRequest.test)
}

// -------------------------------------------------------------------

// MajorSkillResponse

// optional .main.MajorSkillProto majorSkillProto = 1;
inline bool MajorSkillResponse::has_majorskillproto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MajorSkillResponse::set_has_majorskillproto() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MajorSkillResponse::clear_has_majorskillproto() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MajorSkillResponse::clear_majorskillproto() {
  if (majorskillproto_ != NULL) majorskillproto_->::main::MajorSkillProto::Clear();
  clear_has_majorskillproto();
}
inline const ::main::MajorSkillProto& MajorSkillResponse::majorskillproto() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillResponse.majorSkillProto)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return majorskillproto_ != NULL ? *majorskillproto_ : *default_instance().majorskillproto_;
#else
  return majorskillproto_ != NULL ? *majorskillproto_ : *default_instance_->majorskillproto_;
#endif
}
inline ::main::MajorSkillProto* MajorSkillResponse::mutable_majorskillproto() {
  set_has_majorskillproto();
  if (majorskillproto_ == NULL) majorskillproto_ = new ::main::MajorSkillProto;
  // @@protoc_insertion_point(field_mutable:main.MajorSkillResponse.majorSkillProto)
  return majorskillproto_;
}
inline ::main::MajorSkillProto* MajorSkillResponse::release_majorskillproto() {
  clear_has_majorskillproto();
  ::main::MajorSkillProto* temp = majorskillproto_;
  majorskillproto_ = NULL;
  return temp;
}
inline void MajorSkillResponse::set_allocated_majorskillproto(::main::MajorSkillProto* majorskillproto) {
  delete majorskillproto_;
  majorskillproto_ = majorskillproto;
  if (majorskillproto) {
    set_has_majorskillproto();
  } else {
    clear_has_majorskillproto();
  }
  // @@protoc_insertion_point(field_set_allocated:main.MajorSkillResponse.majorSkillProto)
}

// -------------------------------------------------------------------

// MajorSkillProto

// optional int32 state = 1;
inline bool MajorSkillProto::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MajorSkillProto::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MajorSkillProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MajorSkillProto::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MajorSkillProto::state() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.state)
  return state_;
}
inline void MajorSkillProto::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.state)
}

// optional int32 skillId = 2;
inline bool MajorSkillProto::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MajorSkillProto::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MajorSkillProto::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MajorSkillProto::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 MajorSkillProto::skillid() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.skillId)
  return skillid_;
}
inline void MajorSkillProto::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.skillId)
}

// optional float value1 = 3;
inline bool MajorSkillProto::has_value1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MajorSkillProto::set_has_value1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MajorSkillProto::clear_has_value1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MajorSkillProto::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline float MajorSkillProto::value1() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.value1)
  return value1_;
}
inline void MajorSkillProto::set_value1(float value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.value1)
}

// optional float value2 = 4;
inline bool MajorSkillProto::has_value2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MajorSkillProto::set_has_value2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MajorSkillProto::clear_has_value2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MajorSkillProto::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline float MajorSkillProto::value2() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.value2)
  return value2_;
}
inline void MajorSkillProto::set_value2(float value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.value2)
}

// optional int32 roleId = 5;
inline bool MajorSkillProto::has_roleid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MajorSkillProto::set_has_roleid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MajorSkillProto::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MajorSkillProto::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 MajorSkillProto::roleid() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.roleId)
  return roleid_;
}
inline void MajorSkillProto::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.roleId)
}

// repeated .main.CoordinateProto coordinateProtoList = 6;
inline int MajorSkillProto::coordinateprotolist_size() const {
  return coordinateprotolist_.size();
}
inline void MajorSkillProto::clear_coordinateprotolist() {
  coordinateprotolist_.Clear();
}
inline const ::main::CoordinateProto& MajorSkillProto::coordinateprotolist(int index) const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.coordinateProtoList)
  return coordinateprotolist_.Get(index);
}
inline ::main::CoordinateProto* MajorSkillProto::mutable_coordinateprotolist(int index) {
  // @@protoc_insertion_point(field_mutable:main.MajorSkillProto.coordinateProtoList)
  return coordinateprotolist_.Mutable(index);
}
inline ::main::CoordinateProto* MajorSkillProto::add_coordinateprotolist() {
  // @@protoc_insertion_point(field_add:main.MajorSkillProto.coordinateProtoList)
  return coordinateprotolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::CoordinateProto >&
MajorSkillProto::coordinateprotolist() const {
  // @@protoc_insertion_point(field_list:main.MajorSkillProto.coordinateProtoList)
  return coordinateprotolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::CoordinateProto >*
MajorSkillProto::mutable_coordinateprotolist() {
  // @@protoc_insertion_point(field_mutable_list:main.MajorSkillProto.coordinateProtoList)
  return &coordinateprotolist_;
}

// optional int32 buffId = 7;
inline bool MajorSkillProto::has_buffid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MajorSkillProto::set_has_buffid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MajorSkillProto::clear_has_buffid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MajorSkillProto::clear_buffid() {
  buffid_ = 0;
  clear_has_buffid();
}
inline ::google::protobuf::int32 MajorSkillProto::buffid() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.buffId)
  return buffid_;
}
inline void MajorSkillProto::set_buffid(::google::protobuf::int32 value) {
  set_has_buffid();
  buffid_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.buffId)
}

// optional int32 round = 8;
inline bool MajorSkillProto::has_round() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MajorSkillProto::set_has_round() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MajorSkillProto::clear_has_round() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MajorSkillProto::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 MajorSkillProto::round() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.round)
  return round_;
}
inline void MajorSkillProto::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.round)
}

// optional float value3 = 9;
inline bool MajorSkillProto::has_value3() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MajorSkillProto::set_has_value3() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MajorSkillProto::clear_has_value3() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MajorSkillProto::clear_value3() {
  value3_ = 0;
  clear_has_value3();
}
inline float MajorSkillProto::value3() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.value3)
  return value3_;
}
inline void MajorSkillProto::set_value3(float value) {
  set_has_value3();
  value3_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.value3)
}

// optional int32 lordAtkMode = 10;
inline bool MajorSkillProto::has_lordatkmode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MajorSkillProto::set_has_lordatkmode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MajorSkillProto::clear_has_lordatkmode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MajorSkillProto::clear_lordatkmode() {
  lordatkmode_ = 0;
  clear_has_lordatkmode();
}
inline ::google::protobuf::int32 MajorSkillProto::lordatkmode() const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.lordAtkMode)
  return lordatkmode_;
}
inline void MajorSkillProto::set_lordatkmode(::google::protobuf::int32 value) {
  set_has_lordatkmode();
  lordatkmode_ = value;
  // @@protoc_insertion_point(field_set:main.MajorSkillProto.lordAtkMode)
}

// repeated .main.CoordinateEffectProto coordinateEffectProto = 11;
inline int MajorSkillProto::coordinateeffectproto_size() const {
  return coordinateeffectproto_.size();
}
inline void MajorSkillProto::clear_coordinateeffectproto() {
  coordinateeffectproto_.Clear();
}
inline const ::main::CoordinateEffectProto& MajorSkillProto::coordinateeffectproto(int index) const {
  // @@protoc_insertion_point(field_get:main.MajorSkillProto.coordinateEffectProto)
  return coordinateeffectproto_.Get(index);
}
inline ::main::CoordinateEffectProto* MajorSkillProto::mutable_coordinateeffectproto(int index) {
  // @@protoc_insertion_point(field_mutable:main.MajorSkillProto.coordinateEffectProto)
  return coordinateeffectproto_.Mutable(index);
}
inline ::main::CoordinateEffectProto* MajorSkillProto::add_coordinateeffectproto() {
  // @@protoc_insertion_point(field_add:main.MajorSkillProto.coordinateEffectProto)
  return coordinateeffectproto_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::CoordinateEffectProto >&
MajorSkillProto::coordinateeffectproto() const {
  // @@protoc_insertion_point(field_list:main.MajorSkillProto.coordinateEffectProto)
  return coordinateeffectproto_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::CoordinateEffectProto >*
MajorSkillProto::mutable_coordinateeffectproto() {
  // @@protoc_insertion_point(field_mutable_list:main.MajorSkillProto.coordinateEffectProto)
  return &coordinateeffectproto_;
}

// -------------------------------------------------------------------

// CoordinateProto

// optional int32 x = 1;
inline bool CoordinateProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordinateProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordinateProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordinateProto::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 CoordinateProto::x() const {
  // @@protoc_insertion_point(field_get:main.CoordinateProto.x)
  return x_;
}
inline void CoordinateProto::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.CoordinateProto.x)
}

// optional int32 y = 2;
inline bool CoordinateProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordinateProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordinateProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordinateProto::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 CoordinateProto::y() const {
  // @@protoc_insertion_point(field_get:main.CoordinateProto.y)
  return y_;
}
inline void CoordinateProto::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.CoordinateProto.y)
}

// -------------------------------------------------------------------

// CoordinateEffectProto

// optional int32 x = 1;
inline bool CoordinateEffectProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordinateEffectProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordinateEffectProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordinateEffectProto::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 CoordinateEffectProto::x() const {
  // @@protoc_insertion_point(field_get:main.CoordinateEffectProto.x)
  return x_;
}
inline void CoordinateEffectProto::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.CoordinateEffectProto.x)
}

// optional int32 y = 2;
inline bool CoordinateEffectProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordinateEffectProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordinateEffectProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordinateEffectProto::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 CoordinateEffectProto::y() const {
  // @@protoc_insertion_point(field_get:main.CoordinateEffectProto.y)
  return y_;
}
inline void CoordinateEffectProto::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.CoordinateEffectProto.y)
}

// optional int32 hp = 3;
inline bool CoordinateEffectProto::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoordinateEffectProto::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoordinateEffectProto::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoordinateEffectProto::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 CoordinateEffectProto::hp() const {
  // @@protoc_insertion_point(field_get:main.CoordinateEffectProto.hp)
  return hp_;
}
inline void CoordinateEffectProto::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:main.CoordinateEffectProto.hp)
}

// -------------------------------------------------------------------

// FightThtoughRewardRequest

// required int64 fighprossId = 1;
inline bool FightThtoughRewardRequest::has_fighprossid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightThtoughRewardRequest::set_has_fighprossid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightThtoughRewardRequest::clear_has_fighprossid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightThtoughRewardRequest::clear_fighprossid() {
  fighprossid_ = GOOGLE_LONGLONG(0);
  clear_has_fighprossid();
}
inline ::google::protobuf::int64 FightThtoughRewardRequest::fighprossid() const {
  // @@protoc_insertion_point(field_get:main.FightThtoughRewardRequest.fighprossId)
  return fighprossid_;
}
inline void FightThtoughRewardRequest::set_fighprossid(::google::protobuf::int64 value) {
  set_has_fighprossid();
  fighprossid_ = value;
  // @@protoc_insertion_point(field_set:main.FightThtoughRewardRequest.fighprossId)
}

// required sint32 isWin = 2;
inline bool FightThtoughRewardRequest::has_iswin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightThtoughRewardRequest::set_has_iswin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightThtoughRewardRequest::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightThtoughRewardRequest::clear_iswin() {
  iswin_ = 0;
  clear_has_iswin();
}
inline ::google::protobuf::int32 FightThtoughRewardRequest::iswin() const {
  // @@protoc_insertion_point(field_get:main.FightThtoughRewardRequest.isWin)
  return iswin_;
}
inline void FightThtoughRewardRequest::set_iswin(::google::protobuf::int32 value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.FightThtoughRewardRequest.isWin)
}

// optional sint32 currHp = 3;
inline bool FightThtoughRewardRequest::has_currhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightThtoughRewardRequest::set_has_currhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightThtoughRewardRequest::clear_has_currhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightThtoughRewardRequest::clear_currhp() {
  currhp_ = 0;
  clear_has_currhp();
}
inline ::google::protobuf::int32 FightThtoughRewardRequest::currhp() const {
  // @@protoc_insertion_point(field_get:main.FightThtoughRewardRequest.currHp)
  return currhp_;
}
inline void FightThtoughRewardRequest::set_currhp(::google::protobuf::int32 value) {
  set_has_currhp();
  currhp_ = value;
  // @@protoc_insertion_point(field_set:main.FightThtoughRewardRequest.currHp)
}

// -------------------------------------------------------------------

// FightRewardRequest

// optional string fighprossId = 1;
inline bool FightRewardRequest::has_fighprossid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRewardRequest::set_has_fighprossid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRewardRequest::clear_has_fighprossid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRewardRequest::clear_fighprossid() {
  if (fighprossid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fighprossid_->clear();
  }
  clear_has_fighprossid();
}
inline const ::std::string& FightRewardRequest::fighprossid() const {
  // @@protoc_insertion_point(field_get:main.FightRewardRequest.fighprossId)
  return *fighprossid_;
}
inline void FightRewardRequest::set_fighprossid(const ::std::string& value) {
  set_has_fighprossid();
  if (fighprossid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fighprossid_ = new ::std::string;
  }
  fighprossid_->assign(value);
  // @@protoc_insertion_point(field_set:main.FightRewardRequest.fighprossId)
}
inline void FightRewardRequest::set_fighprossid(const char* value) {
  set_has_fighprossid();
  if (fighprossid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fighprossid_ = new ::std::string;
  }
  fighprossid_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.FightRewardRequest.fighprossId)
}
inline void FightRewardRequest::set_fighprossid(const char* value, size_t size) {
  set_has_fighprossid();
  if (fighprossid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fighprossid_ = new ::std::string;
  }
  fighprossid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.FightRewardRequest.fighprossId)
}
inline ::std::string* FightRewardRequest::mutable_fighprossid() {
  set_has_fighprossid();
  if (fighprossid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fighprossid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.FightRewardRequest.fighprossId)
  return fighprossid_;
}
inline ::std::string* FightRewardRequest::release_fighprossid() {
  clear_has_fighprossid();
  if (fighprossid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fighprossid_;
    fighprossid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FightRewardRequest::set_allocated_fighprossid(::std::string* fighprossid) {
  if (fighprossid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fighprossid_;
  }
  if (fighprossid) {
    set_has_fighprossid();
    fighprossid_ = fighprossid;
  } else {
    clear_has_fighprossid();
    fighprossid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardRequest.fighprossId)
}

// -------------------------------------------------------------------

// FightRewardResponse

// optional int32 state = 1;
inline bool FightRewardResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRewardResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRewardResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRewardResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FightRewardResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.state)
  return state_;
}
inline void FightRewardResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.state)
}

// optional int32 plotId = 2;
inline bool FightRewardResponse::has_plotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightRewardResponse::set_has_plotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightRewardResponse::clear_has_plotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightRewardResponse::clear_plotid() {
  plotid_ = 0;
  clear_has_plotid();
}
inline ::google::protobuf::int32 FightRewardResponse::plotid() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.plotId)
  return plotid_;
}
inline void FightRewardResponse::set_plotid(::google::protobuf::int32 value) {
  set_has_plotid();
  plotid_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.plotId)
}

// optional int32 rating = 3;
inline bool FightRewardResponse::has_rating() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightRewardResponse::set_has_rating() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightRewardResponse::clear_has_rating() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightRewardResponse::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline ::google::protobuf::int32 FightRewardResponse::rating() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.rating)
  return rating_;
}
inline void FightRewardResponse::set_rating(::google::protobuf::int32 value) {
  set_has_rating();
  rating_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.rating)
}

// optional int32 exp = 4;
inline bool FightRewardResponse::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightRewardResponse::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightRewardResponse::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightRewardResponse::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 FightRewardResponse::exp() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.exp)
  return exp_;
}
inline void FightRewardResponse::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.exp)
}

// optional int32 gold = 5;
inline bool FightRewardResponse::has_gold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightRewardResponse::set_has_gold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightRewardResponse::clear_has_gold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightRewardResponse::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 FightRewardResponse::gold() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.gold)
  return gold_;
}
inline void FightRewardResponse::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.gold)
}

// repeated .main.FightRewardDropItems dropItems = 6;
inline int FightRewardResponse::dropitems_size() const {
  return dropitems_.size();
}
inline void FightRewardResponse::clear_dropitems() {
  dropitems_.Clear();
}
inline const ::main::FightRewardDropItems& FightRewardResponse::dropitems(int index) const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.dropItems)
  return dropitems_.Get(index);
}
inline ::main::FightRewardDropItems* FightRewardResponse::mutable_dropitems(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightRewardResponse.dropItems)
  return dropitems_.Mutable(index);
}
inline ::main::FightRewardDropItems* FightRewardResponse::add_dropitems() {
  // @@protoc_insertion_point(field_add:main.FightRewardResponse.dropItems)
  return dropitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightRewardDropItems >&
FightRewardResponse::dropitems() const {
  // @@protoc_insertion_point(field_list:main.FightRewardResponse.dropItems)
  return dropitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightRewardDropItems >*
FightRewardResponse::mutable_dropitems() {
  // @@protoc_insertion_point(field_mutable_list:main.FightRewardResponse.dropItems)
  return &dropitems_;
}

// optional int32 isWin = 7;
inline bool FightRewardResponse::has_iswin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FightRewardResponse::set_has_iswin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FightRewardResponse::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FightRewardResponse::clear_iswin() {
  iswin_ = 0;
  clear_has_iswin();
}
inline ::google::protobuf::int32 FightRewardResponse::iswin() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.isWin)
  return iswin_;
}
inline void FightRewardResponse::set_iswin(::google::protobuf::int32 value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.isWin)
}

// optional float hpRate = 8;
inline bool FightRewardResponse::has_hprate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FightRewardResponse::set_has_hprate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FightRewardResponse::clear_has_hprate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FightRewardResponse::clear_hprate() {
  hprate_ = 0;
  clear_has_hprate();
}
inline float FightRewardResponse::hprate() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.hpRate)
  return hprate_;
}
inline void FightRewardResponse::set_hprate(float value) {
  set_has_hprate();
  hprate_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.hpRate)
}

// optional int32 coins = 9;
inline bool FightRewardResponse::has_coins() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightRewardResponse::set_has_coins() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightRewardResponse::clear_has_coins() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightRewardResponse::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 FightRewardResponse::coins() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.coins)
  return coins_;
}
inline void FightRewardResponse::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.coins)
}

// optional int32 meritorious = 10;
inline bool FightRewardResponse::has_meritorious() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FightRewardResponse::set_has_meritorious() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FightRewardResponse::clear_has_meritorious() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FightRewardResponse::clear_meritorious() {
  meritorious_ = 0;
  clear_has_meritorious();
}
inline ::google::protobuf::int32 FightRewardResponse::meritorious() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.meritorious)
  return meritorious_;
}
inline void FightRewardResponse::set_meritorious(::google::protobuf::int32 value) {
  set_has_meritorious();
  meritorious_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.meritorious)
}

// optional int32 lianDan = 11 [default = -1];
inline bool FightRewardResponse::has_liandan() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FightRewardResponse::set_has_liandan() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FightRewardResponse::clear_has_liandan() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FightRewardResponse::clear_liandan() {
  liandan_ = -1;
  clear_has_liandan();
}
inline ::google::protobuf::int32 FightRewardResponse::liandan() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.lianDan)
  return liandan_;
}
inline void FightRewardResponse::set_liandan(::google::protobuf::int32 value) {
  set_has_liandan();
  liandan_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.lianDan)
}

// optional int32 addExp = 12;
inline bool FightRewardResponse::has_addexp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FightRewardResponse::set_has_addexp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FightRewardResponse::clear_has_addexp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FightRewardResponse::clear_addexp() {
  addexp_ = 0;
  clear_has_addexp();
}
inline ::google::protobuf::int32 FightRewardResponse::addexp() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.addExp)
  return addexp_;
}
inline void FightRewardResponse::set_addexp(::google::protobuf::int32 value) {
  set_has_addexp();
  addexp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.addExp)
}

// optional int32 level = 13;
inline bool FightRewardResponse::has_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FightRewardResponse::set_has_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FightRewardResponse::clear_has_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FightRewardResponse::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 FightRewardResponse::level() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.level)
  return level_;
}
inline void FightRewardResponse::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.level)
}

// optional int32 isMaxLevel = 14 [default = 0];
inline bool FightRewardResponse::has_ismaxlevel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FightRewardResponse::set_has_ismaxlevel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FightRewardResponse::clear_has_ismaxlevel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FightRewardResponse::clear_ismaxlevel() {
  ismaxlevel_ = 0;
  clear_has_ismaxlevel();
}
inline ::google::protobuf::int32 FightRewardResponse::ismaxlevel() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.isMaxLevel)
  return ismaxlevel_;
}
inline void FightRewardResponse::set_ismaxlevel(::google::protobuf::int32 value) {
  set_has_ismaxlevel();
  ismaxlevel_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.isMaxLevel)
}

// optional sint32 baseHp = 15;
inline bool FightRewardResponse::has_basehp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FightRewardResponse::set_has_basehp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FightRewardResponse::clear_has_basehp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FightRewardResponse::clear_basehp() {
  basehp_ = 0;
  clear_has_basehp();
}
inline ::google::protobuf::int32 FightRewardResponse::basehp() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.baseHp)
  return basehp_;
}
inline void FightRewardResponse::set_basehp(::google::protobuf::int32 value) {
  set_has_basehp();
  basehp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.baseHp)
}

// optional sint32 currHp = 16;
inline bool FightRewardResponse::has_currhp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FightRewardResponse::set_has_currhp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FightRewardResponse::clear_has_currhp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FightRewardResponse::clear_currhp() {
  currhp_ = 0;
  clear_has_currhp();
}
inline ::google::protobuf::int32 FightRewardResponse::currhp() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.currHp)
  return currhp_;
}
inline void FightRewardResponse::set_currhp(::google::protobuf::int32 value) {
  set_has_currhp();
  currhp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.currHp)
}

// optional int32 oldLevel = 17;
inline bool FightRewardResponse::has_oldlevel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FightRewardResponse::set_has_oldlevel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FightRewardResponse::clear_has_oldlevel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FightRewardResponse::clear_oldlevel() {
  oldlevel_ = 0;
  clear_has_oldlevel();
}
inline ::google::protobuf::int32 FightRewardResponse::oldlevel() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.oldLevel)
  return oldlevel_;
}
inline void FightRewardResponse::set_oldlevel(::google::protobuf::int32 value) {
  set_has_oldlevel();
  oldlevel_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.oldLevel)
}

// optional int32 xiyu = 18 [default = -1];
inline bool FightRewardResponse::has_xiyu() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FightRewardResponse::set_has_xiyu() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FightRewardResponse::clear_has_xiyu() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FightRewardResponse::clear_xiyu() {
  xiyu_ = -1;
  clear_has_xiyu();
}
inline ::google::protobuf::int32 FightRewardResponse::xiyu() const {
  // @@protoc_insertion_point(field_get:main.FightRewardResponse.xiyu)
  return xiyu_;
}
inline void FightRewardResponse::set_xiyu(::google::protobuf::int32 value) {
  set_has_xiyu();
  xiyu_ = value;
  // @@protoc_insertion_point(field_set:main.FightRewardResponse.xiyu)
}

// -------------------------------------------------------------------

// FightRewardDropItems

// optional .main.OfficerCardItemProto officerCards = 1;
inline bool FightRewardDropItems::has_officercards() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRewardDropItems::set_has_officercards() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRewardDropItems::clear_has_officercards() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRewardDropItems::clear_officercards() {
  if (officercards_ != NULL) officercards_->::main::OfficerCardItemProto::Clear();
  clear_has_officercards();
}
inline const ::main::OfficerCardItemProto& FightRewardDropItems::officercards() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.officerCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return officercards_ != NULL ? *officercards_ : *default_instance().officercards_;
#else
  return officercards_ != NULL ? *officercards_ : *default_instance_->officercards_;
#endif
}
inline ::main::OfficerCardItemProto* FightRewardDropItems::mutable_officercards() {
  set_has_officercards();
  if (officercards_ == NULL) officercards_ = new ::main::OfficerCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.officerCards)
  return officercards_;
}
inline ::main::OfficerCardItemProto* FightRewardDropItems::release_officercards() {
  clear_has_officercards();
  ::main::OfficerCardItemProto* temp = officercards_;
  officercards_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_officercards(::main::OfficerCardItemProto* officercards) {
  delete officercards_;
  officercards_ = officercards;
  if (officercards) {
    set_has_officercards();
  } else {
    clear_has_officercards();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.officerCards)
}

// optional .main.EquipmentCardItemProto equipmentCards = 2;
inline bool FightRewardDropItems::has_equipmentcards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightRewardDropItems::set_has_equipmentcards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightRewardDropItems::clear_has_equipmentcards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightRewardDropItems::clear_equipmentcards() {
  if (equipmentcards_ != NULL) equipmentcards_->::main::EquipmentCardItemProto::Clear();
  clear_has_equipmentcards();
}
inline const ::main::EquipmentCardItemProto& FightRewardDropItems::equipmentcards() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.equipmentCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equipmentcards_ != NULL ? *equipmentcards_ : *default_instance().equipmentcards_;
#else
  return equipmentcards_ != NULL ? *equipmentcards_ : *default_instance_->equipmentcards_;
#endif
}
inline ::main::EquipmentCardItemProto* FightRewardDropItems::mutable_equipmentcards() {
  set_has_equipmentcards();
  if (equipmentcards_ == NULL) equipmentcards_ = new ::main::EquipmentCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.equipmentCards)
  return equipmentcards_;
}
inline ::main::EquipmentCardItemProto* FightRewardDropItems::release_equipmentcards() {
  clear_has_equipmentcards();
  ::main::EquipmentCardItemProto* temp = equipmentcards_;
  equipmentcards_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_equipmentcards(::main::EquipmentCardItemProto* equipmentcards) {
  delete equipmentcards_;
  equipmentcards_ = equipmentcards;
  if (equipmentcards) {
    set_has_equipmentcards();
  } else {
    clear_has_equipmentcards();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.equipmentCards)
}

// optional .main.PropsCardItemProto propsCards = 3;
inline bool FightRewardDropItems::has_propscards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightRewardDropItems::set_has_propscards() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightRewardDropItems::clear_has_propscards() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightRewardDropItems::clear_propscards() {
  if (propscards_ != NULL) propscards_->::main::PropsCardItemProto::Clear();
  clear_has_propscards();
}
inline const ::main::PropsCardItemProto& FightRewardDropItems::propscards() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.propsCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return propscards_ != NULL ? *propscards_ : *default_instance().propscards_;
#else
  return propscards_ != NULL ? *propscards_ : *default_instance_->propscards_;
#endif
}
inline ::main::PropsCardItemProto* FightRewardDropItems::mutable_propscards() {
  set_has_propscards();
  if (propscards_ == NULL) propscards_ = new ::main::PropsCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.propsCards)
  return propscards_;
}
inline ::main::PropsCardItemProto* FightRewardDropItems::release_propscards() {
  clear_has_propscards();
  ::main::PropsCardItemProto* temp = propscards_;
  propscards_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_propscards(::main::PropsCardItemProto* propscards) {
  delete propscards_;
  propscards_ = propscards;
  if (propscards) {
    set_has_propscards();
  } else {
    clear_has_propscards();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.propsCards)
}

// optional .main.OfficerFragmentCardItemProto fragmentCards = 4;
inline bool FightRewardDropItems::has_fragmentcards() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightRewardDropItems::set_has_fragmentcards() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightRewardDropItems::clear_has_fragmentcards() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightRewardDropItems::clear_fragmentcards() {
  if (fragmentcards_ != NULL) fragmentcards_->::main::OfficerFragmentCardItemProto::Clear();
  clear_has_fragmentcards();
}
inline const ::main::OfficerFragmentCardItemProto& FightRewardDropItems::fragmentcards() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.fragmentCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fragmentcards_ != NULL ? *fragmentcards_ : *default_instance().fragmentcards_;
#else
  return fragmentcards_ != NULL ? *fragmentcards_ : *default_instance_->fragmentcards_;
#endif
}
inline ::main::OfficerFragmentCardItemProto* FightRewardDropItems::mutable_fragmentcards() {
  set_has_fragmentcards();
  if (fragmentcards_ == NULL) fragmentcards_ = new ::main::OfficerFragmentCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.fragmentCards)
  return fragmentcards_;
}
inline ::main::OfficerFragmentCardItemProto* FightRewardDropItems::release_fragmentcards() {
  clear_has_fragmentcards();
  ::main::OfficerFragmentCardItemProto* temp = fragmentcards_;
  fragmentcards_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_fragmentcards(::main::OfficerFragmentCardItemProto* fragmentcards) {
  delete fragmentcards_;
  fragmentcards_ = fragmentcards;
  if (fragmentcards) {
    set_has_fragmentcards();
  } else {
    clear_has_fragmentcards();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.fragmentCards)
}

// optional .main.ConsumableCardItemProto consumableCards = 5;
inline bool FightRewardDropItems::has_consumablecards() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightRewardDropItems::set_has_consumablecards() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightRewardDropItems::clear_has_consumablecards() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightRewardDropItems::clear_consumablecards() {
  if (consumablecards_ != NULL) consumablecards_->::main::ConsumableCardItemProto::Clear();
  clear_has_consumablecards();
}
inline const ::main::ConsumableCardItemProto& FightRewardDropItems::consumablecards() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.consumableCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return consumablecards_ != NULL ? *consumablecards_ : *default_instance().consumablecards_;
#else
  return consumablecards_ != NULL ? *consumablecards_ : *default_instance_->consumablecards_;
#endif
}
inline ::main::ConsumableCardItemProto* FightRewardDropItems::mutable_consumablecards() {
  set_has_consumablecards();
  if (consumablecards_ == NULL) consumablecards_ = new ::main::ConsumableCardItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.consumableCards)
  return consumablecards_;
}
inline ::main::ConsumableCardItemProto* FightRewardDropItems::release_consumablecards() {
  clear_has_consumablecards();
  ::main::ConsumableCardItemProto* temp = consumablecards_;
  consumablecards_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_consumablecards(::main::ConsumableCardItemProto* consumablecards) {
  delete consumablecards_;
  consumablecards_ = consumablecards;
  if (consumablecards) {
    set_has_consumablecards();
  } else {
    clear_has_consumablecards();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.consumableCards)
}

// optional .main.MaterialItemProto materialItemProtos = 6;
inline bool FightRewardDropItems::has_materialitemprotos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightRewardDropItems::set_has_materialitemprotos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightRewardDropItems::clear_has_materialitemprotos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightRewardDropItems::clear_materialitemprotos() {
  if (materialitemprotos_ != NULL) materialitemprotos_->::main::MaterialItemProto::Clear();
  clear_has_materialitemprotos();
}
inline const ::main::MaterialItemProto& FightRewardDropItems::materialitemprotos() const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.materialItemProtos)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return materialitemprotos_ != NULL ? *materialitemprotos_ : *default_instance().materialitemprotos_;
#else
  return materialitemprotos_ != NULL ? *materialitemprotos_ : *default_instance_->materialitemprotos_;
#endif
}
inline ::main::MaterialItemProto* FightRewardDropItems::mutable_materialitemprotos() {
  set_has_materialitemprotos();
  if (materialitemprotos_ == NULL) materialitemprotos_ = new ::main::MaterialItemProto;
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.materialItemProtos)
  return materialitemprotos_;
}
inline ::main::MaterialItemProto* FightRewardDropItems::release_materialitemprotos() {
  clear_has_materialitemprotos();
  ::main::MaterialItemProto* temp = materialitemprotos_;
  materialitemprotos_ = NULL;
  return temp;
}
inline void FightRewardDropItems::set_allocated_materialitemprotos(::main::MaterialItemProto* materialitemprotos) {
  delete materialitemprotos_;
  materialitemprotos_ = materialitemprotos;
  if (materialitemprotos) {
    set_has_materialitemprotos();
  } else {
    clear_has_materialitemprotos();
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightRewardDropItems.materialItemProtos)
}

// repeated .main.ItemDataProto itemData = 7;
inline int FightRewardDropItems::itemdata_size() const {
  return itemdata_.size();
}
inline void FightRewardDropItems::clear_itemdata() {
  itemdata_.Clear();
}
inline const ::main::ItemDataProto& FightRewardDropItems::itemdata(int index) const {
  // @@protoc_insertion_point(field_get:main.FightRewardDropItems.itemData)
  return itemdata_.Get(index);
}
inline ::main::ItemDataProto* FightRewardDropItems::mutable_itemdata(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightRewardDropItems.itemData)
  return itemdata_.Mutable(index);
}
inline ::main::ItemDataProto* FightRewardDropItems::add_itemdata() {
  // @@protoc_insertion_point(field_add:main.FightRewardDropItems.itemData)
  return itemdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ItemDataProto >&
FightRewardDropItems::itemdata() const {
  // @@protoc_insertion_point(field_list:main.FightRewardDropItems.itemData)
  return itemdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ItemDataProto >*
FightRewardDropItems::mutable_itemdata() {
  // @@protoc_insertion_point(field_mutable_list:main.FightRewardDropItems.itemData)
  return &itemdata_;
}

// -------------------------------------------------------------------

// FightRunAwayRequest

// -------------------------------------------------------------------

// FightRunAwayResponse

// optional int32 state = 1;
inline bool FightRunAwayResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRunAwayResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRunAwayResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRunAwayResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FightRunAwayResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.state)
  return state_;
}
inline void FightRunAwayResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.state)
}

// optional int32 rating = 2;
inline bool FightRunAwayResponse::has_rating() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightRunAwayResponse::set_has_rating() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightRunAwayResponse::clear_has_rating() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightRunAwayResponse::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline ::google::protobuf::int32 FightRunAwayResponse::rating() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.rating)
  return rating_;
}
inline void FightRunAwayResponse::set_rating(::google::protobuf::int32 value) {
  set_has_rating();
  rating_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.rating)
}

// optional int32 exp = 3;
inline bool FightRunAwayResponse::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightRunAwayResponse::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightRunAwayResponse::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightRunAwayResponse::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 FightRunAwayResponse::exp() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.exp)
  return exp_;
}
inline void FightRunAwayResponse::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.exp)
}

// optional int32 gold = 4;
inline bool FightRunAwayResponse::has_gold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightRunAwayResponse::set_has_gold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightRunAwayResponse::clear_has_gold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightRunAwayResponse::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 FightRunAwayResponse::gold() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.gold)
  return gold_;
}
inline void FightRunAwayResponse::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.gold)
}

// optional float hpRate = 5;
inline bool FightRunAwayResponse::has_hprate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightRunAwayResponse::set_has_hprate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightRunAwayResponse::clear_has_hprate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightRunAwayResponse::clear_hprate() {
  hprate_ = 0;
  clear_has_hprate();
}
inline float FightRunAwayResponse::hprate() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.hpRate)
  return hprate_;
}
inline void FightRunAwayResponse::set_hprate(float value) {
  set_has_hprate();
  hprate_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.hpRate)
}

// optional int32 addExp = 6;
inline bool FightRunAwayResponse::has_addexp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightRunAwayResponse::set_has_addexp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightRunAwayResponse::clear_has_addexp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightRunAwayResponse::clear_addexp() {
  addexp_ = 0;
  clear_has_addexp();
}
inline ::google::protobuf::int32 FightRunAwayResponse::addexp() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.addExp)
  return addexp_;
}
inline void FightRunAwayResponse::set_addexp(::google::protobuf::int32 value) {
  set_has_addexp();
  addexp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.addExp)
}

// optional sint32 currHp = 7;
inline bool FightRunAwayResponse::has_currhp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FightRunAwayResponse::set_has_currhp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FightRunAwayResponse::clear_has_currhp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FightRunAwayResponse::clear_currhp() {
  currhp_ = 0;
  clear_has_currhp();
}
inline ::google::protobuf::int32 FightRunAwayResponse::currhp() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.currHp)
  return currhp_;
}
inline void FightRunAwayResponse::set_currhp(::google::protobuf::int32 value) {
  set_has_currhp();
  currhp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.currHp)
}

// optional sint32 bashHp = 8;
inline bool FightRunAwayResponse::has_bashhp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FightRunAwayResponse::set_has_bashhp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FightRunAwayResponse::clear_has_bashhp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FightRunAwayResponse::clear_bashhp() {
  bashhp_ = 0;
  clear_has_bashhp();
}
inline ::google::protobuf::int32 FightRunAwayResponse::bashhp() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.bashHp)
  return bashhp_;
}
inline void FightRunAwayResponse::set_bashhp(::google::protobuf::int32 value) {
  set_has_bashhp();
  bashhp_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.bashHp)
}

// optional int32 isRunAway = 9;
inline bool FightRunAwayResponse::has_isrunaway() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightRunAwayResponse::set_has_isrunaway() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightRunAwayResponse::clear_has_isrunaway() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightRunAwayResponse::clear_isrunaway() {
  isrunaway_ = 0;
  clear_has_isrunaway();
}
inline ::google::protobuf::int32 FightRunAwayResponse::isrunaway() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.isRunAway)
  return isrunaway_;
}
inline void FightRunAwayResponse::set_isrunaway(::google::protobuf::int32 value) {
  set_has_isrunaway();
  isrunaway_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.isRunAway)
}

// optional int32 round = 10;
inline bool FightRunAwayResponse::has_round() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FightRunAwayResponse::set_has_round() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FightRunAwayResponse::clear_has_round() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FightRunAwayResponse::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 FightRunAwayResponse::round() const {
  // @@protoc_insertion_point(field_get:main.FightRunAwayResponse.round)
  return round_;
}
inline void FightRunAwayResponse::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
  // @@protoc_insertion_point(field_set:main.FightRunAwayResponse.round)
}

// -------------------------------------------------------------------

// EnemyExitResponse

// optional int32 state = 1;
inline bool EnemyExitResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnemyExitResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnemyExitResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnemyExitResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 EnemyExitResponse::state() const {
  // @@protoc_insertion_point(field_get:main.EnemyExitResponse.state)
  return state_;
}
inline void EnemyExitResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.EnemyExitResponse.state)
}

// -------------------------------------------------------------------

// EnemyResumeResponse

// optional int32 state = 1;
inline bool EnemyResumeResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnemyResumeResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnemyResumeResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnemyResumeResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 EnemyResumeResponse::state() const {
  // @@protoc_insertion_point(field_get:main.EnemyResumeResponse.state)
  return state_;
}
inline void EnemyResumeResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.EnemyResumeResponse.state)
}

// -------------------------------------------------------------------

// FightLogRequest

// optional string str = 1;
inline bool FightLogRequest::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightLogRequest::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightLogRequest::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightLogRequest::clear_str() {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& FightLogRequest::str() const {
  // @@protoc_insertion_point(field_get:main.FightLogRequest.str)
  return *str_;
}
inline void FightLogRequest::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set:main.FightLogRequest.str)
}
inline void FightLogRequest::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.FightLogRequest.str)
}
inline void FightLogRequest::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.FightLogRequest.str)
}
inline ::std::string* FightLogRequest::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.FightLogRequest.str)
  return str_;
}
inline ::std::string* FightLogRequest::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FightLogRequest::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.FightLogRequest.str)
}

// -------------------------------------------------------------------

// FightReviveRequest

// optional int32 isRevive = 1;
inline bool FightReviveRequest::has_isrevive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightReviveRequest::set_has_isrevive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightReviveRequest::clear_has_isrevive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightReviveRequest::clear_isrevive() {
  isrevive_ = 0;
  clear_has_isrevive();
}
inline ::google::protobuf::int32 FightReviveRequest::isrevive() const {
  // @@protoc_insertion_point(field_get:main.FightReviveRequest.isRevive)
  return isrevive_;
}
inline void FightReviveRequest::set_isrevive(::google::protobuf::int32 value) {
  set_has_isrevive();
  isrevive_ = value;
  // @@protoc_insertion_point(field_set:main.FightReviveRequest.isRevive)
}

// -------------------------------------------------------------------

// FightReviveResponse

// optional int32 state = 1;
inline bool FightReviveResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightReviveResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightReviveResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightReviveResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FightReviveResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FightReviveResponse.state)
  return state_;
}
inline void FightReviveResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FightReviveResponse.state)
}

// -------------------------------------------------------------------

// FightFixMapRequest

// optional int32 roleId = 1;
inline bool FightFixMapRequest::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightFixMapRequest::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightFixMapRequest::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightFixMapRequest::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 FightFixMapRequest::roleid() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapRequest.roleId)
  return roleid_;
}
inline void FightFixMapRequest::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapRequest.roleId)
}

// -------------------------------------------------------------------

// FightFixMapResponse

// optional int32 roleId = 1;
inline bool FightFixMapResponse::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightFixMapResponse::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightFixMapResponse::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightFixMapResponse::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 FightFixMapResponse::roleid() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.roleId)
  return roleid_;
}
inline void FightFixMapResponse::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.roleId)
}

// optional int32 freeCount = 2;
inline bool FightFixMapResponse::has_freecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightFixMapResponse::set_has_freecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightFixMapResponse::clear_has_freecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightFixMapResponse::clear_freecount() {
  freecount_ = 0;
  clear_has_freecount();
}
inline ::google::protobuf::int32 FightFixMapResponse::freecount() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.freeCount)
  return freecount_;
}
inline void FightFixMapResponse::set_freecount(::google::protobuf::int32 value) {
  set_has_freecount();
  freecount_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.freeCount)
}

// optional int32 actionCount = 3;
inline bool FightFixMapResponse::has_actioncount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightFixMapResponse::set_has_actioncount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightFixMapResponse::clear_has_actioncount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightFixMapResponse::clear_actioncount() {
  actioncount_ = 0;
  clear_has_actioncount();
}
inline ::google::protobuf::int32 FightFixMapResponse::actioncount() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.actionCount)
  return actioncount_;
}
inline void FightFixMapResponse::set_actioncount(::google::protobuf::int32 value) {
  set_has_actioncount();
  actioncount_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.actionCount)
}

// optional int32 baseHp = 4;
inline bool FightFixMapResponse::has_basehp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightFixMapResponse::set_has_basehp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightFixMapResponse::clear_has_basehp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightFixMapResponse::clear_basehp() {
  basehp_ = 0;
  clear_has_basehp();
}
inline ::google::protobuf::int32 FightFixMapResponse::basehp() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.baseHp)
  return basehp_;
}
inline void FightFixMapResponse::set_basehp(::google::protobuf::int32 value) {
  set_has_basehp();
  basehp_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.baseHp)
}

// optional int32 hp = 5;
inline bool FightFixMapResponse::has_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightFixMapResponse::set_has_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightFixMapResponse::clear_has_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightFixMapResponse::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 FightFixMapResponse::hp() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.hp)
  return hp_;
}
inline void FightFixMapResponse::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.hp)
}

// optional int32 majorSkillCurrentRound = 6;
inline bool FightFixMapResponse::has_majorskillcurrentround() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightFixMapResponse::set_has_majorskillcurrentround() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightFixMapResponse::clear_has_majorskillcurrentround() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightFixMapResponse::clear_majorskillcurrentround() {
  majorskillcurrentround_ = 0;
  clear_has_majorskillcurrentround();
}
inline ::google::protobuf::int32 FightFixMapResponse::majorskillcurrentround() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.majorSkillCurrentRound)
  return majorskillcurrentround_;
}
inline void FightFixMapResponse::set_majorskillcurrentround(::google::protobuf::int32 value) {
  set_has_majorskillcurrentround();
  majorskillcurrentround_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.majorSkillCurrentRound)
}

// repeated .main.FightSpirit spirits = 7;
inline int FightFixMapResponse::spirits_size() const {
  return spirits_.size();
}
inline void FightFixMapResponse::clear_spirits() {
  spirits_.Clear();
}
inline const ::main::FightSpirit& FightFixMapResponse::spirits(int index) const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.spirits)
  return spirits_.Get(index);
}
inline ::main::FightSpirit* FightFixMapResponse::mutable_spirits(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightFixMapResponse.spirits)
  return spirits_.Mutable(index);
}
inline ::main::FightSpirit* FightFixMapResponse::add_spirits() {
  // @@protoc_insertion_point(field_add:main.FightFixMapResponse.spirits)
  return spirits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >&
FightFixMapResponse::spirits() const {
  // @@protoc_insertion_point(field_list:main.FightFixMapResponse.spirits)
  return spirits_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightSpirit >*
FightFixMapResponse::mutable_spirits() {
  // @@protoc_insertion_point(field_mutable_list:main.FightFixMapResponse.spirits)
  return &spirits_;
}

// repeated .main.FightFixAttackUnit attackList = 8;
inline int FightFixMapResponse::attacklist_size() const {
  return attacklist_.size();
}
inline void FightFixMapResponse::clear_attacklist() {
  attacklist_.Clear();
}
inline const ::main::FightFixAttackUnit& FightFixMapResponse::attacklist(int index) const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.attackList)
  return attacklist_.Get(index);
}
inline ::main::FightFixAttackUnit* FightFixMapResponse::mutable_attacklist(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightFixMapResponse.attackList)
  return attacklist_.Mutable(index);
}
inline ::main::FightFixAttackUnit* FightFixMapResponse::add_attacklist() {
  // @@protoc_insertion_point(field_add:main.FightFixMapResponse.attackList)
  return attacklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightFixAttackUnit >&
FightFixMapResponse::attacklist() const {
  // @@protoc_insertion_point(field_list:main.FightFixMapResponse.attackList)
  return attacklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightFixAttackUnit >*
FightFixMapResponse::mutable_attacklist() {
  // @@protoc_insertion_point(field_mutable_list:main.FightFixMapResponse.attackList)
  return &attacklist_;
}

// optional int32 cooRound = 9;
inline bool FightFixMapResponse::has_cooround() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightFixMapResponse::set_has_cooround() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightFixMapResponse::clear_has_cooround() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightFixMapResponse::clear_cooround() {
  cooround_ = 0;
  clear_has_cooround();
}
inline ::google::protobuf::int32 FightFixMapResponse::cooround() const {
  // @@protoc_insertion_point(field_get:main.FightFixMapResponse.cooRound)
  return cooround_;
}
inline void FightFixMapResponse::set_cooround(::google::protobuf::int32 value) {
  set_has_cooround();
  cooround_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixMapResponse.cooRound)
}

// -------------------------------------------------------------------

// FightFixAttackUnit

// optional int32 x = 1;
inline bool FightFixAttackUnit::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightFixAttackUnit::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightFixAttackUnit::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightFixAttackUnit::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 FightFixAttackUnit::x() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.x)
  return x_;
}
inline void FightFixAttackUnit::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.x)
}

// optional int32 y = 2;
inline bool FightFixAttackUnit::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightFixAttackUnit::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightFixAttackUnit::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightFixAttackUnit::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 FightFixAttackUnit::y() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.y)
  return y_;
}
inline void FightFixAttackUnit::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.y)
}

// optional int32 currentRound = 3;
inline bool FightFixAttackUnit::has_currentround() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightFixAttackUnit::set_has_currentround() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightFixAttackUnit::clear_has_currentround() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightFixAttackUnit::clear_currentround() {
  currentround_ = 0;
  clear_has_currentround();
}
inline ::google::protobuf::int32 FightFixAttackUnit::currentround() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.currentRound)
  return currentround_;
}
inline void FightFixAttackUnit::set_currentround(::google::protobuf::int32 value) {
  set_has_currentround();
  currentround_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.currentRound)
}

// optional int32 currentAttack = 4;
inline bool FightFixAttackUnit::has_currentattack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightFixAttackUnit::set_has_currentattack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightFixAttackUnit::clear_has_currentattack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightFixAttackUnit::clear_currentattack() {
  currentattack_ = 0;
  clear_has_currentattack();
}
inline ::google::protobuf::int32 FightFixAttackUnit::currentattack() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.currentAttack)
  return currentattack_;
}
inline void FightFixAttackUnit::set_currentattack(::google::protobuf::int32 value) {
  set_has_currentattack();
  currentattack_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.currentAttack)
}

// optional int32 currentChainCount = 5;
inline bool FightFixAttackUnit::has_currentchaincount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightFixAttackUnit::set_has_currentchaincount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightFixAttackUnit::clear_has_currentchaincount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightFixAttackUnit::clear_currentchaincount() {
  currentchaincount_ = 0;
  clear_has_currentchaincount();
}
inline ::google::protobuf::int32 FightFixAttackUnit::currentchaincount() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.currentChainCount)
  return currentchaincount_;
}
inline void FightFixAttackUnit::set_currentchaincount(::google::protobuf::int32 value) {
  set_has_currentchaincount();
  currentchaincount_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.currentChainCount)
}

// optional int32 currentMergeCount = 6;
inline bool FightFixAttackUnit::has_currentmergecount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightFixAttackUnit::set_has_currentmergecount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightFixAttackUnit::clear_has_currentmergecount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightFixAttackUnit::clear_currentmergecount() {
  currentmergecount_ = 0;
  clear_has_currentmergecount();
}
inline ::google::protobuf::int32 FightFixAttackUnit::currentmergecount() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.currentMergeCount)
  return currentmergecount_;
}
inline void FightFixAttackUnit::set_currentmergecount(::google::protobuf::int32 value) {
  set_has_currentmergecount();
  currentmergecount_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.currentMergeCount)
}

// repeated .main.FightFixBuff buffList = 7;
inline int FightFixAttackUnit::bufflist_size() const {
  return bufflist_.size();
}
inline void FightFixAttackUnit::clear_bufflist() {
  bufflist_.Clear();
}
inline const ::main::FightFixBuff& FightFixAttackUnit::bufflist(int index) const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.buffList)
  return bufflist_.Get(index);
}
inline ::main::FightFixBuff* FightFixAttackUnit::mutable_bufflist(int index) {
  // @@protoc_insertion_point(field_mutable:main.FightFixAttackUnit.buffList)
  return bufflist_.Mutable(index);
}
inline ::main::FightFixBuff* FightFixAttackUnit::add_bufflist() {
  // @@protoc_insertion_point(field_add:main.FightFixAttackUnit.buffList)
  return bufflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::FightFixBuff >&
FightFixAttackUnit::bufflist() const {
  // @@protoc_insertion_point(field_list:main.FightFixAttackUnit.buffList)
  return bufflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::FightFixBuff >*
FightFixAttackUnit::mutable_bufflist() {
  // @@protoc_insertion_point(field_mutable_list:main.FightFixAttackUnit.buffList)
  return &bufflist_;
}

// optional int32 acceptAmage = 8;
inline bool FightFixAttackUnit::has_acceptamage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FightFixAttackUnit::set_has_acceptamage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FightFixAttackUnit::clear_has_acceptamage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FightFixAttackUnit::clear_acceptamage() {
  acceptamage_ = 0;
  clear_has_acceptamage();
}
inline ::google::protobuf::int32 FightFixAttackUnit::acceptamage() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.acceptAmage)
  return acceptamage_;
}
inline void FightFixAttackUnit::set_acceptamage(::google::protobuf::int32 value) {
  set_has_acceptamage();
  acceptamage_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.acceptAmage)
}

// optional bool ishasFuhuo = 9;
inline bool FightFixAttackUnit::has_ishasfuhuo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightFixAttackUnit::set_has_ishasfuhuo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightFixAttackUnit::clear_has_ishasfuhuo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightFixAttackUnit::clear_ishasfuhuo() {
  ishasfuhuo_ = false;
  clear_has_ishasfuhuo();
}
inline bool FightFixAttackUnit::ishasfuhuo() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.ishasFuhuo)
  return ishasfuhuo_;
}
inline void FightFixAttackUnit::set_ishasfuhuo(bool value) {
  set_has_ishasfuhuo();
  ishasfuhuo_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.ishasFuhuo)
}

// optional bool isFuhuo = 10;
inline bool FightFixAttackUnit::has_isfuhuo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FightFixAttackUnit::set_has_isfuhuo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FightFixAttackUnit::clear_has_isfuhuo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FightFixAttackUnit::clear_isfuhuo() {
  isfuhuo_ = false;
  clear_has_isfuhuo();
}
inline bool FightFixAttackUnit::isfuhuo() const {
  // @@protoc_insertion_point(field_get:main.FightFixAttackUnit.isFuhuo)
  return isfuhuo_;
}
inline void FightFixAttackUnit::set_isfuhuo(bool value) {
  set_has_isfuhuo();
  isfuhuo_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixAttackUnit.isFuhuo)
}

// -------------------------------------------------------------------

// FightFixBuff

// optional int32 buffId = 1;
inline bool FightFixBuff::has_buffid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightFixBuff::set_has_buffid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightFixBuff::clear_has_buffid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightFixBuff::clear_buffid() {
  buffid_ = 0;
  clear_has_buffid();
}
inline ::google::protobuf::int32 FightFixBuff::buffid() const {
  // @@protoc_insertion_point(field_get:main.FightFixBuff.buffId)
  return buffid_;
}
inline void FightFixBuff::set_buffid(::google::protobuf::int32 value) {
  set_has_buffid();
  buffid_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixBuff.buffId)
}

// optional int32 buffType = 2;
inline bool FightFixBuff::has_bufftype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightFixBuff::set_has_bufftype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightFixBuff::clear_has_bufftype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightFixBuff::clear_bufftype() {
  bufftype_ = 0;
  clear_has_bufftype();
}
inline ::google::protobuf::int32 FightFixBuff::bufftype() const {
  // @@protoc_insertion_point(field_get:main.FightFixBuff.buffType)
  return bufftype_;
}
inline void FightFixBuff::set_bufftype(::google::protobuf::int32 value) {
  set_has_bufftype();
  bufftype_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixBuff.buffType)
}

// optional int32 buffRound = 3;
inline bool FightFixBuff::has_buffround() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightFixBuff::set_has_buffround() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightFixBuff::clear_has_buffround() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightFixBuff::clear_buffround() {
  buffround_ = 0;
  clear_has_buffround();
}
inline ::google::protobuf::int32 FightFixBuff::buffround() const {
  // @@protoc_insertion_point(field_get:main.FightFixBuff.buffRound)
  return buffround_;
}
inline void FightFixBuff::set_buffround(::google::protobuf::int32 value) {
  set_has_buffround();
  buffround_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixBuff.buffRound)
}

// optional float buffRoundValue = 4;
inline bool FightFixBuff::has_buffroundvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightFixBuff::set_has_buffroundvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightFixBuff::clear_has_buffroundvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightFixBuff::clear_buffroundvalue() {
  buffroundvalue_ = 0;
  clear_has_buffroundvalue();
}
inline float FightFixBuff::buffroundvalue() const {
  // @@protoc_insertion_point(field_get:main.FightFixBuff.buffRoundValue)
  return buffroundvalue_;
}
inline void FightFixBuff::set_buffroundvalue(float value) {
  set_has_buffroundvalue();
  buffroundvalue_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixBuff.buffRoundValue)
}

// optional int32 buffEffect = 5;
inline bool FightFixBuff::has_buffeffect() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightFixBuff::set_has_buffeffect() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightFixBuff::clear_has_buffeffect() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightFixBuff::clear_buffeffect() {
  buffeffect_ = 0;
  clear_has_buffeffect();
}
inline ::google::protobuf::int32 FightFixBuff::buffeffect() const {
  // @@protoc_insertion_point(field_get:main.FightFixBuff.buffEffect)
  return buffeffect_;
}
inline void FightFixBuff::set_buffeffect(::google::protobuf::int32 value) {
  set_has_buffeffect();
  buffeffect_ = value;
  // @@protoc_insertion_point(field_set:main.FightFixBuff.buffEffect)
}

// -------------------------------------------------------------------

// EnterBossRequest

// -------------------------------------------------------------------

// EnterBossResponse

// optional int32 bossHp = 1;
inline bool EnterBossResponse::has_bosshp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterBossResponse::set_has_bosshp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterBossResponse::clear_has_bosshp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterBossResponse::clear_bosshp() {
  bosshp_ = 0;
  clear_has_bosshp();
}
inline ::google::protobuf::int32 EnterBossResponse::bosshp() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.bossHp)
  return bosshp_;
}
inline void EnterBossResponse::set_bosshp(::google::protobuf::int32 value) {
  set_has_bosshp();
  bosshp_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.bossHp)
}

// optional int32 bossBaseHp = 2;
inline bool EnterBossResponse::has_bossbasehp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterBossResponse::set_has_bossbasehp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterBossResponse::clear_has_bossbasehp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterBossResponse::clear_bossbasehp() {
  bossbasehp_ = 0;
  clear_has_bossbasehp();
}
inline ::google::protobuf::int32 EnterBossResponse::bossbasehp() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.bossBaseHp)
  return bossbasehp_;
}
inline void EnterBossResponse::set_bossbasehp(::google::protobuf::int32 value) {
  set_has_bossbasehp();
  bossbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.bossBaseHp)
}

// optional int32 bossDamageCount = 3;
inline bool EnterBossResponse::has_bossdamagecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterBossResponse::set_has_bossdamagecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterBossResponse::clear_has_bossdamagecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterBossResponse::clear_bossdamagecount() {
  bossdamagecount_ = 0;
  clear_has_bossdamagecount();
}
inline ::google::protobuf::int32 EnterBossResponse::bossdamagecount() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.bossDamageCount)
  return bossdamagecount_;
}
inline void EnterBossResponse::set_bossdamagecount(::google::protobuf::int32 value) {
  set_has_bossdamagecount();
  bossdamagecount_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.bossDamageCount)
}

// repeated .main.BossBuffModel bossBuffModel = 4;
inline int EnterBossResponse::bossbuffmodel_size() const {
  return bossbuffmodel_.size();
}
inline void EnterBossResponse::clear_bossbuffmodel() {
  bossbuffmodel_.Clear();
}
inline const ::main::BossBuffModel& EnterBossResponse::bossbuffmodel(int index) const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.bossBuffModel)
  return bossbuffmodel_.Get(index);
}
inline ::main::BossBuffModel* EnterBossResponse::mutable_bossbuffmodel(int index) {
  // @@protoc_insertion_point(field_mutable:main.EnterBossResponse.bossBuffModel)
  return bossbuffmodel_.Mutable(index);
}
inline ::main::BossBuffModel* EnterBossResponse::add_bossbuffmodel() {
  // @@protoc_insertion_point(field_add:main.EnterBossResponse.bossBuffModel)
  return bossbuffmodel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::BossBuffModel >&
EnterBossResponse::bossbuffmodel() const {
  // @@protoc_insertion_point(field_list:main.EnterBossResponse.bossBuffModel)
  return bossbuffmodel_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::BossBuffModel >*
EnterBossResponse::mutable_bossbuffmodel() {
  // @@protoc_insertion_point(field_mutable_list:main.EnterBossResponse.bossBuffModel)
  return &bossbuffmodel_;
}

// repeated .main.BossRankModel bossRankModel = 5;
inline int EnterBossResponse::bossrankmodel_size() const {
  return bossrankmodel_.size();
}
inline void EnterBossResponse::clear_bossrankmodel() {
  bossrankmodel_.Clear();
}
inline const ::main::BossRankModel& EnterBossResponse::bossrankmodel(int index) const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.bossRankModel)
  return bossrankmodel_.Get(index);
}
inline ::main::BossRankModel* EnterBossResponse::mutable_bossrankmodel(int index) {
  // @@protoc_insertion_point(field_mutable:main.EnterBossResponse.bossRankModel)
  return bossrankmodel_.Mutable(index);
}
inline ::main::BossRankModel* EnterBossResponse::add_bossrankmodel() {
  // @@protoc_insertion_point(field_add:main.EnterBossResponse.bossRankModel)
  return bossrankmodel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >&
EnterBossResponse::bossrankmodel() const {
  // @@protoc_insertion_point(field_list:main.EnterBossResponse.bossRankModel)
  return bossrankmodel_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >*
EnterBossResponse::mutable_bossrankmodel() {
  // @@protoc_insertion_point(field_mutable_list:main.EnterBossResponse.bossRankModel)
  return &bossrankmodel_;
}

// optional bool state = 6;
inline bool EnterBossResponse::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnterBossResponse::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnterBossResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnterBossResponse::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool EnterBossResponse::state() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.state)
  return state_;
}
inline void EnterBossResponse::set_state(bool value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.state)
}

// optional string errMsg = 7;
inline bool EnterBossResponse::has_errmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnterBossResponse::set_has_errmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnterBossResponse::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnterBossResponse::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& EnterBossResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.errMsg)
  return *errmsg_;
}
inline void EnterBossResponse::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.errMsg)
}
inline void EnterBossResponse::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.EnterBossResponse.errMsg)
}
inline void EnterBossResponse::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.EnterBossResponse.errMsg)
}
inline ::std::string* EnterBossResponse::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.EnterBossResponse.errMsg)
  return errmsg_;
}
inline ::std::string* EnterBossResponse::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterBossResponse::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.EnterBossResponse.errMsg)
}

// optional int32 time = 8;
inline bool EnterBossResponse::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnterBossResponse::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnterBossResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnterBossResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 EnterBossResponse::time() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.time)
  return time_;
}
inline void EnterBossResponse::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.time)
}

// optional int32 value1 = 9;
inline bool EnterBossResponse::has_value1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EnterBossResponse::set_has_value1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EnterBossResponse::clear_has_value1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EnterBossResponse::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline ::google::protobuf::int32 EnterBossResponse::value1() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.value1)
  return value1_;
}
inline void EnterBossResponse::set_value1(::google::protobuf::int32 value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.value1)
}

// optional float value2 = 10;
inline bool EnterBossResponse::has_value2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EnterBossResponse::set_has_value2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EnterBossResponse::clear_has_value2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EnterBossResponse::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline float EnterBossResponse::value2() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.value2)
  return value2_;
}
inline void EnterBossResponse::set_value2(float value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.value2)
}

// optional int32 value3 = 11;
inline bool EnterBossResponse::has_value3() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EnterBossResponse::set_has_value3() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EnterBossResponse::clear_has_value3() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EnterBossResponse::clear_value3() {
  value3_ = 0;
  clear_has_value3();
}
inline ::google::protobuf::int32 EnterBossResponse::value3() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.value3)
  return value3_;
}
inline void EnterBossResponse::set_value3(::google::protobuf::int32 value) {
  set_has_value3();
  value3_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.value3)
}

// optional sint32 damage = 12;
inline bool EnterBossResponse::has_damage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EnterBossResponse::set_has_damage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EnterBossResponse::clear_has_damage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EnterBossResponse::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 EnterBossResponse::damage() const {
  // @@protoc_insertion_point(field_get:main.EnterBossResponse.damage)
  return damage_;
}
inline void EnterBossResponse::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:main.EnterBossResponse.damage)
}

// -------------------------------------------------------------------

// BossBuffModel

// optional int32 buffId = 1;
inline bool BossBuffModel::has_buffid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BossBuffModel::set_has_buffid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BossBuffModel::clear_has_buffid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BossBuffModel::clear_buffid() {
  buffid_ = 0;
  clear_has_buffid();
}
inline ::google::protobuf::int32 BossBuffModel::buffid() const {
  // @@protoc_insertion_point(field_get:main.BossBuffModel.buffId)
  return buffid_;
}
inline void BossBuffModel::set_buffid(::google::protobuf::int32 value) {
  set_has_buffid();
  buffid_ = value;
  // @@protoc_insertion_point(field_set:main.BossBuffModel.buffId)
}

// optional string buffName = 3;
inline bool BossBuffModel::has_buffname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BossBuffModel::set_has_buffname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BossBuffModel::clear_has_buffname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BossBuffModel::clear_buffname() {
  if (buffname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffname_->clear();
  }
  clear_has_buffname();
}
inline const ::std::string& BossBuffModel::buffname() const {
  // @@protoc_insertion_point(field_get:main.BossBuffModel.buffName)
  return *buffname_;
}
inline void BossBuffModel::set_buffname(const ::std::string& value) {
  set_has_buffname();
  if (buffname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffname_ = new ::std::string;
  }
  buffname_->assign(value);
  // @@protoc_insertion_point(field_set:main.BossBuffModel.buffName)
}
inline void BossBuffModel::set_buffname(const char* value) {
  set_has_buffname();
  if (buffname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffname_ = new ::std::string;
  }
  buffname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BossBuffModel.buffName)
}
inline void BossBuffModel::set_buffname(const char* value, size_t size) {
  set_has_buffname();
  if (buffname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffname_ = new ::std::string;
  }
  buffname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BossBuffModel.buffName)
}
inline ::std::string* BossBuffModel::mutable_buffname() {
  set_has_buffname();
  if (buffname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BossBuffModel.buffName)
  return buffname_;
}
inline ::std::string* BossBuffModel::release_buffname() {
  clear_has_buffname();
  if (buffname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buffname_;
    buffname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BossBuffModel::set_allocated_buffname(::std::string* buffname) {
  if (buffname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buffname_;
  }
  if (buffname) {
    set_has_buffname();
    buffname_ = buffname;
  } else {
    clear_has_buffname();
    buffname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BossBuffModel.buffName)
}

// optional int32 buffGold = 4;
inline bool BossBuffModel::has_buffgold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BossBuffModel::set_has_buffgold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BossBuffModel::clear_has_buffgold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BossBuffModel::clear_buffgold() {
  buffgold_ = 0;
  clear_has_buffgold();
}
inline ::google::protobuf::int32 BossBuffModel::buffgold() const {
  // @@protoc_insertion_point(field_get:main.BossBuffModel.buffGold)
  return buffgold_;
}
inline void BossBuffModel::set_buffgold(::google::protobuf::int32 value) {
  set_has_buffgold();
  buffgold_ = value;
  // @@protoc_insertion_point(field_set:main.BossBuffModel.buffGold)
}

// optional int32 buffBasValue = 5;
inline bool BossBuffModel::has_buffbasvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BossBuffModel::set_has_buffbasvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BossBuffModel::clear_has_buffbasvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BossBuffModel::clear_buffbasvalue() {
  buffbasvalue_ = 0;
  clear_has_buffbasvalue();
}
inline ::google::protobuf::int32 BossBuffModel::buffbasvalue() const {
  // @@protoc_insertion_point(field_get:main.BossBuffModel.buffBasValue)
  return buffbasvalue_;
}
inline void BossBuffModel::set_buffbasvalue(::google::protobuf::int32 value) {
  set_has_buffbasvalue();
  buffbasvalue_ = value;
  // @@protoc_insertion_point(field_set:main.BossBuffModel.buffBasValue)
}

// -------------------------------------------------------------------

// BossRankModel

// optional int32 roleId = 1;
inline bool BossRankModel::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BossRankModel::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BossRankModel::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BossRankModel::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 BossRankModel::roleid() const {
  // @@protoc_insertion_point(field_get:main.BossRankModel.roleId)
  return roleid_;
}
inline void BossRankModel::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankModel.roleId)
}

// optional string roleName = 2;
inline bool BossRankModel::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BossRankModel::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BossRankModel::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BossRankModel::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& BossRankModel::rolename() const {
  // @@protoc_insertion_point(field_get:main.BossRankModel.roleName)
  return *rolename_;
}
inline void BossRankModel::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
  // @@protoc_insertion_point(field_set:main.BossRankModel.roleName)
}
inline void BossRankModel::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BossRankModel.roleName)
}
inline void BossRankModel::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BossRankModel.roleName)
}
inline ::std::string* BossRankModel::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BossRankModel.roleName)
  return rolename_;
}
inline ::std::string* BossRankModel::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BossRankModel::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BossRankModel.roleName)
}

// optional int32 level = 3;
inline bool BossRankModel::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BossRankModel::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BossRankModel::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BossRankModel::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BossRankModel::level() const {
  // @@protoc_insertion_point(field_get:main.BossRankModel.level)
  return level_;
}
inline void BossRankModel::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankModel.level)
}

// optional int32 damage = 4;
inline bool BossRankModel::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BossRankModel::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BossRankModel::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BossRankModel::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 BossRankModel::damage() const {
  // @@protoc_insertion_point(field_get:main.BossRankModel.damage)
  return damage_;
}
inline void BossRankModel::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankModel.damage)
}

// -------------------------------------------------------------------

// AtkBossRequest

// -------------------------------------------------------------------

// AtkBossResponse

// optional int32 bossItemId = 1;
inline bool AtkBossResponse::has_bossitemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AtkBossResponse::set_has_bossitemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AtkBossResponse::clear_has_bossitemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AtkBossResponse::clear_bossitemid() {
  bossitemid_ = 0;
  clear_has_bossitemid();
}
inline ::google::protobuf::int32 AtkBossResponse::bossitemid() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.bossItemId)
  return bossitemid_;
}
inline void AtkBossResponse::set_bossitemid(::google::protobuf::int32 value) {
  set_has_bossitemid();
  bossitemid_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.bossItemId)
}

// optional int32 bossHp = 2;
inline bool AtkBossResponse::has_bosshp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AtkBossResponse::set_has_bosshp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AtkBossResponse::clear_has_bosshp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AtkBossResponse::clear_bosshp() {
  bosshp_ = 0;
  clear_has_bosshp();
}
inline ::google::protobuf::int32 AtkBossResponse::bosshp() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.bossHp)
  return bosshp_;
}
inline void AtkBossResponse::set_bosshp(::google::protobuf::int32 value) {
  set_has_bosshp();
  bosshp_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.bossHp)
}

// optional int32 bossBaseHp = 3;
inline bool AtkBossResponse::has_bossbasehp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AtkBossResponse::set_has_bossbasehp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AtkBossResponse::clear_has_bossbasehp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AtkBossResponse::clear_bossbasehp() {
  bossbasehp_ = 0;
  clear_has_bossbasehp();
}
inline ::google::protobuf::int32 AtkBossResponse::bossbasehp() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.bossBaseHp)
  return bossbasehp_;
}
inline void AtkBossResponse::set_bossbasehp(::google::protobuf::int32 value) {
  set_has_bossbasehp();
  bossbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.bossBaseHp)
}

// optional int32 roleItemId = 4;
inline bool AtkBossResponse::has_roleitemid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AtkBossResponse::set_has_roleitemid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AtkBossResponse::clear_has_roleitemid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AtkBossResponse::clear_roleitemid() {
  roleitemid_ = 0;
  clear_has_roleitemid();
}
inline ::google::protobuf::int32 AtkBossResponse::roleitemid() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.roleItemId)
  return roleitemid_;
}
inline void AtkBossResponse::set_roleitemid(::google::protobuf::int32 value) {
  set_has_roleitemid();
  roleitemid_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.roleItemId)
}

// optional sint32 lordType = 8;
inline bool AtkBossResponse::has_lordtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AtkBossResponse::set_has_lordtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AtkBossResponse::clear_has_lordtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AtkBossResponse::clear_lordtype() {
  lordtype_ = 0;
  clear_has_lordtype();
}
inline ::google::protobuf::int32 AtkBossResponse::lordtype() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.lordType)
  return lordtype_;
}
inline void AtkBossResponse::set_lordtype(::google::protobuf::int32 value) {
  set_has_lordtype();
  lordtype_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.lordType)
}

// optional int32 roledamage = 5;
inline bool AtkBossResponse::has_roledamage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AtkBossResponse::set_has_roledamage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AtkBossResponse::clear_has_roledamage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AtkBossResponse::clear_roledamage() {
  roledamage_ = 0;
  clear_has_roledamage();
}
inline ::google::protobuf::int32 AtkBossResponse::roledamage() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.roledamage)
  return roledamage_;
}
inline void AtkBossResponse::set_roledamage(::google::protobuf::int32 value) {
  set_has_roledamage();
  roledamage_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.roledamage)
}

// optional bool state = 6;
inline bool AtkBossResponse::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AtkBossResponse::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AtkBossResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AtkBossResponse::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool AtkBossResponse::state() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.state)
  return state_;
}
inline void AtkBossResponse::set_state(bool value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.state)
}

// optional string errMsg = 7;
inline bool AtkBossResponse::has_errmsg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AtkBossResponse::set_has_errmsg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AtkBossResponse::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AtkBossResponse::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AtkBossResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.errMsg)
  return *errmsg_;
}
inline void AtkBossResponse::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.errMsg)
}
inline void AtkBossResponse::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AtkBossResponse.errMsg)
}
inline void AtkBossResponse::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AtkBossResponse.errMsg)
}
inline ::std::string* AtkBossResponse::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AtkBossResponse.errMsg)
  return errmsg_;
}
inline ::std::string* AtkBossResponse::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AtkBossResponse::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AtkBossResponse.errMsg)
}

// optional bool isCrit = 9;
inline bool AtkBossResponse::has_iscrit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AtkBossResponse::set_has_iscrit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AtkBossResponse::clear_has_iscrit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AtkBossResponse::clear_iscrit() {
  iscrit_ = false;
  clear_has_iscrit();
}
inline bool AtkBossResponse::iscrit() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.isCrit)
  return iscrit_;
}
inline void AtkBossResponse::set_iscrit(bool value) {
  set_has_iscrit();
  iscrit_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.isCrit)
}

// optional sint32 coins = 10;
inline bool AtkBossResponse::has_coins() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AtkBossResponse::set_has_coins() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AtkBossResponse::clear_has_coins() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AtkBossResponse::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 AtkBossResponse::coins() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.coins)
  return coins_;
}
inline void AtkBossResponse::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.coins)
}

// optional sint32 medal = 11;
inline bool AtkBossResponse::has_medal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AtkBossResponse::set_has_medal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AtkBossResponse::clear_has_medal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AtkBossResponse::clear_medal() {
  medal_ = 0;
  clear_has_medal();
}
inline ::google::protobuf::int32 AtkBossResponse::medal() const {
  // @@protoc_insertion_point(field_get:main.AtkBossResponse.medal)
  return medal_;
}
inline void AtkBossResponse::set_medal(::google::protobuf::int32 value) {
  set_has_medal();
  medal_ = value;
  // @@protoc_insertion_point(field_set:main.AtkBossResponse.medal)
}

// -------------------------------------------------------------------

// BossCurrStateRequest

// -------------------------------------------------------------------

// BossCurrStateResponse

// optional int32 bossHp = 1;
inline bool BossCurrStateResponse::has_bosshp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BossCurrStateResponse::set_has_bosshp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BossCurrStateResponse::clear_has_bosshp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BossCurrStateResponse::clear_bosshp() {
  bosshp_ = 0;
  clear_has_bosshp();
}
inline ::google::protobuf::int32 BossCurrStateResponse::bosshp() const {
  // @@protoc_insertion_point(field_get:main.BossCurrStateResponse.bossHp)
  return bosshp_;
}
inline void BossCurrStateResponse::set_bosshp(::google::protobuf::int32 value) {
  set_has_bosshp();
  bosshp_ = value;
  // @@protoc_insertion_point(field_set:main.BossCurrStateResponse.bossHp)
}

// optional int32 bossBaseHp = 2;
inline bool BossCurrStateResponse::has_bossbasehp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BossCurrStateResponse::set_has_bossbasehp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BossCurrStateResponse::clear_has_bossbasehp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BossCurrStateResponse::clear_bossbasehp() {
  bossbasehp_ = 0;
  clear_has_bossbasehp();
}
inline ::google::protobuf::int32 BossCurrStateResponse::bossbasehp() const {
  // @@protoc_insertion_point(field_get:main.BossCurrStateResponse.bossBaseHp)
  return bossbasehp_;
}
inline void BossCurrStateResponse::set_bossbasehp(::google::protobuf::int32 value) {
  set_has_bossbasehp();
  bossbasehp_ = value;
  // @@protoc_insertion_point(field_set:main.BossCurrStateResponse.bossBaseHp)
}

// repeated .main.BossRankModel bossRankModel = 3;
inline int BossCurrStateResponse::bossrankmodel_size() const {
  return bossrankmodel_.size();
}
inline void BossCurrStateResponse::clear_bossrankmodel() {
  bossrankmodel_.Clear();
}
inline const ::main::BossRankModel& BossCurrStateResponse::bossrankmodel(int index) const {
  // @@protoc_insertion_point(field_get:main.BossCurrStateResponse.bossRankModel)
  return bossrankmodel_.Get(index);
}
inline ::main::BossRankModel* BossCurrStateResponse::mutable_bossrankmodel(int index) {
  // @@protoc_insertion_point(field_mutable:main.BossCurrStateResponse.bossRankModel)
  return bossrankmodel_.Mutable(index);
}
inline ::main::BossRankModel* BossCurrStateResponse::add_bossrankmodel() {
  // @@protoc_insertion_point(field_add:main.BossCurrStateResponse.bossRankModel)
  return bossrankmodel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >&
BossCurrStateResponse::bossrankmodel() const {
  // @@protoc_insertion_point(field_list:main.BossCurrStateResponse.bossRankModel)
  return bossrankmodel_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::BossRankModel >*
BossCurrStateResponse::mutable_bossrankmodel() {
  // @@protoc_insertion_point(field_mutable_list:main.BossCurrStateResponse.bossRankModel)
  return &bossrankmodel_;
}

// -------------------------------------------------------------------

// MainBossRequest

// -------------------------------------------------------------------

// MainBossResponse

// required sint32 state = 1;
inline bool MainBossResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MainBossResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MainBossResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MainBossResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MainBossResponse::state() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.state)
  return state_;
}
inline void MainBossResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.MainBossResponse.state)
}

// optional sint32 bossLevel = 2;
inline bool MainBossResponse::has_bosslevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MainBossResponse::set_has_bosslevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MainBossResponse::clear_has_bosslevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MainBossResponse::clear_bosslevel() {
  bosslevel_ = 0;
  clear_has_bosslevel();
}
inline ::google::protobuf::int32 MainBossResponse::bosslevel() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.bossLevel)
  return bosslevel_;
}
inline void MainBossResponse::set_bosslevel(::google::protobuf::int32 value) {
  set_has_bosslevel();
  bosslevel_ = value;
  // @@protoc_insertion_point(field_set:main.MainBossResponse.bossLevel)
}

// optional sint64 residueTime = 3;
inline bool MainBossResponse::has_residuetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MainBossResponse::set_has_residuetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MainBossResponse::clear_has_residuetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MainBossResponse::clear_residuetime() {
  residuetime_ = GOOGLE_LONGLONG(0);
  clear_has_residuetime();
}
inline ::google::protobuf::int64 MainBossResponse::residuetime() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.residueTime)
  return residuetime_;
}
inline void MainBossResponse::set_residuetime(::google::protobuf::int64 value) {
  set_has_residuetime();
  residuetime_ = value;
  // @@protoc_insertion_point(field_set:main.MainBossResponse.residueTime)
}

// optional string theFirstThree = 4;
inline bool MainBossResponse::has_thefirstthree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MainBossResponse::set_has_thefirstthree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MainBossResponse::clear_has_thefirstthree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MainBossResponse::clear_thefirstthree() {
  if (thefirstthree_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thefirstthree_->clear();
  }
  clear_has_thefirstthree();
}
inline const ::std::string& MainBossResponse::thefirstthree() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.theFirstThree)
  return *thefirstthree_;
}
inline void MainBossResponse::set_thefirstthree(const ::std::string& value) {
  set_has_thefirstthree();
  if (thefirstthree_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thefirstthree_ = new ::std::string;
  }
  thefirstthree_->assign(value);
  // @@protoc_insertion_point(field_set:main.MainBossResponse.theFirstThree)
}
inline void MainBossResponse::set_thefirstthree(const char* value) {
  set_has_thefirstthree();
  if (thefirstthree_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thefirstthree_ = new ::std::string;
  }
  thefirstthree_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.MainBossResponse.theFirstThree)
}
inline void MainBossResponse::set_thefirstthree(const char* value, size_t size) {
  set_has_thefirstthree();
  if (thefirstthree_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thefirstthree_ = new ::std::string;
  }
  thefirstthree_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.MainBossResponse.theFirstThree)
}
inline ::std::string* MainBossResponse::mutable_thefirstthree() {
  set_has_thefirstthree();
  if (thefirstthree_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thefirstthree_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.MainBossResponse.theFirstThree)
  return thefirstthree_;
}
inline ::std::string* MainBossResponse::release_thefirstthree() {
  clear_has_thefirstthree();
  if (thefirstthree_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thefirstthree_;
    thefirstthree_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MainBossResponse::set_allocated_thefirstthree(::std::string* thefirstthree) {
  if (thefirstthree_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thefirstthree_;
  }
  if (thefirstthree) {
    set_has_thefirstthree();
    thefirstthree_ = thefirstthree;
  } else {
    clear_has_thefirstthree();
    thefirstthree_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.MainBossResponse.theFirstThree)
}

// optional string slayInfo = 5;
inline bool MainBossResponse::has_slayinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MainBossResponse::set_has_slayinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MainBossResponse::clear_has_slayinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MainBossResponse::clear_slayinfo() {
  if (slayinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slayinfo_->clear();
  }
  clear_has_slayinfo();
}
inline const ::std::string& MainBossResponse::slayinfo() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.slayInfo)
  return *slayinfo_;
}
inline void MainBossResponse::set_slayinfo(const ::std::string& value) {
  set_has_slayinfo();
  if (slayinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slayinfo_ = new ::std::string;
  }
  slayinfo_->assign(value);
  // @@protoc_insertion_point(field_set:main.MainBossResponse.slayInfo)
}
inline void MainBossResponse::set_slayinfo(const char* value) {
  set_has_slayinfo();
  if (slayinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slayinfo_ = new ::std::string;
  }
  slayinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.MainBossResponse.slayInfo)
}
inline void MainBossResponse::set_slayinfo(const char* value, size_t size) {
  set_has_slayinfo();
  if (slayinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slayinfo_ = new ::std::string;
  }
  slayinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.MainBossResponse.slayInfo)
}
inline ::std::string* MainBossResponse::mutable_slayinfo() {
  set_has_slayinfo();
  if (slayinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slayinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.MainBossResponse.slayInfo)
  return slayinfo_;
}
inline ::std::string* MainBossResponse::release_slayinfo() {
  clear_has_slayinfo();
  if (slayinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slayinfo_;
    slayinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MainBossResponse::set_allocated_slayinfo(::std::string* slayinfo) {
  if (slayinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slayinfo_;
  }
  if (slayinfo) {
    set_has_slayinfo();
    slayinfo_ = slayinfo;
  } else {
    clear_has_slayinfo();
    slayinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.MainBossResponse.slayInfo)
}

// optional sint32 startedTime = 6;
inline bool MainBossResponse::has_startedtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MainBossResponse::set_has_startedtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MainBossResponse::clear_has_startedtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MainBossResponse::clear_startedtime() {
  startedtime_ = 0;
  clear_has_startedtime();
}
inline ::google::protobuf::int32 MainBossResponse::startedtime() const {
  // @@protoc_insertion_point(field_get:main.MainBossResponse.startedTime)
  return startedtime_;
}
inline void MainBossResponse::set_startedtime(::google::protobuf::int32 value) {
  set_has_startedtime();
  startedtime_ = value;
  // @@protoc_insertion_point(field_set:main.MainBossResponse.startedTime)
}

// -------------------------------------------------------------------

// BossDamageRankRequest

// -------------------------------------------------------------------

// BossDamageRankResponse

// repeated .main.BossRankInfo bossRankInfo = 1;
inline int BossDamageRankResponse::bossrankinfo_size() const {
  return bossrankinfo_.size();
}
inline void BossDamageRankResponse::clear_bossrankinfo() {
  bossrankinfo_.Clear();
}
inline const ::main::BossRankInfo& BossDamageRankResponse::bossrankinfo(int index) const {
  // @@protoc_insertion_point(field_get:main.BossDamageRankResponse.bossRankInfo)
  return bossrankinfo_.Get(index);
}
inline ::main::BossRankInfo* BossDamageRankResponse::mutable_bossrankinfo(int index) {
  // @@protoc_insertion_point(field_mutable:main.BossDamageRankResponse.bossRankInfo)
  return bossrankinfo_.Mutable(index);
}
inline ::main::BossRankInfo* BossDamageRankResponse::add_bossrankinfo() {
  // @@protoc_insertion_point(field_add:main.BossDamageRankResponse.bossRankInfo)
  return bossrankinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::BossRankInfo >&
BossDamageRankResponse::bossrankinfo() const {
  // @@protoc_insertion_point(field_list:main.BossDamageRankResponse.bossRankInfo)
  return bossrankinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::BossRankInfo >*
BossDamageRankResponse::mutable_bossrankinfo() {
  // @@protoc_insertion_point(field_mutable_list:main.BossDamageRankResponse.bossRankInfo)
  return &bossrankinfo_;
}

// optional sint32 minute = 2;
inline bool BossDamageRankResponse::has_minute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BossDamageRankResponse::set_has_minute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BossDamageRankResponse::clear_has_minute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BossDamageRankResponse::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 BossDamageRankResponse::minute() const {
  // @@protoc_insertion_point(field_get:main.BossDamageRankResponse.minute)
  return minute_;
}
inline void BossDamageRankResponse::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:main.BossDamageRankResponse.minute)
}

// optional string playerName = 3;
inline bool BossDamageRankResponse::has_playername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BossDamageRankResponse::set_has_playername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BossDamageRankResponse::clear_has_playername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BossDamageRankResponse::clear_playername() {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& BossDamageRankResponse::playername() const {
  // @@protoc_insertion_point(field_get:main.BossDamageRankResponse.playerName)
  return *playername_;
}
inline void BossDamageRankResponse::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set:main.BossDamageRankResponse.playerName)
}
inline void BossDamageRankResponse::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BossDamageRankResponse.playerName)
}
inline void BossDamageRankResponse::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BossDamageRankResponse.playerName)
}
inline ::std::string* BossDamageRankResponse::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BossDamageRankResponse.playerName)
  return playername_;
}
inline ::std::string* BossDamageRankResponse::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BossDamageRankResponse::set_allocated_playername(::std::string* playername) {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BossDamageRankResponse.playerName)
}

// optional sint64 damage = 4;
inline bool BossDamageRankResponse::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BossDamageRankResponse::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BossDamageRankResponse::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BossDamageRankResponse::clear_damage() {
  damage_ = GOOGLE_LONGLONG(0);
  clear_has_damage();
}
inline ::google::protobuf::int64 BossDamageRankResponse::damage() const {
  // @@protoc_insertion_point(field_get:main.BossDamageRankResponse.damage)
  return damage_;
}
inline void BossDamageRankResponse::set_damage(::google::protobuf::int64 value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:main.BossDamageRankResponse.damage)
}

// optional sint32 selfDamage = 5;
inline bool BossDamageRankResponse::has_selfdamage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BossDamageRankResponse::set_has_selfdamage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BossDamageRankResponse::clear_has_selfdamage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BossDamageRankResponse::clear_selfdamage() {
  selfdamage_ = 0;
  clear_has_selfdamage();
}
inline ::google::protobuf::int32 BossDamageRankResponse::selfdamage() const {
  // @@protoc_insertion_point(field_get:main.BossDamageRankResponse.selfDamage)
  return selfdamage_;
}
inline void BossDamageRankResponse::set_selfdamage(::google::protobuf::int32 value) {
  set_has_selfdamage();
  selfdamage_ = value;
  // @@protoc_insertion_point(field_set:main.BossDamageRankResponse.selfDamage)
}

// -------------------------------------------------------------------

// BossRankInfo

// optional sint32 roleId = 1;
inline bool BossRankInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BossRankInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BossRankInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BossRankInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 BossRankInfo::roleid() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.roleId)
  return roleid_;
}
inline void BossRankInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.roleId)
}

// optional string roleName = 2;
inline bool BossRankInfo::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BossRankInfo::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BossRankInfo::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BossRankInfo::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& BossRankInfo::rolename() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.roleName)
  return *rolename_;
}
inline void BossRankInfo::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
  // @@protoc_insertion_point(field_set:main.BossRankInfo.roleName)
}
inline void BossRankInfo::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BossRankInfo.roleName)
}
inline void BossRankInfo::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BossRankInfo.roleName)
}
inline ::std::string* BossRankInfo::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rolename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BossRankInfo.roleName)
  return rolename_;
}
inline ::std::string* BossRankInfo::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BossRankInfo::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BossRankInfo.roleName)
}

// optional sint32 level = 3;
inline bool BossRankInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BossRankInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BossRankInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BossRankInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BossRankInfo::level() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.level)
  return level_;
}
inline void BossRankInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.level)
}

// optional sint32 icon = 4;
inline bool BossRankInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BossRankInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BossRankInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BossRankInfo::clear_icon() {
  icon_ = 0;
  clear_has_icon();
}
inline ::google::protobuf::int32 BossRankInfo::icon() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.icon)
  return icon_;
}
inline void BossRankInfo::set_icon(::google::protobuf::int32 value) {
  set_has_icon();
  icon_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.icon)
}

// optional sint32 country = 5;
inline bool BossRankInfo::has_country() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BossRankInfo::set_has_country() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BossRankInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BossRankInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 BossRankInfo::country() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.country)
  return country_;
}
inline void BossRankInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.country)
}

// optional sint32 damage = 6;
inline bool BossRankInfo::has_damage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BossRankInfo::set_has_damage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BossRankInfo::clear_has_damage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BossRankInfo::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 BossRankInfo::damage() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.damage)
  return damage_;
}
inline void BossRankInfo::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.damage)
}

// optional sint32 rankIndex = 7;
inline bool BossRankInfo::has_rankindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BossRankInfo::set_has_rankindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BossRankInfo::clear_has_rankindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BossRankInfo::clear_rankindex() {
  rankindex_ = 0;
  clear_has_rankindex();
}
inline ::google::protobuf::int32 BossRankInfo::rankindex() const {
  // @@protoc_insertion_point(field_get:main.BossRankInfo.rankIndex)
  return rankindex_;
}
inline void BossRankInfo::set_rankindex(::google::protobuf::int32 value) {
  set_has_rankindex();
  rankindex_ = value;
  // @@protoc_insertion_point(field_set:main.BossRankInfo.rankIndex)
}

// -------------------------------------------------------------------

// GetBossBuffRequest

// optional sint32 key = 1;
inline bool GetBossBuffRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBossBuffRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBossBuffRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBossBuffRequest::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 GetBossBuffRequest::key() const {
  // @@protoc_insertion_point(field_get:main.GetBossBuffRequest.key)
  return key_;
}
inline void GetBossBuffRequest::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:main.GetBossBuffRequest.key)
}

// -------------------------------------------------------------------

// GetBossBuffResponse

// optional sint32 state = 1;
inline bool GetBossBuffResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBossBuffResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBossBuffResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBossBuffResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 GetBossBuffResponse::state() const {
  // @@protoc_insertion_point(field_get:main.GetBossBuffResponse.state)
  return state_;
}
inline void GetBossBuffResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.GetBossBuffResponse.state)
}

// optional sint32 value1 = 2;
inline bool GetBossBuffResponse::has_value1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBossBuffResponse::set_has_value1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBossBuffResponse::clear_has_value1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBossBuffResponse::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline ::google::protobuf::int32 GetBossBuffResponse::value1() const {
  // @@protoc_insertion_point(field_get:main.GetBossBuffResponse.value1)
  return value1_;
}
inline void GetBossBuffResponse::set_value1(::google::protobuf::int32 value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:main.GetBossBuffResponse.value1)
}

// optional float value2 = 3;
inline bool GetBossBuffResponse::has_value2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBossBuffResponse::set_has_value2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBossBuffResponse::clear_has_value2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBossBuffResponse::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline float GetBossBuffResponse::value2() const {
  // @@protoc_insertion_point(field_get:main.GetBossBuffResponse.value2)
  return value2_;
}
inline void GetBossBuffResponse::set_value2(float value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:main.GetBossBuffResponse.value2)
}

// optional sint32 value3 = 4;
inline bool GetBossBuffResponse::has_value3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetBossBuffResponse::set_has_value3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetBossBuffResponse::clear_has_value3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetBossBuffResponse::clear_value3() {
  value3_ = 0;
  clear_has_value3();
}
inline ::google::protobuf::int32 GetBossBuffResponse::value3() const {
  // @@protoc_insertion_point(field_get:main.GetBossBuffResponse.value3)
  return value3_;
}
inline void GetBossBuffResponse::set_value3(::google::protobuf::int32 value) {
  set_has_value3();
  value3_ = value;
  // @@protoc_insertion_point(field_set:main.GetBossBuffResponse.value3)
}

// -------------------------------------------------------------------

// BossEndRewardResponse

// optional string rewardString = 1;
inline bool BossEndRewardResponse::has_rewardstring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BossEndRewardResponse::set_has_rewardstring() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BossEndRewardResponse::clear_has_rewardstring() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BossEndRewardResponse::clear_rewardstring() {
  if (rewardstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rewardstring_->clear();
  }
  clear_has_rewardstring();
}
inline const ::std::string& BossEndRewardResponse::rewardstring() const {
  // @@protoc_insertion_point(field_get:main.BossEndRewardResponse.rewardString)
  return *rewardstring_;
}
inline void BossEndRewardResponse::set_rewardstring(const ::std::string& value) {
  set_has_rewardstring();
  if (rewardstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rewardstring_ = new ::std::string;
  }
  rewardstring_->assign(value);
  // @@protoc_insertion_point(field_set:main.BossEndRewardResponse.rewardString)
}
inline void BossEndRewardResponse::set_rewardstring(const char* value) {
  set_has_rewardstring();
  if (rewardstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rewardstring_ = new ::std::string;
  }
  rewardstring_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.BossEndRewardResponse.rewardString)
}
inline void BossEndRewardResponse::set_rewardstring(const char* value, size_t size) {
  set_has_rewardstring();
  if (rewardstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rewardstring_ = new ::std::string;
  }
  rewardstring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.BossEndRewardResponse.rewardString)
}
inline ::std::string* BossEndRewardResponse::mutable_rewardstring() {
  set_has_rewardstring();
  if (rewardstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rewardstring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.BossEndRewardResponse.rewardString)
  return rewardstring_;
}
inline ::std::string* BossEndRewardResponse::release_rewardstring() {
  clear_has_rewardstring();
  if (rewardstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rewardstring_;
    rewardstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BossEndRewardResponse::set_allocated_rewardstring(::std::string* rewardstring) {
  if (rewardstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rewardstring_;
  }
  if (rewardstring) {
    set_has_rewardstring();
    rewardstring_ = rewardstring;
  } else {
    clear_has_rewardstring();
    rewardstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.BossEndRewardResponse.rewardString)
}

// -------------------------------------------------------------------

// FightPvpRewardRequest

// required sint64 fightId = 1;
inline bool FightPvpRewardRequest::has_fightid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightPvpRewardRequest::set_has_fightid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightPvpRewardRequest::clear_has_fightid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightPvpRewardRequest::clear_fightid() {
  fightid_ = GOOGLE_LONGLONG(0);
  clear_has_fightid();
}
inline ::google::protobuf::int64 FightPvpRewardRequest::fightid() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardRequest.fightId)
  return fightid_;
}
inline void FightPvpRewardRequest::set_fightid(::google::protobuf::int64 value) {
  set_has_fightid();
  fightid_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardRequest.fightId)
}

// -------------------------------------------------------------------

// FightPvpRewardResponse

// required sint32 state = 1;
inline bool FightPvpRewardResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightPvpRewardResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightPvpRewardResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightPvpRewardResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FightPvpRewardResponse::state() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.state)
  return state_;
}
inline void FightPvpRewardResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.state)
}

// optional bool isWin = 2;
inline bool FightPvpRewardResponse::has_iswin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightPvpRewardResponse::set_has_iswin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightPvpRewardResponse::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightPvpRewardResponse::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool FightPvpRewardResponse::iswin() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.isWin)
  return iswin_;
}
inline void FightPvpRewardResponse::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.isWin)
}

// optional sint32 prestige = 3;
inline bool FightPvpRewardResponse::has_prestige() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightPvpRewardResponse::set_has_prestige() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightPvpRewardResponse::clear_has_prestige() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightPvpRewardResponse::clear_prestige() {
  prestige_ = 0;
  clear_has_prestige();
}
inline ::google::protobuf::int32 FightPvpRewardResponse::prestige() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.prestige)
  return prestige_;
}
inline void FightPvpRewardResponse::set_prestige(::google::protobuf::int32 value) {
  set_has_prestige();
  prestige_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.prestige)
}

// optional sint32 score = 4;
inline bool FightPvpRewardResponse::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightPvpRewardResponse::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightPvpRewardResponse::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightPvpRewardResponse::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 FightPvpRewardResponse::score() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.score)
  return score_;
}
inline void FightPvpRewardResponse::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.score)
}

// optional sint32 rank = 5;
inline bool FightPvpRewardResponse::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightPvpRewardResponse::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightPvpRewardResponse::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightPvpRewardResponse::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 FightPvpRewardResponse::rank() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.rank)
  return rank_;
}
inline void FightPvpRewardResponse::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.rank)
}

// optional sint32 count = 6;
inline bool FightPvpRewardResponse::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightPvpRewardResponse::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightPvpRewardResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightPvpRewardResponse::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 FightPvpRewardResponse::count() const {
  // @@protoc_insertion_point(field_get:main.FightPvpRewardResponse.count)
  return count_;
}
inline void FightPvpRewardResponse::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:main.FightPvpRewardResponse.count)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FightBaseModule_2eproto__INCLUDED

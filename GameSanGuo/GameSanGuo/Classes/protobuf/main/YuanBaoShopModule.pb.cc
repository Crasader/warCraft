// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: YuanBaoShopModule.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "YuanBaoShopModule.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace main {

void protobuf_ShutdownFile_YuanBaoShopModule_2eproto() {
  delete ShopEntryRequest::default_instance_;
  delete ShopEntryResponse::default_instance_;
  delete GoodsInfo::default_instance_;
  delete GoodsItemInfo::default_instance_;
  delete GoodsBuyRequest::default_instance_;
  delete GoodsBuyResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_YuanBaoShopModule_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_YuanBaoShopModule_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ShopEntryRequest::default_instance_ = new ShopEntryRequest();
  ShopEntryResponse::default_instance_ = new ShopEntryResponse();
  GoodsInfo::default_instance_ = new GoodsInfo();
  GoodsItemInfo::default_instance_ = new GoodsItemInfo();
  GoodsBuyRequest::default_instance_ = new GoodsBuyRequest();
  GoodsBuyResponse::default_instance_ = new GoodsBuyResponse();
  ShopEntryRequest::default_instance_->InitAsDefaultInstance();
  ShopEntryResponse::default_instance_->InitAsDefaultInstance();
  GoodsInfo::default_instance_->InitAsDefaultInstance();
  GoodsItemInfo::default_instance_->InitAsDefaultInstance();
  GoodsBuyRequest::default_instance_->InitAsDefaultInstance();
  GoodsBuyResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_YuanBaoShopModule_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_YuanBaoShopModule_2eproto_once_);
void protobuf_AddDesc_YuanBaoShopModule_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_YuanBaoShopModule_2eproto_once_,
                 &protobuf_AddDesc_YuanBaoShopModule_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_YuanBaoShopModule_2eproto {
  StaticDescriptorInitializer_YuanBaoShopModule_2eproto() {
    protobuf_AddDesc_YuanBaoShopModule_2eproto();
  }
} static_descriptor_initializer_YuanBaoShopModule_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int ShopEntryRequest::kCurrentShopTypeFieldNumber;
#endif  // !_MSC_VER

ShopEntryRequest::ShopEntryRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ShopEntryRequest)
}

void ShopEntryRequest::InitAsDefaultInstance() {
}

ShopEntryRequest::ShopEntryRequest(const ShopEntryRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ShopEntryRequest)
}

void ShopEntryRequest::SharedCtor() {
  _cached_size_ = 0;
  currentshoptype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopEntryRequest::~ShopEntryRequest() {
  // @@protoc_insertion_point(destructor:main.ShopEntryRequest)
  SharedDtor();
}

void ShopEntryRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShopEntryRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopEntryRequest& ShopEntryRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

ShopEntryRequest* ShopEntryRequest::default_instance_ = NULL;

ShopEntryRequest* ShopEntryRequest::New() const {
  return new ShopEntryRequest;
}

void ShopEntryRequest::Clear() {
  currentshoptype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ShopEntryRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ShopEntryRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 currentShopType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentshoptype_)));
          set_has_currentshoptype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.ShopEntryRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ShopEntryRequest)
  return false;
#undef DO_
}

void ShopEntryRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ShopEntryRequest)
  // optional int32 currentShopType = 1;
  if (has_currentshoptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->currentshoptype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ShopEntryRequest)
}

int ShopEntryRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 currentShopType = 1;
    if (has_currentshoptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentshoptype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopEntryRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopEntryRequest*>(&from));
}

void ShopEntryRequest::MergeFrom(const ShopEntryRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_currentshoptype()) {
      set_currentshoptype(from.currentshoptype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ShopEntryRequest::CopyFrom(const ShopEntryRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopEntryRequest::IsInitialized() const {

  return true;
}

void ShopEntryRequest::Swap(ShopEntryRequest* other) {
  if (other != this) {
    std::swap(currentshoptype_, other->currentshoptype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopEntryRequest::GetTypeName() const {
  return "main.ShopEntryRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ShopEntryResponse::kCurrentGoldFieldNumber;
const int ShopEntryResponse::kCurrentShopTypeFieldNumber;
const int ShopEntryResponse::kGoodsInfoFieldNumber;
#endif  // !_MSC_VER

ShopEntryResponse::ShopEntryResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.ShopEntryResponse)
}

void ShopEntryResponse::InitAsDefaultInstance() {
}

ShopEntryResponse::ShopEntryResponse(const ShopEntryResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.ShopEntryResponse)
}

void ShopEntryResponse::SharedCtor() {
  _cached_size_ = 0;
  currentgold_ = 0;
  currentshoptype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopEntryResponse::~ShopEntryResponse() {
  // @@protoc_insertion_point(destructor:main.ShopEntryResponse)
  SharedDtor();
}

void ShopEntryResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShopEntryResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopEntryResponse& ShopEntryResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

ShopEntryResponse* ShopEntryResponse::default_instance_ = NULL;

ShopEntryResponse* ShopEntryResponse::New() const {
  return new ShopEntryResponse;
}

void ShopEntryResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ShopEntryResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(currentgold_, currentshoptype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  goodsinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ShopEntryResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.ShopEntryResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 currentGold = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentgold_)));
          set_has_currentgold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_currentShopType;
        break;
      }

      // optional int32 currentShopType = 2;
      case 2: {
        if (tag == 16) {
         parse_currentShopType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentshoptype_)));
          set_has_currentshoptype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_goodsInfo;
        break;
      }

      // repeated .main.GoodsInfo goodsInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_goodsInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_goodsinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_goodsInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.ShopEntryResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.ShopEntryResponse)
  return false;
#undef DO_
}

void ShopEntryResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.ShopEntryResponse)
  // optional int32 currentGold = 1;
  if (has_currentgold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->currentgold(), output);
  }

  // optional int32 currentShopType = 2;
  if (has_currentshoptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->currentshoptype(), output);
  }

  // repeated .main.GoodsInfo goodsInfo = 3;
  for (int i = 0; i < this->goodsinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->goodsinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.ShopEntryResponse)
}

int ShopEntryResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 currentGold = 1;
    if (has_currentgold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentgold());
    }

    // optional int32 currentShopType = 2;
    if (has_currentshoptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentshoptype());
    }

  }
  // repeated .main.GoodsInfo goodsInfo = 3;
  total_size += 1 * this->goodsinfo_size();
  for (int i = 0; i < this->goodsinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->goodsinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopEntryResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopEntryResponse*>(&from));
}

void ShopEntryResponse::MergeFrom(const ShopEntryResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  goodsinfo_.MergeFrom(from.goodsinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_currentgold()) {
      set_currentgold(from.currentgold());
    }
    if (from.has_currentshoptype()) {
      set_currentshoptype(from.currentshoptype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ShopEntryResponse::CopyFrom(const ShopEntryResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopEntryResponse::IsInitialized() const {

  return true;
}

void ShopEntryResponse::Swap(ShopEntryResponse* other) {
  if (other != this) {
    std::swap(currentgold_, other->currentgold_);
    std::swap(currentshoptype_, other->currentshoptype_);
    goodsinfo_.Swap(&other->goodsinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopEntryResponse::GetTypeName() const {
  return "main.ShopEntryResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int GoodsInfo::kGoodsIdFieldNumber;
const int GoodsInfo::kGoodsNameFieldNumber;
const int GoodsInfo::kGoodsDescriptionFieldNumber;
const int GoodsInfo::kBeforePriceFieldNumber;
const int GoodsInfo::kCurrPriceFieldNumber;
const int GoodsInfo::kResidueCountFieldNumber;
const int GoodsInfo::kAllResidueCountFieldNumber;
const int GoodsInfo::kResidueTimeFieldNumber;
const int GoodsInfo::kCanBuyFieldNumber;
const int GoodsInfo::kNeedLevelFieldNumber;
const int GoodsInfo::kNeedVipLevelFieldNumber;
const int GoodsInfo::kGoodsItemInfoFieldNumber;
const int GoodsInfo::kCurrGrowthRateFieldNumber;
const int GoodsInfo::kBeforeGrowthRateFieldNumber;
const int GoodsInfo::kIsGoldFieldNumber;
#endif  // !_MSC_VER

GoodsInfo::GoodsInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.GoodsInfo)
}

void GoodsInfo::InitAsDefaultInstance() {
}

GoodsInfo::GoodsInfo(const GoodsInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.GoodsInfo)
}

void GoodsInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  goodsid_ = 0;
  goodsname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  goodsdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beforeprice_ = 0;
  currprice_ = 0;
  residuecount_ = 0;
  allresiduecount_ = 0;
  residuetime_ = GOOGLE_LONGLONG(0);
  canbuy_ = 0;
  needlevel_ = 0;
  needviplevel_ = 0;
  currgrowthrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beforegrowthrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  isgold_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GoodsInfo::~GoodsInfo() {
  // @@protoc_insertion_point(destructor:main.GoodsInfo)
  SharedDtor();
}

void GoodsInfo::SharedDtor() {
  if (goodsname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete goodsname_;
  }
  if (goodsdescription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete goodsdescription_;
  }
  if (currgrowthrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currgrowthrate_;
  }
  if (beforegrowthrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete beforegrowthrate_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GoodsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GoodsInfo& GoodsInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

GoodsInfo* GoodsInfo::default_instance_ = NULL;

GoodsInfo* GoodsInfo::New() const {
  return new GoodsInfo;
}

void GoodsInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GoodsInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(goodsid_, beforeprice_);
    ZR_(currprice_, allresiduecount_);
    if (has_goodsname()) {
      if (goodsname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        goodsname_->clear();
      }
    }
    if (has_goodsdescription()) {
      if (goodsdescription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        goodsdescription_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 30464) {
    ZR_(canbuy_, needviplevel_);
    if (has_currgrowthrate()) {
      if (currgrowthrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        currgrowthrate_->clear();
      }
    }
    if (has_beforegrowthrate()) {
      if (beforegrowthrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        beforegrowthrate_->clear();
      }
    }
    isgold_ = false;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  goodsiteminfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GoodsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.GoodsInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 goodsId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &goodsid_)));
          set_has_goodsid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_goodsName;
        break;
      }

      // optional string goodsName = 2;
      case 2: {
        if (tag == 18) {
         parse_goodsName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_goodsname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_goodsDescription;
        break;
      }

      // optional string goodsDescription = 3;
      case 3: {
        if (tag == 26) {
         parse_goodsDescription:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_goodsdescription()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_beforePrice;
        break;
      }

      // optional sint32 beforePrice = 4;
      case 4: {
        if (tag == 32) {
         parse_beforePrice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &beforeprice_)));
          set_has_beforeprice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_currPrice;
        break;
      }

      // optional sint32 currPrice = 5;
      case 5: {
        if (tag == 40) {
         parse_currPrice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &currprice_)));
          set_has_currprice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_residueCount;
        break;
      }

      // optional sint32 residueCount = 6;
      case 6: {
        if (tag == 48) {
         parse_residueCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &residuecount_)));
          set_has_residuecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_allResidueCount;
        break;
      }

      // optional sint32 allResidueCount = 7;
      case 7: {
        if (tag == 56) {
         parse_allResidueCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &allresiduecount_)));
          set_has_allresiduecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_residueTime;
        break;
      }

      // optional sint64 residueTime = 8;
      case 8: {
        if (tag == 64) {
         parse_residueTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &residuetime_)));
          set_has_residuetime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_canBuy;
        break;
      }

      // optional sint32 canBuy = 9;
      case 9: {
        if (tag == 72) {
         parse_canBuy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &canbuy_)));
          set_has_canbuy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_needLevel;
        break;
      }

      // optional sint32 needLevel = 10;
      case 10: {
        if (tag == 80) {
         parse_needLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &needlevel_)));
          set_has_needlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_needVipLevel;
        break;
      }

      // optional sint32 needVipLevel = 11;
      case 11: {
        if (tag == 88) {
         parse_needVipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &needviplevel_)));
          set_has_needviplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_goodsItemInfo;
        break;
      }

      // repeated .main.GoodsItemInfo goodsItemInfo = 12;
      case 12: {
        if (tag == 98) {
         parse_goodsItemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_goodsiteminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_goodsItemInfo;
        if (input->ExpectTag(106)) goto parse_currGrowthRate;
        break;
      }

      // optional string currGrowthRate = 13;
      case 13: {
        if (tag == 106) {
         parse_currGrowthRate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_currgrowthrate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_beforeGrowthRate;
        break;
      }

      // optional string beforeGrowthRate = 14;
      case 14: {
        if (tag == 114) {
         parse_beforeGrowthRate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_beforegrowthrate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_isGold;
        break;
      }

      // optional bool isGold = 15;
      case 15: {
        if (tag == 120) {
         parse_isGold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isgold_)));
          set_has_isgold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.GoodsInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.GoodsInfo)
  return false;
#undef DO_
}

void GoodsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.GoodsInfo)
  // optional sint32 goodsId = 1;
  if (has_goodsid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->goodsid(), output);
  }

  // optional string goodsName = 2;
  if (has_goodsname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->goodsname(), output);
  }

  // optional string goodsDescription = 3;
  if (has_goodsdescription()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->goodsdescription(), output);
  }

  // optional sint32 beforePrice = 4;
  if (has_beforeprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->beforeprice(), output);
  }

  // optional sint32 currPrice = 5;
  if (has_currprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->currprice(), output);
  }

  // optional sint32 residueCount = 6;
  if (has_residuecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(6, this->residuecount(), output);
  }

  // optional sint32 allResidueCount = 7;
  if (has_allresiduecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(7, this->allresiduecount(), output);
  }

  // optional sint64 residueTime = 8;
  if (has_residuetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(8, this->residuetime(), output);
  }

  // optional sint32 canBuy = 9;
  if (has_canbuy()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(9, this->canbuy(), output);
  }

  // optional sint32 needLevel = 10;
  if (has_needlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(10, this->needlevel(), output);
  }

  // optional sint32 needVipLevel = 11;
  if (has_needviplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(11, this->needviplevel(), output);
  }

  // repeated .main.GoodsItemInfo goodsItemInfo = 12;
  for (int i = 0; i < this->goodsiteminfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->goodsiteminfo(i), output);
  }

  // optional string currGrowthRate = 13;
  if (has_currgrowthrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->currgrowthrate(), output);
  }

  // optional string beforeGrowthRate = 14;
  if (has_beforegrowthrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->beforegrowthrate(), output);
  }

  // optional bool isGold = 15;
  if (has_isgold()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->isgold(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.GoodsInfo)
}

int GoodsInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 goodsId = 1;
    if (has_goodsid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->goodsid());
    }

    // optional string goodsName = 2;
    if (has_goodsname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->goodsname());
    }

    // optional string goodsDescription = 3;
    if (has_goodsdescription()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->goodsdescription());
    }

    // optional sint32 beforePrice = 4;
    if (has_beforeprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->beforeprice());
    }

    // optional sint32 currPrice = 5;
    if (has_currprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->currprice());
    }

    // optional sint32 residueCount = 6;
    if (has_residuecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->residuecount());
    }

    // optional sint32 allResidueCount = 7;
    if (has_allresiduecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->allresiduecount());
    }

    // optional sint64 residueTime = 8;
    if (has_residuetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->residuetime());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional sint32 canBuy = 9;
    if (has_canbuy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->canbuy());
    }

    // optional sint32 needLevel = 10;
    if (has_needlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->needlevel());
    }

    // optional sint32 needVipLevel = 11;
    if (has_needviplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->needviplevel());
    }

    // optional string currGrowthRate = 13;
    if (has_currgrowthrate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->currgrowthrate());
    }

    // optional string beforeGrowthRate = 14;
    if (has_beforegrowthrate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->beforegrowthrate());
    }

    // optional bool isGold = 15;
    if (has_isgold()) {
      total_size += 1 + 1;
    }

  }
  // repeated .main.GoodsItemInfo goodsItemInfo = 12;
  total_size += 1 * this->goodsiteminfo_size();
  for (int i = 0; i < this->goodsiteminfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->goodsiteminfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GoodsInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GoodsInfo*>(&from));
}

void GoodsInfo::MergeFrom(const GoodsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  goodsiteminfo_.MergeFrom(from.goodsiteminfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_goodsid()) {
      set_goodsid(from.goodsid());
    }
    if (from.has_goodsname()) {
      set_goodsname(from.goodsname());
    }
    if (from.has_goodsdescription()) {
      set_goodsdescription(from.goodsdescription());
    }
    if (from.has_beforeprice()) {
      set_beforeprice(from.beforeprice());
    }
    if (from.has_currprice()) {
      set_currprice(from.currprice());
    }
    if (from.has_residuecount()) {
      set_residuecount(from.residuecount());
    }
    if (from.has_allresiduecount()) {
      set_allresiduecount(from.allresiduecount());
    }
    if (from.has_residuetime()) {
      set_residuetime(from.residuetime());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_canbuy()) {
      set_canbuy(from.canbuy());
    }
    if (from.has_needlevel()) {
      set_needlevel(from.needlevel());
    }
    if (from.has_needviplevel()) {
      set_needviplevel(from.needviplevel());
    }
    if (from.has_currgrowthrate()) {
      set_currgrowthrate(from.currgrowthrate());
    }
    if (from.has_beforegrowthrate()) {
      set_beforegrowthrate(from.beforegrowthrate());
    }
    if (from.has_isgold()) {
      set_isgold(from.isgold());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GoodsInfo::CopyFrom(const GoodsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoodsInfo::IsInitialized() const {

  return true;
}

void GoodsInfo::Swap(GoodsInfo* other) {
  if (other != this) {
    std::swap(goodsid_, other->goodsid_);
    std::swap(goodsname_, other->goodsname_);
    std::swap(goodsdescription_, other->goodsdescription_);
    std::swap(beforeprice_, other->beforeprice_);
    std::swap(currprice_, other->currprice_);
    std::swap(residuecount_, other->residuecount_);
    std::swap(allresiduecount_, other->allresiduecount_);
    std::swap(residuetime_, other->residuetime_);
    std::swap(canbuy_, other->canbuy_);
    std::swap(needlevel_, other->needlevel_);
    std::swap(needviplevel_, other->needviplevel_);
    goodsiteminfo_.Swap(&other->goodsiteminfo_);
    std::swap(currgrowthrate_, other->currgrowthrate_);
    std::swap(beforegrowthrate_, other->beforegrowthrate_);
    std::swap(isgold_, other->isgold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GoodsInfo::GetTypeName() const {
  return "main.GoodsInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GoodsItemInfo::kItemTypeFieldNumber;
const int GoodsItemInfo::kItemIdFieldNumber;
const int GoodsItemInfo::kItemCountFieldNumber;
#endif  // !_MSC_VER

GoodsItemInfo::GoodsItemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.GoodsItemInfo)
}

void GoodsItemInfo::InitAsDefaultInstance() {
}

GoodsItemInfo::GoodsItemInfo(const GoodsItemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.GoodsItemInfo)
}

void GoodsItemInfo::SharedCtor() {
  _cached_size_ = 0;
  itemtype_ = 0;
  itemid_ = 0;
  itemcount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GoodsItemInfo::~GoodsItemInfo() {
  // @@protoc_insertion_point(destructor:main.GoodsItemInfo)
  SharedDtor();
}

void GoodsItemInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GoodsItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GoodsItemInfo& GoodsItemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

GoodsItemInfo* GoodsItemInfo::default_instance_ = NULL;

GoodsItemInfo* GoodsItemInfo::New() const {
  return new GoodsItemInfo;
}

void GoodsItemInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GoodsItemInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemtype_, itemcount_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GoodsItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.GoodsItemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 itemType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &itemtype_)));
          set_has_itemtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_itemId;
        break;
      }

      // optional sint32 itemId = 2;
      case 2: {
        if (tag == 16) {
         parse_itemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemCount;
        break;
      }

      // optional sint32 itemCount = 3;
      case 3: {
        if (tag == 24) {
         parse_itemCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &itemcount_)));
          set_has_itemcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.GoodsItemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.GoodsItemInfo)
  return false;
#undef DO_
}

void GoodsItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.GoodsItemInfo)
  // optional sint32 itemType = 1;
  if (has_itemtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->itemtype(), output);
  }

  // optional sint32 itemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->itemid(), output);
  }

  // optional sint32 itemCount = 3;
  if (has_itemcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->itemcount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.GoodsItemInfo)
}

int GoodsItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 itemType = 1;
    if (has_itemtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->itemtype());
    }

    // optional sint32 itemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->itemid());
    }

    // optional sint32 itemCount = 3;
    if (has_itemcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->itemcount());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GoodsItemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GoodsItemInfo*>(&from));
}

void GoodsItemInfo::MergeFrom(const GoodsItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemtype()) {
      set_itemtype(from.itemtype());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_itemcount()) {
      set_itemcount(from.itemcount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GoodsItemInfo::CopyFrom(const GoodsItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoodsItemInfo::IsInitialized() const {

  return true;
}

void GoodsItemInfo::Swap(GoodsItemInfo* other) {
  if (other != this) {
    std::swap(itemtype_, other->itemtype_);
    std::swap(itemid_, other->itemid_);
    std::swap(itemcount_, other->itemcount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GoodsItemInfo::GetTypeName() const {
  return "main.GoodsItemInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GoodsBuyRequest::kGoodsIdFieldNumber;
const int GoodsBuyRequest::kGoodsCountFieldNumber;
const int GoodsBuyRequest::kShopTypeFieldNumber;
#endif  // !_MSC_VER

GoodsBuyRequest::GoodsBuyRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.GoodsBuyRequest)
}

void GoodsBuyRequest::InitAsDefaultInstance() {
}

GoodsBuyRequest::GoodsBuyRequest(const GoodsBuyRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.GoodsBuyRequest)
}

void GoodsBuyRequest::SharedCtor() {
  _cached_size_ = 0;
  goodsid_ = 0;
  goodscount_ = 0;
  shoptype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GoodsBuyRequest::~GoodsBuyRequest() {
  // @@protoc_insertion_point(destructor:main.GoodsBuyRequest)
  SharedDtor();
}

void GoodsBuyRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GoodsBuyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GoodsBuyRequest& GoodsBuyRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

GoodsBuyRequest* GoodsBuyRequest::default_instance_ = NULL;

GoodsBuyRequest* GoodsBuyRequest::New() const {
  return new GoodsBuyRequest;
}

void GoodsBuyRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GoodsBuyRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(goodsid_, shoptype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GoodsBuyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.GoodsBuyRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 goodsId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &goodsid_)));
          set_has_goodsid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_goodsCount;
        break;
      }

      // optional sint32 goodsCount = 2;
      case 2: {
        if (tag == 16) {
         parse_goodsCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &goodscount_)));
          set_has_goodscount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shopType;
        break;
      }

      // optional sint32 shopType = 3;
      case 3: {
        if (tag == 24) {
         parse_shopType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &shoptype_)));
          set_has_shoptype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.GoodsBuyRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.GoodsBuyRequest)
  return false;
#undef DO_
}

void GoodsBuyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.GoodsBuyRequest)
  // optional sint32 goodsId = 1;
  if (has_goodsid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->goodsid(), output);
  }

  // optional sint32 goodsCount = 2;
  if (has_goodscount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->goodscount(), output);
  }

  // optional sint32 shopType = 3;
  if (has_shoptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->shoptype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.GoodsBuyRequest)
}

int GoodsBuyRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 goodsId = 1;
    if (has_goodsid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->goodsid());
    }

    // optional sint32 goodsCount = 2;
    if (has_goodscount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->goodscount());
    }

    // optional sint32 shopType = 3;
    if (has_shoptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->shoptype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GoodsBuyRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GoodsBuyRequest*>(&from));
}

void GoodsBuyRequest::MergeFrom(const GoodsBuyRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_goodsid()) {
      set_goodsid(from.goodsid());
    }
    if (from.has_goodscount()) {
      set_goodscount(from.goodscount());
    }
    if (from.has_shoptype()) {
      set_shoptype(from.shoptype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GoodsBuyRequest::CopyFrom(const GoodsBuyRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoodsBuyRequest::IsInitialized() const {

  return true;
}

void GoodsBuyRequest::Swap(GoodsBuyRequest* other) {
  if (other != this) {
    std::swap(goodsid_, other->goodsid_);
    std::swap(goodscount_, other->goodscount_);
    std::swap(shoptype_, other->shoptype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GoodsBuyRequest::GetTypeName() const {
  return "main.GoodsBuyRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int GoodsBuyResponse::kStateFieldNumber;
const int GoodsBuyResponse::kCurrShopTypeFieldNumber;
const int GoodsBuyResponse::kGoodsItemInfoFieldNumber;
const int GoodsBuyResponse::kGoodsIdFieldNumber;
const int GoodsBuyResponse::kCurrPriceFieldNumber;
const int GoodsBuyResponse::kBeforePriceFieldNumber;
const int GoodsBuyResponse::kResidueCountFieldNumber;
const int GoodsBuyResponse::kAllResidueCountFieldNumber;
#endif  // !_MSC_VER

GoodsBuyResponse::GoodsBuyResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:main.GoodsBuyResponse)
}

void GoodsBuyResponse::InitAsDefaultInstance() {
}

GoodsBuyResponse::GoodsBuyResponse(const GoodsBuyResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:main.GoodsBuyResponse)
}

void GoodsBuyResponse::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  currshoptype_ = 0;
  goodsid_ = 0;
  currprice_ = 0;
  beforeprice_ = 0;
  residuecount_ = 0;
  allresiduecount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GoodsBuyResponse::~GoodsBuyResponse() {
  // @@protoc_insertion_point(destructor:main.GoodsBuyResponse)
  SharedDtor();
}

void GoodsBuyResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GoodsBuyResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GoodsBuyResponse& GoodsBuyResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_YuanBaoShopModule_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_YuanBaoShopModule_2eproto();
#endif
  return *default_instance_;
}

GoodsBuyResponse* GoodsBuyResponse::default_instance_ = NULL;

GoodsBuyResponse* GoodsBuyResponse::New() const {
  return new GoodsBuyResponse;
}

void GoodsBuyResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GoodsBuyResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 251) {
    ZR_(state_, currshoptype_);
    ZR_(goodsid_, allresiduecount_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  goodsiteminfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GoodsBuyResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:main.GoodsBuyResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_currShopType;
        break;
      }

      // optional sint32 currShopType = 2;
      case 2: {
        if (tag == 16) {
         parse_currShopType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &currshoptype_)));
          set_has_currshoptype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_goodsItemInfo;
        break;
      }

      // repeated .main.GoodsItemInfo goodsItemInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_goodsItemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_goodsiteminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_goodsItemInfo;
        if (input->ExpectTag(32)) goto parse_goodsId;
        break;
      }

      // optional sint32 goodsId = 4;
      case 4: {
        if (tag == 32) {
         parse_goodsId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &goodsid_)));
          set_has_goodsid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_currPrice;
        break;
      }

      // optional sint32 currPrice = 5;
      case 5: {
        if (tag == 40) {
         parse_currPrice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &currprice_)));
          set_has_currprice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_beforePrice;
        break;
      }

      // optional sint32 beforePrice = 6;
      case 6: {
        if (tag == 48) {
         parse_beforePrice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &beforeprice_)));
          set_has_beforeprice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_residueCount;
        break;
      }

      // optional sint32 residueCount = 7;
      case 7: {
        if (tag == 56) {
         parse_residueCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &residuecount_)));
          set_has_residuecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_allResidueCount;
        break;
      }

      // optional sint32 allResidueCount = 8;
      case 8: {
        if (tag == 64) {
         parse_allResidueCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &allresiduecount_)));
          set_has_allresiduecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:main.GoodsBuyResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:main.GoodsBuyResponse)
  return false;
#undef DO_
}

void GoodsBuyResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:main.GoodsBuyResponse)
  // optional sint32 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->state(), output);
  }

  // optional sint32 currShopType = 2;
  if (has_currshoptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->currshoptype(), output);
  }

  // repeated .main.GoodsItemInfo goodsItemInfo = 3;
  for (int i = 0; i < this->goodsiteminfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->goodsiteminfo(i), output);
  }

  // optional sint32 goodsId = 4;
  if (has_goodsid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->goodsid(), output);
  }

  // optional sint32 currPrice = 5;
  if (has_currprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->currprice(), output);
  }

  // optional sint32 beforePrice = 6;
  if (has_beforeprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(6, this->beforeprice(), output);
  }

  // optional sint32 residueCount = 7;
  if (has_residuecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(7, this->residuecount(), output);
  }

  // optional sint32 allResidueCount = 8;
  if (has_allresiduecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(8, this->allresiduecount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:main.GoodsBuyResponse)
}

int GoodsBuyResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->state());
    }

    // optional sint32 currShopType = 2;
    if (has_currshoptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->currshoptype());
    }

    // optional sint32 goodsId = 4;
    if (has_goodsid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->goodsid());
    }

    // optional sint32 currPrice = 5;
    if (has_currprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->currprice());
    }

    // optional sint32 beforePrice = 6;
    if (has_beforeprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->beforeprice());
    }

    // optional sint32 residueCount = 7;
    if (has_residuecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->residuecount());
    }

    // optional sint32 allResidueCount = 8;
    if (has_allresiduecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->allresiduecount());
    }

  }
  // repeated .main.GoodsItemInfo goodsItemInfo = 3;
  total_size += 1 * this->goodsiteminfo_size();
  for (int i = 0; i < this->goodsiteminfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->goodsiteminfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GoodsBuyResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GoodsBuyResponse*>(&from));
}

void GoodsBuyResponse::MergeFrom(const GoodsBuyResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  goodsiteminfo_.MergeFrom(from.goodsiteminfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_currshoptype()) {
      set_currshoptype(from.currshoptype());
    }
    if (from.has_goodsid()) {
      set_goodsid(from.goodsid());
    }
    if (from.has_currprice()) {
      set_currprice(from.currprice());
    }
    if (from.has_beforeprice()) {
      set_beforeprice(from.beforeprice());
    }
    if (from.has_residuecount()) {
      set_residuecount(from.residuecount());
    }
    if (from.has_allresiduecount()) {
      set_allresiduecount(from.allresiduecount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GoodsBuyResponse::CopyFrom(const GoodsBuyResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoodsBuyResponse::IsInitialized() const {

  return true;
}

void GoodsBuyResponse::Swap(GoodsBuyResponse* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(currshoptype_, other->currshoptype_);
    goodsiteminfo_.Swap(&other->goodsiteminfo_);
    std::swap(goodsid_, other->goodsid_);
    std::swap(currprice_, other->currprice_);
    std::swap(beforeprice_, other->beforeprice_);
    std::swap(residuecount_, other->residuecount_);
    std::swap(allresiduecount_, other->allresiduecount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GoodsBuyResponse::GetTypeName() const {
  return "main.GoodsBuyResponse";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

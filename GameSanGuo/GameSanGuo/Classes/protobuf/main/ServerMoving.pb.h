// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServerMoving.proto

#ifndef PROTOBUF_ServerMoving_2eproto__INCLUDED
#define PROTOBUF_ServerMoving_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ServerMoving_2eproto();
void protobuf_AssignDesc_ServerMoving_2eproto();
void protobuf_ShutdownFile_ServerMoving_2eproto();

class ServerMovingResponse;
class ServerMovingModel;
class ServerMovingModel2;
class AnnouncementRequest;
class AnnouncementResponse;
class AnnouncementModel;
class ServerNoticeResponse;
class AlanWake;
class ShowCommonMessage;

// ===================================================================

class ServerMovingResponse : public ::google::protobuf::MessageLite {
 public:
  ServerMovingResponse();
  virtual ~ServerMovingResponse();

  ServerMovingResponse(const ServerMovingResponse& from);

  inline ServerMovingResponse& operator=(const ServerMovingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMovingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMovingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMovingResponse* other);

  // implements Message ----------------------------------------------

  ServerMovingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMovingResponse& from);
  void MergeFrom(const ServerMovingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.ServerMovingModel model = 1;
  inline int model_size() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::main::ServerMovingModel& model(int index) const;
  inline ::main::ServerMovingModel* mutable_model(int index);
  inline ::main::ServerMovingModel* add_model();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel >&
      model() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel >*
      mutable_model();

  // @@protoc_insertion_point(class_scope:main.ServerMovingResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel > model_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static ServerMovingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerMovingModel : public ::google::protobuf::MessageLite {
 public:
  ServerMovingModel();
  virtual ~ServerMovingModel();

  ServerMovingModel(const ServerMovingModel& from);

  inline ServerMovingModel& operator=(const ServerMovingModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMovingModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMovingModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMovingModel* other);

  // implements Message ----------------------------------------------

  ServerMovingModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMovingModel& from);
  void MergeFrom(const ServerMovingModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // repeated .main.ServerMovingModel2 model = 3;
  inline int model_size() const;
  inline void clear_model();
  static const int kModelFieldNumber = 3;
  inline const ::main::ServerMovingModel2& model(int index) const;
  inline ::main::ServerMovingModel2* mutable_model(int index);
  inline ::main::ServerMovingModel2* add_model();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel2 >&
      model() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel2 >*
      mutable_model();

  // @@protoc_insertion_point(class_scope:main.ServerMovingModel)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel2 > model_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static ServerMovingModel* default_instance_;
};
// -------------------------------------------------------------------

class ServerMovingModel2 : public ::google::protobuf::MessageLite {
 public:
  ServerMovingModel2();
  virtual ~ServerMovingModel2();

  ServerMovingModel2(const ServerMovingModel2& from);

  inline ServerMovingModel2& operator=(const ServerMovingModel2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMovingModel2& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMovingModel2* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMovingModel2* other);

  // implements Message ----------------------------------------------

  ServerMovingModel2* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMovingModel2& from);
  void MergeFrom(const ServerMovingModel2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:main.ServerMovingModel2)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static ServerMovingModel2* default_instance_;
};
// -------------------------------------------------------------------

class AnnouncementRequest : public ::google::protobuf::MessageLite {
 public:
  AnnouncementRequest();
  virtual ~AnnouncementRequest();

  AnnouncementRequest(const AnnouncementRequest& from);

  inline AnnouncementRequest& operator=(const AnnouncementRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnouncementRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnouncementRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnouncementRequest* other);

  // implements Message ----------------------------------------------

  AnnouncementRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnouncementRequest& from);
  void MergeFrom(const AnnouncementRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.AnnouncementRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static AnnouncementRequest* default_instance_;
};
// -------------------------------------------------------------------

class AnnouncementResponse : public ::google::protobuf::MessageLite {
 public:
  AnnouncementResponse();
  virtual ~AnnouncementResponse();

  AnnouncementResponse(const AnnouncementResponse& from);

  inline AnnouncementResponse& operator=(const AnnouncementResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnouncementResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnouncementResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnouncementResponse* other);

  // implements Message ----------------------------------------------

  AnnouncementResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnouncementResponse& from);
  void MergeFrom(const AnnouncementResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .main.AnnouncementModel announcementModel = 1;
  inline int announcementmodel_size() const;
  inline void clear_announcementmodel();
  static const int kAnnouncementModelFieldNumber = 1;
  inline const ::main::AnnouncementModel& announcementmodel(int index) const;
  inline ::main::AnnouncementModel* mutable_announcementmodel(int index);
  inline ::main::AnnouncementModel* add_announcementmodel();
  inline const ::google::protobuf::RepeatedPtrField< ::main::AnnouncementModel >&
      announcementmodel() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::AnnouncementModel >*
      mutable_announcementmodel();

  // @@protoc_insertion_point(class_scope:main.AnnouncementResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::main::AnnouncementModel > announcementmodel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static AnnouncementResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnnouncementModel : public ::google::protobuf::MessageLite {
 public:
  AnnouncementModel();
  virtual ~AnnouncementModel();

  AnnouncementModel(const AnnouncementModel& from);

  inline AnnouncementModel& operator=(const AnnouncementModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnouncementModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnouncementModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnouncementModel* other);

  // implements Message ----------------------------------------------

  AnnouncementModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnouncementModel& from);
  void MergeFrom(const AnnouncementModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 viewId = 4;
  inline bool has_viewid() const;
  inline void clear_viewid();
  static const int kViewIdFieldNumber = 4;
  inline ::google::protobuf::int32 viewid() const;
  inline void set_viewid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.AnnouncementModel)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_viewid();
  inline void clear_has_viewid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* content_;
  ::std::string* url_;
  ::google::protobuf::int32 viewid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static AnnouncementModel* default_instance_;
};
// -------------------------------------------------------------------

class ServerNoticeResponse : public ::google::protobuf::MessageLite {
 public:
  ServerNoticeResponse();
  virtual ~ServerNoticeResponse();

  ServerNoticeResponse(const ServerNoticeResponse& from);

  inline ServerNoticeResponse& operator=(const ServerNoticeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerNoticeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerNoticeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerNoticeResponse* other);

  // implements Message ----------------------------------------------

  ServerNoticeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerNoticeResponse& from);
  void MergeFrom(const ServerNoticeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:main.ServerNoticeResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  ::google::protobuf::int32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static ServerNoticeResponse* default_instance_;
};
// -------------------------------------------------------------------

class AlanWake : public ::google::protobuf::MessageLite {
 public:
  AlanWake();
  virtual ~AlanWake();

  AlanWake(const AlanWake& from);

  inline AlanWake& operator=(const AlanWake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AlanWake& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AlanWake* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AlanWake* other);

  // implements Message ----------------------------------------------

  AlanWake* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AlanWake& from);
  void MergeFrom(const AlanWake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 arg1 = 1 [default = 0];
  inline bool has_arg1() const;
  inline void clear_arg1();
  static const int kArg1FieldNumber = 1;
  inline ::google::protobuf::int32 arg1() const;
  inline void set_arg1(::google::protobuf::int32 value);

  // optional string arg2 = 2 [default = ""];
  inline bool has_arg2() const;
  inline void clear_arg2();
  static const int kArg2FieldNumber = 2;
  inline const ::std::string& arg2() const;
  inline void set_arg2(const ::std::string& value);
  inline void set_arg2(const char* value);
  inline void set_arg2(const char* value, size_t size);
  inline ::std::string* mutable_arg2();
  inline ::std::string* release_arg2();
  inline void set_allocated_arg2(::std::string* arg2);

  // @@protoc_insertion_point(class_scope:main.AlanWake)
 private:
  inline void set_has_arg1();
  inline void clear_has_arg1();
  inline void set_has_arg2();
  inline void clear_has_arg2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* arg2_;
  ::google::protobuf::int32 arg1_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static AlanWake* default_instance_;
};
// -------------------------------------------------------------------

class ShowCommonMessage : public ::google::protobuf::MessageLite {
 public:
  ShowCommonMessage();
  virtual ~ShowCommonMessage();

  ShowCommonMessage(const ShowCommonMessage& from);

  inline ShowCommonMessage& operator=(const ShowCommonMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShowCommonMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShowCommonMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShowCommonMessage* other);

  // implements Message ----------------------------------------------

  ShowCommonMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShowCommonMessage& from);
  void MergeFrom(const ShowCommonMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:main.ShowCommonMessage)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ServerMoving_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ServerMoving_2eproto();
  #endif
  friend void protobuf_AssignDesc_ServerMoving_2eproto();
  friend void protobuf_ShutdownFile_ServerMoving_2eproto();

  void InitAsDefaultInstance();
  static ShowCommonMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ServerMovingResponse

// repeated .main.ServerMovingModel model = 1;
inline int ServerMovingResponse::model_size() const {
  return model_.size();
}
inline void ServerMovingResponse::clear_model() {
  model_.Clear();
}
inline const ::main::ServerMovingModel& ServerMovingResponse::model(int index) const {
  // @@protoc_insertion_point(field_get:main.ServerMovingResponse.model)
  return model_.Get(index);
}
inline ::main::ServerMovingModel* ServerMovingResponse::mutable_model(int index) {
  // @@protoc_insertion_point(field_mutable:main.ServerMovingResponse.model)
  return model_.Mutable(index);
}
inline ::main::ServerMovingModel* ServerMovingResponse::add_model() {
  // @@protoc_insertion_point(field_add:main.ServerMovingResponse.model)
  return model_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel >&
ServerMovingResponse::model() const {
  // @@protoc_insertion_point(field_list:main.ServerMovingResponse.model)
  return model_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel >*
ServerMovingResponse::mutable_model() {
  // @@protoc_insertion_point(field_mutable_list:main.ServerMovingResponse.model)
  return &model_;
}

// -------------------------------------------------------------------

// ServerMovingModel

// optional int32 id = 1;
inline bool ServerMovingModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMovingModel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMovingModel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMovingModel::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ServerMovingModel::id() const {
  // @@protoc_insertion_point(field_get:main.ServerMovingModel.id)
  return id_;
}
inline void ServerMovingModel::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:main.ServerMovingModel.id)
}

// optional int32 level = 2;
inline bool ServerMovingModel::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMovingModel::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMovingModel::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMovingModel::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ServerMovingModel::level() const {
  // @@protoc_insertion_point(field_get:main.ServerMovingModel.level)
  return level_;
}
inline void ServerMovingModel::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.ServerMovingModel.level)
}

// repeated .main.ServerMovingModel2 model = 3;
inline int ServerMovingModel::model_size() const {
  return model_.size();
}
inline void ServerMovingModel::clear_model() {
  model_.Clear();
}
inline const ::main::ServerMovingModel2& ServerMovingModel::model(int index) const {
  // @@protoc_insertion_point(field_get:main.ServerMovingModel.model)
  return model_.Get(index);
}
inline ::main::ServerMovingModel2* ServerMovingModel::mutable_model(int index) {
  // @@protoc_insertion_point(field_mutable:main.ServerMovingModel.model)
  return model_.Mutable(index);
}
inline ::main::ServerMovingModel2* ServerMovingModel::add_model() {
  // @@protoc_insertion_point(field_add:main.ServerMovingModel.model)
  return model_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel2 >&
ServerMovingModel::model() const {
  // @@protoc_insertion_point(field_list:main.ServerMovingModel.model)
  return model_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ServerMovingModel2 >*
ServerMovingModel::mutable_model() {
  // @@protoc_insertion_point(field_mutable_list:main.ServerMovingModel.model)
  return &model_;
}

// -------------------------------------------------------------------

// ServerMovingModel2

// optional string msg = 1;
inline bool ServerMovingModel2::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMovingModel2::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMovingModel2::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMovingModel2::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ServerMovingModel2::msg() const {
  // @@protoc_insertion_point(field_get:main.ServerMovingModel2.msg)
  return *msg_;
}
inline void ServerMovingModel2::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:main.ServerMovingModel2.msg)
}
inline void ServerMovingModel2::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ServerMovingModel2.msg)
}
inline void ServerMovingModel2::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ServerMovingModel2.msg)
}
inline ::std::string* ServerMovingModel2::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ServerMovingModel2.msg)
  return msg_;
}
inline ::std::string* ServerMovingModel2::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerMovingModel2::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ServerMovingModel2.msg)
}

// -------------------------------------------------------------------

// AnnouncementRequest

// -------------------------------------------------------------------

// AnnouncementResponse

// repeated .main.AnnouncementModel announcementModel = 1;
inline int AnnouncementResponse::announcementmodel_size() const {
  return announcementmodel_.size();
}
inline void AnnouncementResponse::clear_announcementmodel() {
  announcementmodel_.Clear();
}
inline const ::main::AnnouncementModel& AnnouncementResponse::announcementmodel(int index) const {
  // @@protoc_insertion_point(field_get:main.AnnouncementResponse.announcementModel)
  return announcementmodel_.Get(index);
}
inline ::main::AnnouncementModel* AnnouncementResponse::mutable_announcementmodel(int index) {
  // @@protoc_insertion_point(field_mutable:main.AnnouncementResponse.announcementModel)
  return announcementmodel_.Mutable(index);
}
inline ::main::AnnouncementModel* AnnouncementResponse::add_announcementmodel() {
  // @@protoc_insertion_point(field_add:main.AnnouncementResponse.announcementModel)
  return announcementmodel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::AnnouncementModel >&
AnnouncementResponse::announcementmodel() const {
  // @@protoc_insertion_point(field_list:main.AnnouncementResponse.announcementModel)
  return announcementmodel_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::AnnouncementModel >*
AnnouncementResponse::mutable_announcementmodel() {
  // @@protoc_insertion_point(field_mutable_list:main.AnnouncementResponse.announcementModel)
  return &announcementmodel_;
}

// -------------------------------------------------------------------

// AnnouncementModel

// optional string title = 1;
inline bool AnnouncementModel::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnouncementModel::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnouncementModel::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnouncementModel::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& AnnouncementModel::title() const {
  // @@protoc_insertion_point(field_get:main.AnnouncementModel.title)
  return *title_;
}
inline void AnnouncementModel::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:main.AnnouncementModel.title)
}
inline void AnnouncementModel::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AnnouncementModel.title)
}
inline void AnnouncementModel::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AnnouncementModel.title)
}
inline ::std::string* AnnouncementModel::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AnnouncementModel.title)
  return title_;
}
inline ::std::string* AnnouncementModel::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnnouncementModel::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AnnouncementModel.title)
}

// optional string content = 2;
inline bool AnnouncementModel::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnouncementModel::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnouncementModel::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnouncementModel::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AnnouncementModel::content() const {
  // @@protoc_insertion_point(field_get:main.AnnouncementModel.content)
  return *content_;
}
inline void AnnouncementModel::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:main.AnnouncementModel.content)
}
inline void AnnouncementModel::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AnnouncementModel.content)
}
inline void AnnouncementModel::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AnnouncementModel.content)
}
inline ::std::string* AnnouncementModel::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AnnouncementModel.content)
  return content_;
}
inline ::std::string* AnnouncementModel::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnnouncementModel::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AnnouncementModel.content)
}

// optional string url = 3;
inline bool AnnouncementModel::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnouncementModel::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnnouncementModel::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnnouncementModel::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AnnouncementModel::url() const {
  // @@protoc_insertion_point(field_get:main.AnnouncementModel.url)
  return *url_;
}
inline void AnnouncementModel::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:main.AnnouncementModel.url)
}
inline void AnnouncementModel::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AnnouncementModel.url)
}
inline void AnnouncementModel::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AnnouncementModel.url)
}
inline ::std::string* AnnouncementModel::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AnnouncementModel.url)
  return url_;
}
inline ::std::string* AnnouncementModel::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnnouncementModel::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AnnouncementModel.url)
}

// optional int32 viewId = 4;
inline bool AnnouncementModel::has_viewid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnnouncementModel::set_has_viewid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnnouncementModel::clear_has_viewid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnnouncementModel::clear_viewid() {
  viewid_ = 0;
  clear_has_viewid();
}
inline ::google::protobuf::int32 AnnouncementModel::viewid() const {
  // @@protoc_insertion_point(field_get:main.AnnouncementModel.viewId)
  return viewid_;
}
inline void AnnouncementModel::set_viewid(::google::protobuf::int32 value) {
  set_has_viewid();
  viewid_ = value;
  // @@protoc_insertion_point(field_set:main.AnnouncementModel.viewId)
}

// -------------------------------------------------------------------

// ServerNoticeResponse

// optional int32 type = 1;
inline bool ServerNoticeResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerNoticeResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerNoticeResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerNoticeResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ServerNoticeResponse::type() const {
  // @@protoc_insertion_point(field_get:main.ServerNoticeResponse.type)
  return type_;
}
inline void ServerNoticeResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:main.ServerNoticeResponse.type)
}

// optional string content = 2;
inline bool ServerNoticeResponse::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerNoticeResponse::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerNoticeResponse::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerNoticeResponse::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ServerNoticeResponse::content() const {
  // @@protoc_insertion_point(field_get:main.ServerNoticeResponse.content)
  return *content_;
}
inline void ServerNoticeResponse::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:main.ServerNoticeResponse.content)
}
inline void ServerNoticeResponse::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ServerNoticeResponse.content)
}
inline void ServerNoticeResponse::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ServerNoticeResponse.content)
}
inline ::std::string* ServerNoticeResponse::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ServerNoticeResponse.content)
  return content_;
}
inline ::std::string* ServerNoticeResponse::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerNoticeResponse::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ServerNoticeResponse.content)
}

// -------------------------------------------------------------------

// AlanWake

// optional int32 arg1 = 1 [default = 0];
inline bool AlanWake::has_arg1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlanWake::set_has_arg1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlanWake::clear_has_arg1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlanWake::clear_arg1() {
  arg1_ = 0;
  clear_has_arg1();
}
inline ::google::protobuf::int32 AlanWake::arg1() const {
  // @@protoc_insertion_point(field_get:main.AlanWake.arg1)
  return arg1_;
}
inline void AlanWake::set_arg1(::google::protobuf::int32 value) {
  set_has_arg1();
  arg1_ = value;
  // @@protoc_insertion_point(field_set:main.AlanWake.arg1)
}

// optional string arg2 = 2 [default = ""];
inline bool AlanWake::has_arg2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlanWake::set_has_arg2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlanWake::clear_has_arg2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlanWake::clear_arg2() {
  if (arg2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg2_->clear();
  }
  clear_has_arg2();
}
inline const ::std::string& AlanWake::arg2() const {
  // @@protoc_insertion_point(field_get:main.AlanWake.arg2)
  return *arg2_;
}
inline void AlanWake::set_arg2(const ::std::string& value) {
  set_has_arg2();
  if (arg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg2_ = new ::std::string;
  }
  arg2_->assign(value);
  // @@protoc_insertion_point(field_set:main.AlanWake.arg2)
}
inline void AlanWake::set_arg2(const char* value) {
  set_has_arg2();
  if (arg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg2_ = new ::std::string;
  }
  arg2_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.AlanWake.arg2)
}
inline void AlanWake::set_arg2(const char* value, size_t size) {
  set_has_arg2();
  if (arg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg2_ = new ::std::string;
  }
  arg2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.AlanWake.arg2)
}
inline ::std::string* AlanWake::mutable_arg2() {
  set_has_arg2();
  if (arg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.AlanWake.arg2)
  return arg2_;
}
inline ::std::string* AlanWake::release_arg2() {
  clear_has_arg2();
  if (arg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = arg2_;
    arg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AlanWake::set_allocated_arg2(::std::string* arg2) {
  if (arg2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete arg2_;
  }
  if (arg2) {
    set_has_arg2();
    arg2_ = arg2;
  } else {
    clear_has_arg2();
    arg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.AlanWake.arg2)
}

// -------------------------------------------------------------------

// ShowCommonMessage

// required string msg = 1;
inline bool ShowCommonMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShowCommonMessage::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShowCommonMessage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShowCommonMessage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ShowCommonMessage::msg() const {
  // @@protoc_insertion_point(field_get:main.ShowCommonMessage.msg)
  return *msg_;
}
inline void ShowCommonMessage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:main.ShowCommonMessage.msg)
}
inline void ShowCommonMessage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ShowCommonMessage.msg)
}
inline void ShowCommonMessage::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ShowCommonMessage.msg)
}
inline ::std::string* ShowCommonMessage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ShowCommonMessage.msg)
  return msg_;
}
inline ::std::string* ShowCommonMessage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShowCommonMessage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ShowCommonMessage.msg)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ServerMoving_2eproto__INCLUDED

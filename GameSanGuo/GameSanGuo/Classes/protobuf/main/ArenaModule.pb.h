// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ArenaModule.proto

#ifndef PROTOBUF_ArenaModule_2eproto__INCLUDED
#define PROTOBUF_ArenaModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace main {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ArenaModule_2eproto();
void protobuf_AssignDesc_ArenaModule_2eproto();
void protobuf_ShutdownFile_ArenaModule_2eproto();

class ArenaMainInfoRequest;
class ArenaMainInfoResponse;
class ArenaFightReportRequest;
class ArenaFightReportResponse;
class ArenaRanksRequest;
class ArenaRanksResponse;
class ArenaStartRequest;
class ArenaStartResponse;
class ArenaEndFightRequest;
class ArenaEndFightResponse;
class ArenaGetRewardRequest;
class ArenaGetRewardResponse;
class ArenaBuyFightCountRequest;
class ArenaBuyFightCountResponse;
class ArenaFightReport;
class ArenaBaseInfo;
class ArenaRoleInfo;

// ===================================================================

class ArenaMainInfoRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaMainInfoRequest();
  virtual ~ArenaMainInfoRequest();

  ArenaMainInfoRequest(const ArenaMainInfoRequest& from);

  inline ArenaMainInfoRequest& operator=(const ArenaMainInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaMainInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaMainInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaMainInfoRequest* other);

  // implements Message ----------------------------------------------

  ArenaMainInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaMainInfoRequest& from);
  void MergeFrom(const ArenaMainInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ArenaMainInfoRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaMainInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaMainInfoResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaMainInfoResponse();
  virtual ~ArenaMainInfoResponse();

  ArenaMainInfoResponse(const ArenaMainInfoResponse& from);

  inline ArenaMainInfoResponse& operator=(const ArenaMainInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaMainInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaMainInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaMainInfoResponse* other);

  // implements Message ----------------------------------------------

  ArenaMainInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaMainInfoResponse& from);
  void MergeFrom(const ArenaMainInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .main.ArenaBaseInfo baseInfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  inline const ::main::ArenaBaseInfo& baseinfo() const;
  inline ::main::ArenaBaseInfo* mutable_baseinfo();
  inline ::main::ArenaBaseInfo* release_baseinfo();
  inline void set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo);

  // required .main.ArenaRoleInfo selfInfo = 2;
  inline bool has_selfinfo() const;
  inline void clear_selfinfo();
  static const int kSelfInfoFieldNumber = 2;
  inline const ::main::ArenaRoleInfo& selfinfo() const;
  inline ::main::ArenaRoleInfo* mutable_selfinfo();
  inline ::main::ArenaRoleInfo* release_selfinfo();
  inline void set_allocated_selfinfo(::main::ArenaRoleInfo* selfinfo);

  // repeated .main.ArenaRoleInfo matchList = 3;
  inline int matchlist_size() const;
  inline void clear_matchlist();
  static const int kMatchListFieldNumber = 3;
  inline const ::main::ArenaRoleInfo& matchlist(int index) const;
  inline ::main::ArenaRoleInfo* mutable_matchlist(int index);
  inline ::main::ArenaRoleInfo* add_matchlist();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >&
      matchlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >*
      mutable_matchlist();

  // @@protoc_insertion_point(class_scope:main.ArenaMainInfoResponse)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_selfinfo();
  inline void clear_has_selfinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::ArenaBaseInfo* baseinfo_;
  ::main::ArenaRoleInfo* selfinfo_;
  ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo > matchlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaMainInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaFightReportRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaFightReportRequest();
  virtual ~ArenaFightReportRequest();

  ArenaFightReportRequest(const ArenaFightReportRequest& from);

  inline ArenaFightReportRequest& operator=(const ArenaFightReportRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaFightReportRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaFightReportRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaFightReportRequest* other);

  // implements Message ----------------------------------------------

  ArenaFightReportRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaFightReportRequest& from);
  void MergeFrom(const ArenaFightReportRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ArenaFightReportRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaFightReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaFightReportResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaFightReportResponse();
  virtual ~ArenaFightReportResponse();

  ArenaFightReportResponse(const ArenaFightReportResponse& from);

  inline ArenaFightReportResponse& operator=(const ArenaFightReportResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaFightReportResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaFightReportResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaFightReportResponse* other);

  // implements Message ----------------------------------------------

  ArenaFightReportResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaFightReportResponse& from);
  void MergeFrom(const ArenaFightReportResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .main.ArenaBaseInfo baseInfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  inline const ::main::ArenaBaseInfo& baseinfo() const;
  inline ::main::ArenaBaseInfo* mutable_baseinfo();
  inline ::main::ArenaBaseInfo* release_baseinfo();
  inline void set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo);

  // repeated .main.ArenaFightReport reportList = 2;
  inline int reportlist_size() const;
  inline void clear_reportlist();
  static const int kReportListFieldNumber = 2;
  inline const ::main::ArenaFightReport& reportlist(int index) const;
  inline ::main::ArenaFightReport* mutable_reportlist(int index);
  inline ::main::ArenaFightReport* add_reportlist();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaFightReport >&
      reportlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ArenaFightReport >*
      mutable_reportlist();

  // @@protoc_insertion_point(class_scope:main.ArenaFightReportResponse)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::ArenaBaseInfo* baseinfo_;
  ::google::protobuf::RepeatedPtrField< ::main::ArenaFightReport > reportlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaFightReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaRanksRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaRanksRequest();
  virtual ~ArenaRanksRequest();

  ArenaRanksRequest(const ArenaRanksRequest& from);

  inline ArenaRanksRequest& operator=(const ArenaRanksRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaRanksRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaRanksRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaRanksRequest* other);

  // implements Message ----------------------------------------------

  ArenaRanksRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaRanksRequest& from);
  void MergeFrom(const ArenaRanksRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ArenaRanksRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaRanksRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaRanksResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaRanksResponse();
  virtual ~ArenaRanksResponse();

  ArenaRanksResponse(const ArenaRanksResponse& from);

  inline ArenaRanksResponse& operator=(const ArenaRanksResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaRanksResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaRanksResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaRanksResponse* other);

  // implements Message ----------------------------------------------

  ArenaRanksResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaRanksResponse& from);
  void MergeFrom(const ArenaRanksResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .main.ArenaBaseInfo baseInfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  inline const ::main::ArenaBaseInfo& baseinfo() const;
  inline ::main::ArenaBaseInfo* mutable_baseinfo();
  inline ::main::ArenaBaseInfo* release_baseinfo();
  inline void set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo);

  // required .main.ArenaRoleInfo selfInfo = 2;
  inline bool has_selfinfo() const;
  inline void clear_selfinfo();
  static const int kSelfInfoFieldNumber = 2;
  inline const ::main::ArenaRoleInfo& selfinfo() const;
  inline ::main::ArenaRoleInfo* mutable_selfinfo();
  inline ::main::ArenaRoleInfo* release_selfinfo();
  inline void set_allocated_selfinfo(::main::ArenaRoleInfo* selfinfo);

  // repeated .main.ArenaRoleInfo ranks = 3;
  inline int ranks_size() const;
  inline void clear_ranks();
  static const int kRanksFieldNumber = 3;
  inline const ::main::ArenaRoleInfo& ranks(int index) const;
  inline ::main::ArenaRoleInfo* mutable_ranks(int index);
  inline ::main::ArenaRoleInfo* add_ranks();
  inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >&
      ranks() const;
  inline ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >*
      mutable_ranks();

  // @@protoc_insertion_point(class_scope:main.ArenaRanksResponse)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_selfinfo();
  inline void clear_has_selfinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::main::ArenaBaseInfo* baseinfo_;
  ::main::ArenaRoleInfo* selfinfo_;
  ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo > ranks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaRanksResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaStartRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaStartRequest();
  virtual ~ArenaStartRequest();

  ArenaStartRequest(const ArenaStartRequest& from);

  inline ArenaStartRequest& operator=(const ArenaStartRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaStartRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaStartRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaStartRequest* other);

  // implements Message ----------------------------------------------

  ArenaStartRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaStartRequest& from);
  void MergeFrom(const ArenaStartRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaStartRequest)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 rank_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaStartRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaStartResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaStartResponse();
  virtual ~ArenaStartResponse();

  ArenaStartResponse(const ArenaStartResponse& from);

  inline ArenaStartResponse& operator=(const ArenaStartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaStartResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaStartResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaStartResponse* other);

  // implements Message ----------------------------------------------

  ArenaStartResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaStartResponse& from);
  void MergeFrom(const ArenaStartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 gold = 3;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 3;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 surplusBuyCount = 4;
  inline bool has_surplusbuycount() const;
  inline void clear_surplusbuycount();
  static const int kSurplusBuyCountFieldNumber = 4;
  inline ::google::protobuf::int32 surplusbuycount() const;
  inline void set_surplusbuycount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaStartResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_surplusbuycount();
  inline void clear_has_surplusbuycount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 surplusbuycount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaStartResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaEndFightRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaEndFightRequest();
  virtual ~ArenaEndFightRequest();

  ArenaEndFightRequest(const ArenaEndFightRequest& from);

  inline ArenaEndFightRequest& operator=(const ArenaEndFightRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaEndFightRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaEndFightRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaEndFightRequest* other);

  // implements Message ----------------------------------------------

  ArenaEndFightRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaEndFightRequest& from);
  void MergeFrom(const ArenaEndFightRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool quick = 1;
  inline bool has_quick() const;
  inline void clear_quick();
  static const int kQuickFieldNumber = 1;
  inline bool quick() const;
  inline void set_quick(bool value);

  // optional bool isWin = 2;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 2;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // @@protoc_insertion_point(class_scope:main.ArenaEndFightRequest)
 private:
  inline void set_has_quick();
  inline void clear_has_quick();
  inline void set_has_iswin();
  inline void clear_has_iswin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool quick_;
  bool iswin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaEndFightRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaEndFightResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaEndFightResponse();
  virtual ~ArenaEndFightResponse();

  ArenaEndFightResponse(const ArenaEndFightResponse& from);

  inline ArenaEndFightResponse& operator=(const ArenaEndFightResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaEndFightResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaEndFightResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaEndFightResponse* other);

  // implements Message ----------------------------------------------

  ArenaEndFightResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaEndFightResponse& from);
  void MergeFrom(const ArenaEndFightResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isWin = 1;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 1;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // required int32 beforeRank = 2;
  inline bool has_beforerank() const;
  inline void clear_beforerank();
  static const int kBeforeRankFieldNumber = 2;
  inline ::google::protobuf::int32 beforerank() const;
  inline void set_beforerank(::google::protobuf::int32 value);

  // required int32 afterRank = 3;
  inline bool has_afterrank() const;
  inline void clear_afterrank();
  static const int kAfterRankFieldNumber = 3;
  inline ::google::protobuf::int32 afterrank() const;
  inline void set_afterrank(::google::protobuf::int32 value);

  // required int32 coins = 4;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 4;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // required int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 maxCount = 6;
  inline bool has_maxcount() const;
  inline void clear_maxcount();
  static const int kMaxCountFieldNumber = 6;
  inline ::google::protobuf::int32 maxcount() const;
  inline void set_maxcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaEndFightResponse)
 private:
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_beforerank();
  inline void clear_has_beforerank();
  inline void set_has_afterrank();
  inline void clear_has_afterrank();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_maxcount();
  inline void clear_has_maxcount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool iswin_;
  ::google::protobuf::int32 beforerank_;
  ::google::protobuf::int32 afterrank_;
  ::google::protobuf::int32 coins_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 maxcount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaEndFightResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaGetRewardRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaGetRewardRequest();
  virtual ~ArenaGetRewardRequest();

  ArenaGetRewardRequest(const ArenaGetRewardRequest& from);

  inline ArenaGetRewardRequest& operator=(const ArenaGetRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaGetRewardRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaGetRewardRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaGetRewardRequest* other);

  // implements Message ----------------------------------------------

  ArenaGetRewardRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaGetRewardRequest& from);
  void MergeFrom(const ArenaGetRewardRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ArenaGetRewardRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaGetRewardRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaGetRewardResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaGetRewardResponse();
  virtual ~ArenaGetRewardResponse();

  ArenaGetRewardResponse(const ArenaGetRewardResponse& from);

  inline ArenaGetRewardResponse& operator=(const ArenaGetRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaGetRewardResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaGetRewardResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaGetRewardResponse* other);

  // implements Message ----------------------------------------------

  ArenaGetRewardResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaGetRewardResponse& from);
  void MergeFrom(const ArenaGetRewardResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // required int32 zhengfudian = 2;
  inline bool has_zhengfudian() const;
  inline void clear_zhengfudian();
  static const int kZhengfudianFieldNumber = 2;
  inline ::google::protobuf::int32 zhengfudian() const;
  inline void set_zhengfudian(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaGetRewardResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_zhengfudian();
  inline void clear_has_zhengfudian();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 zhengfudian_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaGetRewardResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaBuyFightCountRequest : public ::google::protobuf::MessageLite {
 public:
  ArenaBuyFightCountRequest();
  virtual ~ArenaBuyFightCountRequest();

  ArenaBuyFightCountRequest(const ArenaBuyFightCountRequest& from);

  inline ArenaBuyFightCountRequest& operator=(const ArenaBuyFightCountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaBuyFightCountRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaBuyFightCountRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaBuyFightCountRequest* other);

  // implements Message ----------------------------------------------

  ArenaBuyFightCountRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaBuyFightCountRequest& from);
  void MergeFrom(const ArenaBuyFightCountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:main.ArenaBuyFightCountRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaBuyFightCountRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArenaBuyFightCountResponse : public ::google::protobuf::MessageLite {
 public:
  ArenaBuyFightCountResponse();
  virtual ~ArenaBuyFightCountResponse();

  ArenaBuyFightCountResponse(const ArenaBuyFightCountResponse& from);

  inline ArenaBuyFightCountResponse& operator=(const ArenaBuyFightCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaBuyFightCountResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaBuyFightCountResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaBuyFightCountResponse* other);

  // implements Message ----------------------------------------------

  ArenaBuyFightCountResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaBuyFightCountResponse& from);
  void MergeFrom(const ArenaBuyFightCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:main.ArenaBuyFightCountResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaBuyFightCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class ArenaFightReport : public ::google::protobuf::MessageLite {
 public:
  ArenaFightReport();
  virtual ~ArenaFightReport();

  ArenaFightReport(const ArenaFightReport& from);

  inline ArenaFightReport& operator=(const ArenaFightReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaFightReport& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaFightReport* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaFightReport* other);

  // implements Message ----------------------------------------------

  ArenaFightReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaFightReport& from);
  void MergeFrom(const ArenaFightReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // required string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int32 nationId = 3;
  inline bool has_nationid() const;
  inline void clear_nationid();
  static const int kNationIdFieldNumber = 3;
  inline ::google::protobuf::int32 nationid() const;
  inline void set_nationid(::google::protobuf::int32 value);

  // required int32 officeItemId = 4;
  inline bool has_officeitemid() const;
  inline void clear_officeitemid();
  static const int kOfficeItemIdFieldNumber = 4;
  inline ::google::protobuf::int32 officeitemid() const;
  inline void set_officeitemid(::google::protobuf::int32 value);

  // required int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 beforeRank = 6;
  inline bool has_beforerank() const;
  inline void clear_beforerank();
  static const int kBeforeRankFieldNumber = 6;
  inline ::google::protobuf::int32 beforerank() const;
  inline void set_beforerank(::google::protobuf::int32 value);

  // required int32 afterRank = 7;
  inline bool has_afterrank() const;
  inline void clear_afterrank();
  static const int kAfterRankFieldNumber = 7;
  inline ::google::protobuf::int32 afterrank() const;
  inline void set_afterrank(::google::protobuf::int32 value);

  // required bool isWin = 8 [default = false];
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 8;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // required bool isAttact = 9 [default = false];
  inline bool has_isattact() const;
  inline void clear_isattact();
  static const int kIsAttactFieldNumber = 9;
  inline bool isattact() const;
  inline void set_isattact(bool value);

  // required int64 time = 10;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 10;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:main.ArenaFightReport)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_nationid();
  inline void clear_has_nationid();
  inline void set_has_officeitemid();
  inline void clear_has_officeitemid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_beforerank();
  inline void clear_has_beforerank();
  inline void set_has_afterrank();
  inline void clear_has_afterrank();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_isattact();
  inline void clear_has_isattact();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 nationid_;
  ::google::protobuf::int32 officeitemid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 beforerank_;
  ::google::protobuf::int32 afterrank_;
  ::google::protobuf::int64 time_;
  bool iswin_;
  bool isattact_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaFightReport* default_instance_;
};
// -------------------------------------------------------------------

class ArenaBaseInfo : public ::google::protobuf::MessageLite {
 public:
  ArenaBaseInfo();
  virtual ~ArenaBaseInfo();

  ArenaBaseInfo(const ArenaBaseInfo& from);

  inline ArenaBaseInfo& operator=(const ArenaBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaBaseInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaBaseInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaBaseInfo* other);

  // implements Message ----------------------------------------------

  ArenaBaseInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaBaseInfo& from);
  void MergeFrom(const ArenaBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 zhengfudian = 1;
  inline bool has_zhengfudian() const;
  inline void clear_zhengfudian();
  static const int kZhengfudianFieldNumber = 1;
  inline ::google::protobuf::int32 zhengfudian() const;
  inline void set_zhengfudian(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 maxCount = 3;
  inline bool has_maxcount() const;
  inline void clear_maxcount();
  static const int kMaxCountFieldNumber = 3;
  inline ::google::protobuf::int32 maxcount() const;
  inline void set_maxcount(::google::protobuf::int32 value);

  // required string info = 4;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // required int64 surplusTime = 5;
  inline bool has_surplustime() const;
  inline void clear_surplustime();
  static const int kSurplusTimeFieldNumber = 5;
  inline ::google::protobuf::int64 surplustime() const;
  inline void set_surplustime(::google::protobuf::int64 value);

  // required int64 canRewardCount = 6;
  inline bool has_canrewardcount() const;
  inline void clear_canrewardcount();
  static const int kCanRewardCountFieldNumber = 6;
  inline ::google::protobuf::int64 canrewardcount() const;
  inline void set_canrewardcount(::google::protobuf::int64 value);

  // required int32 cdTime = 7;
  inline bool has_cdtime() const;
  inline void clear_cdtime();
  static const int kCdTimeFieldNumber = 7;
  inline ::google::protobuf::int32 cdtime() const;
  inline void set_cdtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaBaseInfo)
 private:
  inline void set_has_zhengfudian();
  inline void clear_has_zhengfudian();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_maxcount();
  inline void clear_has_maxcount();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_surplustime();
  inline void clear_has_surplustime();
  inline void set_has_canrewardcount();
  inline void clear_has_canrewardcount();
  inline void set_has_cdtime();
  inline void clear_has_cdtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 zhengfudian_;
  ::google::protobuf::int32 count_;
  ::std::string* info_;
  ::google::protobuf::int64 surplustime_;
  ::google::protobuf::int32 maxcount_;
  ::google::protobuf::int32 cdtime_;
  ::google::protobuf::int64 canrewardcount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaRoleInfo : public ::google::protobuf::MessageLite {
 public:
  ArenaRoleInfo();
  virtual ~ArenaRoleInfo();

  ArenaRoleInfo(const ArenaRoleInfo& from);

  inline ArenaRoleInfo& operator=(const ArenaRoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ArenaRoleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaRoleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaRoleInfo* other);

  // implements Message ----------------------------------------------

  ArenaRoleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaRoleInfo& from);
  void MergeFrom(const ArenaRoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // required string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int32 nationId = 3;
  inline bool has_nationid() const;
  inline void clear_nationid();
  static const int kNationIdFieldNumber = 3;
  inline ::google::protobuf::int32 nationid() const;
  inline void set_nationid(::google::protobuf::int32 value);

  // required int32 officeItemId = 4;
  inline bool has_officeitemid() const;
  inline void clear_officeitemid();
  static const int kOfficeItemIdFieldNumber = 4;
  inline ::google::protobuf::int32 officeitemid() const;
  inline void set_officeitemid(::google::protobuf::int32 value);

  // required int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 rank = 6;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 6;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // required int32 combatValue = 7;
  inline bool has_combatvalue() const;
  inline void clear_combatvalue();
  static const int kCombatValueFieldNumber = 7;
  inline ::google::protobuf::int32 combatvalue() const;
  inline void set_combatvalue(::google::protobuf::int32 value);

  // required int32 zhengfudian = 8;
  inline bool has_zhengfudian() const;
  inline void clear_zhengfudian();
  static const int kZhengfudianFieldNumber = 8;
  inline ::google::protobuf::int32 zhengfudian() const;
  inline void set_zhengfudian(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:main.ArenaRoleInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_nationid();
  inline void clear_has_nationid();
  inline void set_has_officeitemid();
  inline void clear_has_officeitemid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_combatvalue();
  inline void clear_has_combatvalue();
  inline void set_has_zhengfudian();
  inline void clear_has_zhengfudian();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 nationid_;
  ::google::protobuf::int32 officeitemid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 combatvalue_;
  ::google::protobuf::int32 zhengfudian_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ArenaModule_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ArenaModule_2eproto();
  #endif
  friend void protobuf_AssignDesc_ArenaModule_2eproto();
  friend void protobuf_ShutdownFile_ArenaModule_2eproto();

  void InitAsDefaultInstance();
  static ArenaRoleInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ArenaMainInfoRequest

// -------------------------------------------------------------------

// ArenaMainInfoResponse

// required .main.ArenaBaseInfo baseInfo = 1;
inline bool ArenaMainInfoResponse::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaMainInfoResponse::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaMainInfoResponse::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaMainInfoResponse::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::main::ArenaBaseInfo::Clear();
  clear_has_baseinfo();
}
inline const ::main::ArenaBaseInfo& ArenaMainInfoResponse::baseinfo() const {
  // @@protoc_insertion_point(field_get:main.ArenaMainInfoResponse.baseInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance().baseinfo_;
#else
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
#endif
}
inline ::main::ArenaBaseInfo* ArenaMainInfoResponse::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::main::ArenaBaseInfo;
  // @@protoc_insertion_point(field_mutable:main.ArenaMainInfoResponse.baseInfo)
  return baseinfo_;
}
inline ::main::ArenaBaseInfo* ArenaMainInfoResponse::release_baseinfo() {
  clear_has_baseinfo();
  ::main::ArenaBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void ArenaMainInfoResponse::set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaMainInfoResponse.baseInfo)
}

// required .main.ArenaRoleInfo selfInfo = 2;
inline bool ArenaMainInfoResponse::has_selfinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaMainInfoResponse::set_has_selfinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaMainInfoResponse::clear_has_selfinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaMainInfoResponse::clear_selfinfo() {
  if (selfinfo_ != NULL) selfinfo_->::main::ArenaRoleInfo::Clear();
  clear_has_selfinfo();
}
inline const ::main::ArenaRoleInfo& ArenaMainInfoResponse::selfinfo() const {
  // @@protoc_insertion_point(field_get:main.ArenaMainInfoResponse.selfInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selfinfo_ != NULL ? *selfinfo_ : *default_instance().selfinfo_;
#else
  return selfinfo_ != NULL ? *selfinfo_ : *default_instance_->selfinfo_;
#endif
}
inline ::main::ArenaRoleInfo* ArenaMainInfoResponse::mutable_selfinfo() {
  set_has_selfinfo();
  if (selfinfo_ == NULL) selfinfo_ = new ::main::ArenaRoleInfo;
  // @@protoc_insertion_point(field_mutable:main.ArenaMainInfoResponse.selfInfo)
  return selfinfo_;
}
inline ::main::ArenaRoleInfo* ArenaMainInfoResponse::release_selfinfo() {
  clear_has_selfinfo();
  ::main::ArenaRoleInfo* temp = selfinfo_;
  selfinfo_ = NULL;
  return temp;
}
inline void ArenaMainInfoResponse::set_allocated_selfinfo(::main::ArenaRoleInfo* selfinfo) {
  delete selfinfo_;
  selfinfo_ = selfinfo;
  if (selfinfo) {
    set_has_selfinfo();
  } else {
    clear_has_selfinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaMainInfoResponse.selfInfo)
}

// repeated .main.ArenaRoleInfo matchList = 3;
inline int ArenaMainInfoResponse::matchlist_size() const {
  return matchlist_.size();
}
inline void ArenaMainInfoResponse::clear_matchlist() {
  matchlist_.Clear();
}
inline const ::main::ArenaRoleInfo& ArenaMainInfoResponse::matchlist(int index) const {
  // @@protoc_insertion_point(field_get:main.ArenaMainInfoResponse.matchList)
  return matchlist_.Get(index);
}
inline ::main::ArenaRoleInfo* ArenaMainInfoResponse::mutable_matchlist(int index) {
  // @@protoc_insertion_point(field_mutable:main.ArenaMainInfoResponse.matchList)
  return matchlist_.Mutable(index);
}
inline ::main::ArenaRoleInfo* ArenaMainInfoResponse::add_matchlist() {
  // @@protoc_insertion_point(field_add:main.ArenaMainInfoResponse.matchList)
  return matchlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >&
ArenaMainInfoResponse::matchlist() const {
  // @@protoc_insertion_point(field_list:main.ArenaMainInfoResponse.matchList)
  return matchlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >*
ArenaMainInfoResponse::mutable_matchlist() {
  // @@protoc_insertion_point(field_mutable_list:main.ArenaMainInfoResponse.matchList)
  return &matchlist_;
}

// -------------------------------------------------------------------

// ArenaFightReportRequest

// -------------------------------------------------------------------

// ArenaFightReportResponse

// required .main.ArenaBaseInfo baseInfo = 1;
inline bool ArenaFightReportResponse::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaFightReportResponse::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaFightReportResponse::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaFightReportResponse::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::main::ArenaBaseInfo::Clear();
  clear_has_baseinfo();
}
inline const ::main::ArenaBaseInfo& ArenaFightReportResponse::baseinfo() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReportResponse.baseInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance().baseinfo_;
#else
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
#endif
}
inline ::main::ArenaBaseInfo* ArenaFightReportResponse::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::main::ArenaBaseInfo;
  // @@protoc_insertion_point(field_mutable:main.ArenaFightReportResponse.baseInfo)
  return baseinfo_;
}
inline ::main::ArenaBaseInfo* ArenaFightReportResponse::release_baseinfo() {
  clear_has_baseinfo();
  ::main::ArenaBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void ArenaFightReportResponse::set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaFightReportResponse.baseInfo)
}

// repeated .main.ArenaFightReport reportList = 2;
inline int ArenaFightReportResponse::reportlist_size() const {
  return reportlist_.size();
}
inline void ArenaFightReportResponse::clear_reportlist() {
  reportlist_.Clear();
}
inline const ::main::ArenaFightReport& ArenaFightReportResponse::reportlist(int index) const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReportResponse.reportList)
  return reportlist_.Get(index);
}
inline ::main::ArenaFightReport* ArenaFightReportResponse::mutable_reportlist(int index) {
  // @@protoc_insertion_point(field_mutable:main.ArenaFightReportResponse.reportList)
  return reportlist_.Mutable(index);
}
inline ::main::ArenaFightReport* ArenaFightReportResponse::add_reportlist() {
  // @@protoc_insertion_point(field_add:main.ArenaFightReportResponse.reportList)
  return reportlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaFightReport >&
ArenaFightReportResponse::reportlist() const {
  // @@protoc_insertion_point(field_list:main.ArenaFightReportResponse.reportList)
  return reportlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ArenaFightReport >*
ArenaFightReportResponse::mutable_reportlist() {
  // @@protoc_insertion_point(field_mutable_list:main.ArenaFightReportResponse.reportList)
  return &reportlist_;
}

// -------------------------------------------------------------------

// ArenaRanksRequest

// -------------------------------------------------------------------

// ArenaRanksResponse

// required .main.ArenaBaseInfo baseInfo = 1;
inline bool ArenaRanksResponse::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaRanksResponse::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaRanksResponse::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaRanksResponse::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::main::ArenaBaseInfo::Clear();
  clear_has_baseinfo();
}
inline const ::main::ArenaBaseInfo& ArenaRanksResponse::baseinfo() const {
  // @@protoc_insertion_point(field_get:main.ArenaRanksResponse.baseInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance().baseinfo_;
#else
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
#endif
}
inline ::main::ArenaBaseInfo* ArenaRanksResponse::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::main::ArenaBaseInfo;
  // @@protoc_insertion_point(field_mutable:main.ArenaRanksResponse.baseInfo)
  return baseinfo_;
}
inline ::main::ArenaBaseInfo* ArenaRanksResponse::release_baseinfo() {
  clear_has_baseinfo();
  ::main::ArenaBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void ArenaRanksResponse::set_allocated_baseinfo(::main::ArenaBaseInfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaRanksResponse.baseInfo)
}

// required .main.ArenaRoleInfo selfInfo = 2;
inline bool ArenaRanksResponse::has_selfinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaRanksResponse::set_has_selfinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaRanksResponse::clear_has_selfinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaRanksResponse::clear_selfinfo() {
  if (selfinfo_ != NULL) selfinfo_->::main::ArenaRoleInfo::Clear();
  clear_has_selfinfo();
}
inline const ::main::ArenaRoleInfo& ArenaRanksResponse::selfinfo() const {
  // @@protoc_insertion_point(field_get:main.ArenaRanksResponse.selfInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selfinfo_ != NULL ? *selfinfo_ : *default_instance().selfinfo_;
#else
  return selfinfo_ != NULL ? *selfinfo_ : *default_instance_->selfinfo_;
#endif
}
inline ::main::ArenaRoleInfo* ArenaRanksResponse::mutable_selfinfo() {
  set_has_selfinfo();
  if (selfinfo_ == NULL) selfinfo_ = new ::main::ArenaRoleInfo;
  // @@protoc_insertion_point(field_mutable:main.ArenaRanksResponse.selfInfo)
  return selfinfo_;
}
inline ::main::ArenaRoleInfo* ArenaRanksResponse::release_selfinfo() {
  clear_has_selfinfo();
  ::main::ArenaRoleInfo* temp = selfinfo_;
  selfinfo_ = NULL;
  return temp;
}
inline void ArenaRanksResponse::set_allocated_selfinfo(::main::ArenaRoleInfo* selfinfo) {
  delete selfinfo_;
  selfinfo_ = selfinfo;
  if (selfinfo) {
    set_has_selfinfo();
  } else {
    clear_has_selfinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaRanksResponse.selfInfo)
}

// repeated .main.ArenaRoleInfo ranks = 3;
inline int ArenaRanksResponse::ranks_size() const {
  return ranks_.size();
}
inline void ArenaRanksResponse::clear_ranks() {
  ranks_.Clear();
}
inline const ::main::ArenaRoleInfo& ArenaRanksResponse::ranks(int index) const {
  // @@protoc_insertion_point(field_get:main.ArenaRanksResponse.ranks)
  return ranks_.Get(index);
}
inline ::main::ArenaRoleInfo* ArenaRanksResponse::mutable_ranks(int index) {
  // @@protoc_insertion_point(field_mutable:main.ArenaRanksResponse.ranks)
  return ranks_.Mutable(index);
}
inline ::main::ArenaRoleInfo* ArenaRanksResponse::add_ranks() {
  // @@protoc_insertion_point(field_add:main.ArenaRanksResponse.ranks)
  return ranks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >&
ArenaRanksResponse::ranks() const {
  // @@protoc_insertion_point(field_list:main.ArenaRanksResponse.ranks)
  return ranks_;
}
inline ::google::protobuf::RepeatedPtrField< ::main::ArenaRoleInfo >*
ArenaRanksResponse::mutable_ranks() {
  // @@protoc_insertion_point(field_mutable_list:main.ArenaRanksResponse.ranks)
  return &ranks_;
}

// -------------------------------------------------------------------

// ArenaStartRequest

// required int32 rank = 1;
inline bool ArenaStartRequest::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaStartRequest::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaStartRequest::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaStartRequest::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ArenaStartRequest::rank() const {
  // @@protoc_insertion_point(field_get:main.ArenaStartRequest.rank)
  return rank_;
}
inline void ArenaStartRequest::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaStartRequest.rank)
}

// -------------------------------------------------------------------

// ArenaStartResponse

// required int32 state = 1;
inline bool ArenaStartResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaStartResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaStartResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaStartResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ArenaStartResponse::state() const {
  // @@protoc_insertion_point(field_get:main.ArenaStartResponse.state)
  return state_;
}
inline void ArenaStartResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaStartResponse.state)
}

// optional string msg = 2;
inline bool ArenaStartResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaStartResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaStartResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaStartResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ArenaStartResponse::msg() const {
  // @@protoc_insertion_point(field_get:main.ArenaStartResponse.msg)
  return *msg_;
}
inline void ArenaStartResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:main.ArenaStartResponse.msg)
}
inline void ArenaStartResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ArenaStartResponse.msg)
}
inline void ArenaStartResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ArenaStartResponse.msg)
}
inline ::std::string* ArenaStartResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ArenaStartResponse.msg)
  return msg_;
}
inline ::std::string* ArenaStartResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArenaStartResponse::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaStartResponse.msg)
}

// optional int32 gold = 3;
inline bool ArenaStartResponse::has_gold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaStartResponse::set_has_gold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaStartResponse::clear_has_gold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaStartResponse::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 ArenaStartResponse::gold() const {
  // @@protoc_insertion_point(field_get:main.ArenaStartResponse.gold)
  return gold_;
}
inline void ArenaStartResponse::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaStartResponse.gold)
}

// optional int32 surplusBuyCount = 4;
inline bool ArenaStartResponse::has_surplusbuycount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaStartResponse::set_has_surplusbuycount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaStartResponse::clear_has_surplusbuycount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaStartResponse::clear_surplusbuycount() {
  surplusbuycount_ = 0;
  clear_has_surplusbuycount();
}
inline ::google::protobuf::int32 ArenaStartResponse::surplusbuycount() const {
  // @@protoc_insertion_point(field_get:main.ArenaStartResponse.surplusBuyCount)
  return surplusbuycount_;
}
inline void ArenaStartResponse::set_surplusbuycount(::google::protobuf::int32 value) {
  set_has_surplusbuycount();
  surplusbuycount_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaStartResponse.surplusBuyCount)
}

// -------------------------------------------------------------------

// ArenaEndFightRequest

// required bool quick = 1;
inline bool ArenaEndFightRequest::has_quick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaEndFightRequest::set_has_quick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaEndFightRequest::clear_has_quick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaEndFightRequest::clear_quick() {
  quick_ = false;
  clear_has_quick();
}
inline bool ArenaEndFightRequest::quick() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightRequest.quick)
  return quick_;
}
inline void ArenaEndFightRequest::set_quick(bool value) {
  set_has_quick();
  quick_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightRequest.quick)
}

// optional bool isWin = 2;
inline bool ArenaEndFightRequest::has_iswin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaEndFightRequest::set_has_iswin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaEndFightRequest::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaEndFightRequest::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool ArenaEndFightRequest::iswin() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightRequest.isWin)
  return iswin_;
}
inline void ArenaEndFightRequest::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightRequest.isWin)
}

// -------------------------------------------------------------------

// ArenaEndFightResponse

// required bool isWin = 1;
inline bool ArenaEndFightResponse::has_iswin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaEndFightResponse::set_has_iswin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaEndFightResponse::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaEndFightResponse::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool ArenaEndFightResponse::iswin() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.isWin)
  return iswin_;
}
inline void ArenaEndFightResponse::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.isWin)
}

// required int32 beforeRank = 2;
inline bool ArenaEndFightResponse::has_beforerank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaEndFightResponse::set_has_beforerank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaEndFightResponse::clear_has_beforerank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaEndFightResponse::clear_beforerank() {
  beforerank_ = 0;
  clear_has_beforerank();
}
inline ::google::protobuf::int32 ArenaEndFightResponse::beforerank() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.beforeRank)
  return beforerank_;
}
inline void ArenaEndFightResponse::set_beforerank(::google::protobuf::int32 value) {
  set_has_beforerank();
  beforerank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.beforeRank)
}

// required int32 afterRank = 3;
inline bool ArenaEndFightResponse::has_afterrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaEndFightResponse::set_has_afterrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaEndFightResponse::clear_has_afterrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaEndFightResponse::clear_afterrank() {
  afterrank_ = 0;
  clear_has_afterrank();
}
inline ::google::protobuf::int32 ArenaEndFightResponse::afterrank() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.afterRank)
  return afterrank_;
}
inline void ArenaEndFightResponse::set_afterrank(::google::protobuf::int32 value) {
  set_has_afterrank();
  afterrank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.afterRank)
}

// required int32 coins = 4;
inline bool ArenaEndFightResponse::has_coins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaEndFightResponse::set_has_coins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaEndFightResponse::clear_has_coins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaEndFightResponse::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 ArenaEndFightResponse::coins() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.coins)
  return coins_;
}
inline void ArenaEndFightResponse::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.coins)
}

// required int32 count = 5;
inline bool ArenaEndFightResponse::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaEndFightResponse::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaEndFightResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaEndFightResponse::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ArenaEndFightResponse::count() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.count)
  return count_;
}
inline void ArenaEndFightResponse::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.count)
}

// required int32 maxCount = 6;
inline bool ArenaEndFightResponse::has_maxcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaEndFightResponse::set_has_maxcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaEndFightResponse::clear_has_maxcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaEndFightResponse::clear_maxcount() {
  maxcount_ = 0;
  clear_has_maxcount();
}
inline ::google::protobuf::int32 ArenaEndFightResponse::maxcount() const {
  // @@protoc_insertion_point(field_get:main.ArenaEndFightResponse.maxCount)
  return maxcount_;
}
inline void ArenaEndFightResponse::set_maxcount(::google::protobuf::int32 value) {
  set_has_maxcount();
  maxcount_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaEndFightResponse.maxCount)
}

// -------------------------------------------------------------------

// ArenaGetRewardRequest

// -------------------------------------------------------------------

// ArenaGetRewardResponse

// required int32 state = 1;
inline bool ArenaGetRewardResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaGetRewardResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaGetRewardResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaGetRewardResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ArenaGetRewardResponse::state() const {
  // @@protoc_insertion_point(field_get:main.ArenaGetRewardResponse.state)
  return state_;
}
inline void ArenaGetRewardResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaGetRewardResponse.state)
}

// required int32 zhengfudian = 2;
inline bool ArenaGetRewardResponse::has_zhengfudian() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaGetRewardResponse::set_has_zhengfudian() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaGetRewardResponse::clear_has_zhengfudian() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaGetRewardResponse::clear_zhengfudian() {
  zhengfudian_ = 0;
  clear_has_zhengfudian();
}
inline ::google::protobuf::int32 ArenaGetRewardResponse::zhengfudian() const {
  // @@protoc_insertion_point(field_get:main.ArenaGetRewardResponse.zhengfudian)
  return zhengfudian_;
}
inline void ArenaGetRewardResponse::set_zhengfudian(::google::protobuf::int32 value) {
  set_has_zhengfudian();
  zhengfudian_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaGetRewardResponse.zhengfudian)
}

// -------------------------------------------------------------------

// ArenaBuyFightCountRequest

// -------------------------------------------------------------------

// ArenaBuyFightCountResponse

// required int32 state = 1;
inline bool ArenaBuyFightCountResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaBuyFightCountResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaBuyFightCountResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaBuyFightCountResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ArenaBuyFightCountResponse::state() const {
  // @@protoc_insertion_point(field_get:main.ArenaBuyFightCountResponse.state)
  return state_;
}
inline void ArenaBuyFightCountResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBuyFightCountResponse.state)
}

// optional string msg = 2;
inline bool ArenaBuyFightCountResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaBuyFightCountResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaBuyFightCountResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaBuyFightCountResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ArenaBuyFightCountResponse::msg() const {
  // @@protoc_insertion_point(field_get:main.ArenaBuyFightCountResponse.msg)
  return *msg_;
}
inline void ArenaBuyFightCountResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:main.ArenaBuyFightCountResponse.msg)
}
inline void ArenaBuyFightCountResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ArenaBuyFightCountResponse.msg)
}
inline void ArenaBuyFightCountResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ArenaBuyFightCountResponse.msg)
}
inline ::std::string* ArenaBuyFightCountResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ArenaBuyFightCountResponse.msg)
  return msg_;
}
inline ::std::string* ArenaBuyFightCountResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArenaBuyFightCountResponse::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaBuyFightCountResponse.msg)
}

// -------------------------------------------------------------------

// ArenaFightReport

// required int32 roleId = 1;
inline bool ArenaFightReport::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaFightReport::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaFightReport::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaFightReport::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 ArenaFightReport::roleid() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.roleId)
  return roleid_;
}
inline void ArenaFightReport::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.roleId)
}

// required string nickName = 2;
inline bool ArenaFightReport::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaFightReport::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaFightReport::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaFightReport::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ArenaFightReport::nickname() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.nickName)
  return *nickname_;
}
inline void ArenaFightReport::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.nickName)
}
inline void ArenaFightReport::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ArenaFightReport.nickName)
}
inline void ArenaFightReport::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ArenaFightReport.nickName)
}
inline ::std::string* ArenaFightReport::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ArenaFightReport.nickName)
  return nickname_;
}
inline ::std::string* ArenaFightReport::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArenaFightReport::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaFightReport.nickName)
}

// required int32 nationId = 3;
inline bool ArenaFightReport::has_nationid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaFightReport::set_has_nationid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaFightReport::clear_has_nationid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaFightReport::clear_nationid() {
  nationid_ = 0;
  clear_has_nationid();
}
inline ::google::protobuf::int32 ArenaFightReport::nationid() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.nationId)
  return nationid_;
}
inline void ArenaFightReport::set_nationid(::google::protobuf::int32 value) {
  set_has_nationid();
  nationid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.nationId)
}

// required int32 officeItemId = 4;
inline bool ArenaFightReport::has_officeitemid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaFightReport::set_has_officeitemid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaFightReport::clear_has_officeitemid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaFightReport::clear_officeitemid() {
  officeitemid_ = 0;
  clear_has_officeitemid();
}
inline ::google::protobuf::int32 ArenaFightReport::officeitemid() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.officeItemId)
  return officeitemid_;
}
inline void ArenaFightReport::set_officeitemid(::google::protobuf::int32 value) {
  set_has_officeitemid();
  officeitemid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.officeItemId)
}

// required int32 level = 5;
inline bool ArenaFightReport::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaFightReport::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaFightReport::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaFightReport::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ArenaFightReport::level() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.level)
  return level_;
}
inline void ArenaFightReport::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.level)
}

// required int32 beforeRank = 6;
inline bool ArenaFightReport::has_beforerank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaFightReport::set_has_beforerank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaFightReport::clear_has_beforerank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaFightReport::clear_beforerank() {
  beforerank_ = 0;
  clear_has_beforerank();
}
inline ::google::protobuf::int32 ArenaFightReport::beforerank() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.beforeRank)
  return beforerank_;
}
inline void ArenaFightReport::set_beforerank(::google::protobuf::int32 value) {
  set_has_beforerank();
  beforerank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.beforeRank)
}

// required int32 afterRank = 7;
inline bool ArenaFightReport::has_afterrank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaFightReport::set_has_afterrank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaFightReport::clear_has_afterrank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaFightReport::clear_afterrank() {
  afterrank_ = 0;
  clear_has_afterrank();
}
inline ::google::protobuf::int32 ArenaFightReport::afterrank() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.afterRank)
  return afterrank_;
}
inline void ArenaFightReport::set_afterrank(::google::protobuf::int32 value) {
  set_has_afterrank();
  afterrank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.afterRank)
}

// required bool isWin = 8 [default = false];
inline bool ArenaFightReport::has_iswin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaFightReport::set_has_iswin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaFightReport::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaFightReport::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool ArenaFightReport::iswin() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.isWin)
  return iswin_;
}
inline void ArenaFightReport::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.isWin)
}

// required bool isAttact = 9 [default = false];
inline bool ArenaFightReport::has_isattact() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArenaFightReport::set_has_isattact() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArenaFightReport::clear_has_isattact() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArenaFightReport::clear_isattact() {
  isattact_ = false;
  clear_has_isattact();
}
inline bool ArenaFightReport::isattact() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.isAttact)
  return isattact_;
}
inline void ArenaFightReport::set_isattact(bool value) {
  set_has_isattact();
  isattact_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.isAttact)
}

// required int64 time = 10;
inline bool ArenaFightReport::has_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ArenaFightReport::set_has_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ArenaFightReport::clear_has_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ArenaFightReport::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ArenaFightReport::time() const {
  // @@protoc_insertion_point(field_get:main.ArenaFightReport.time)
  return time_;
}
inline void ArenaFightReport::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaFightReport.time)
}

// -------------------------------------------------------------------

// ArenaBaseInfo

// required int32 zhengfudian = 1;
inline bool ArenaBaseInfo::has_zhengfudian() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaBaseInfo::set_has_zhengfudian() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaBaseInfo::clear_has_zhengfudian() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaBaseInfo::clear_zhengfudian() {
  zhengfudian_ = 0;
  clear_has_zhengfudian();
}
inline ::google::protobuf::int32 ArenaBaseInfo::zhengfudian() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.zhengfudian)
  return zhengfudian_;
}
inline void ArenaBaseInfo::set_zhengfudian(::google::protobuf::int32 value) {
  set_has_zhengfudian();
  zhengfudian_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.zhengfudian)
}

// required int32 count = 2;
inline bool ArenaBaseInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaBaseInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaBaseInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaBaseInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ArenaBaseInfo::count() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.count)
  return count_;
}
inline void ArenaBaseInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.count)
}

// required int32 maxCount = 3;
inline bool ArenaBaseInfo::has_maxcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaBaseInfo::set_has_maxcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaBaseInfo::clear_has_maxcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaBaseInfo::clear_maxcount() {
  maxcount_ = 0;
  clear_has_maxcount();
}
inline ::google::protobuf::int32 ArenaBaseInfo::maxcount() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.maxCount)
  return maxcount_;
}
inline void ArenaBaseInfo::set_maxcount(::google::protobuf::int32 value) {
  set_has_maxcount();
  maxcount_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.maxCount)
}

// required string info = 4;
inline bool ArenaBaseInfo::has_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaBaseInfo::set_has_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaBaseInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaBaseInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ArenaBaseInfo::info() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.info)
  return *info_;
}
inline void ArenaBaseInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.info)
}
inline void ArenaBaseInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ArenaBaseInfo.info)
}
inline void ArenaBaseInfo::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ArenaBaseInfo.info)
}
inline ::std::string* ArenaBaseInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ArenaBaseInfo.info)
  return info_;
}
inline ::std::string* ArenaBaseInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArenaBaseInfo::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaBaseInfo.info)
}

// required int64 surplusTime = 5;
inline bool ArenaBaseInfo::has_surplustime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaBaseInfo::set_has_surplustime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaBaseInfo::clear_has_surplustime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaBaseInfo::clear_surplustime() {
  surplustime_ = GOOGLE_LONGLONG(0);
  clear_has_surplustime();
}
inline ::google::protobuf::int64 ArenaBaseInfo::surplustime() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.surplusTime)
  return surplustime_;
}
inline void ArenaBaseInfo::set_surplustime(::google::protobuf::int64 value) {
  set_has_surplustime();
  surplustime_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.surplusTime)
}

// required int64 canRewardCount = 6;
inline bool ArenaBaseInfo::has_canrewardcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaBaseInfo::set_has_canrewardcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaBaseInfo::clear_has_canrewardcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaBaseInfo::clear_canrewardcount() {
  canrewardcount_ = GOOGLE_LONGLONG(0);
  clear_has_canrewardcount();
}
inline ::google::protobuf::int64 ArenaBaseInfo::canrewardcount() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.canRewardCount)
  return canrewardcount_;
}
inline void ArenaBaseInfo::set_canrewardcount(::google::protobuf::int64 value) {
  set_has_canrewardcount();
  canrewardcount_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.canRewardCount)
}

// required int32 cdTime = 7;
inline bool ArenaBaseInfo::has_cdtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaBaseInfo::set_has_cdtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaBaseInfo::clear_has_cdtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaBaseInfo::clear_cdtime() {
  cdtime_ = 0;
  clear_has_cdtime();
}
inline ::google::protobuf::int32 ArenaBaseInfo::cdtime() const {
  // @@protoc_insertion_point(field_get:main.ArenaBaseInfo.cdTime)
  return cdtime_;
}
inline void ArenaBaseInfo::set_cdtime(::google::protobuf::int32 value) {
  set_has_cdtime();
  cdtime_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaBaseInfo.cdTime)
}

// -------------------------------------------------------------------

// ArenaRoleInfo

// required int32 roleId = 1;
inline bool ArenaRoleInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaRoleInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaRoleInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaRoleInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 ArenaRoleInfo::roleid() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.roleId)
  return roleid_;
}
inline void ArenaRoleInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.roleId)
}

// required string nickName = 2;
inline bool ArenaRoleInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaRoleInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaRoleInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaRoleInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ArenaRoleInfo::nickname() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.nickName)
  return *nickname_;
}
inline void ArenaRoleInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.nickName)
}
inline void ArenaRoleInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:main.ArenaRoleInfo.nickName)
}
inline void ArenaRoleInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:main.ArenaRoleInfo.nickName)
}
inline ::std::string* ArenaRoleInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:main.ArenaRoleInfo.nickName)
  return nickname_;
}
inline ::std::string* ArenaRoleInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArenaRoleInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:main.ArenaRoleInfo.nickName)
}

// required int32 nationId = 3;
inline bool ArenaRoleInfo::has_nationid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaRoleInfo::set_has_nationid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaRoleInfo::clear_has_nationid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaRoleInfo::clear_nationid() {
  nationid_ = 0;
  clear_has_nationid();
}
inline ::google::protobuf::int32 ArenaRoleInfo::nationid() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.nationId)
  return nationid_;
}
inline void ArenaRoleInfo::set_nationid(::google::protobuf::int32 value) {
  set_has_nationid();
  nationid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.nationId)
}

// required int32 officeItemId = 4;
inline bool ArenaRoleInfo::has_officeitemid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaRoleInfo::set_has_officeitemid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaRoleInfo::clear_has_officeitemid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaRoleInfo::clear_officeitemid() {
  officeitemid_ = 0;
  clear_has_officeitemid();
}
inline ::google::protobuf::int32 ArenaRoleInfo::officeitemid() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.officeItemId)
  return officeitemid_;
}
inline void ArenaRoleInfo::set_officeitemid(::google::protobuf::int32 value) {
  set_has_officeitemid();
  officeitemid_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.officeItemId)
}

// required int32 level = 5;
inline bool ArenaRoleInfo::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaRoleInfo::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaRoleInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaRoleInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ArenaRoleInfo::level() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.level)
  return level_;
}
inline void ArenaRoleInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.level)
}

// required int32 rank = 6;
inline bool ArenaRoleInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaRoleInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaRoleInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaRoleInfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ArenaRoleInfo::rank() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.rank)
  return rank_;
}
inline void ArenaRoleInfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.rank)
}

// required int32 combatValue = 7;
inline bool ArenaRoleInfo::has_combatvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaRoleInfo::set_has_combatvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaRoleInfo::clear_has_combatvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaRoleInfo::clear_combatvalue() {
  combatvalue_ = 0;
  clear_has_combatvalue();
}
inline ::google::protobuf::int32 ArenaRoleInfo::combatvalue() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.combatValue)
  return combatvalue_;
}
inline void ArenaRoleInfo::set_combatvalue(::google::protobuf::int32 value) {
  set_has_combatvalue();
  combatvalue_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.combatValue)
}

// required int32 zhengfudian = 8;
inline bool ArenaRoleInfo::has_zhengfudian() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaRoleInfo::set_has_zhengfudian() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaRoleInfo::clear_has_zhengfudian() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaRoleInfo::clear_zhengfudian() {
  zhengfudian_ = 0;
  clear_has_zhengfudian();
}
inline ::google::protobuf::int32 ArenaRoleInfo::zhengfudian() const {
  // @@protoc_insertion_point(field_get:main.ArenaRoleInfo.zhengfudian)
  return zhengfudian_;
}
inline void ArenaRoleInfo::set_zhengfudian(::google::protobuf::int32 value) {
  set_has_zhengfudian();
  zhengfudian_ = value;
  // @@protoc_insertion_point(field_set:main.ArenaRoleInfo.zhengfudian)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace main

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ArenaModule_2eproto__INCLUDED
